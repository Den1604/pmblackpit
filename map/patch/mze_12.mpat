#import Maze_MarioHPTracker.mpat % track if mario have 0hp

#new:Header $Header
{
[MainScript] $Script_Main
[Background] 80200000
[EntryList] $EntryList
[EntryCount] 3
[MapTattle]  $Function_GetTattle
}

#define .Chest *MapVar[0]
#define .Price *MapVar[1]

#new:Function_Init $Function_Init
{
PUSH 	RA, A0, A1
LIA 	A0, 800B0CF0
LIA 	A1, "tik_tex" 
JAL 	~Func:sprintf
RESERVED
COPY 	V0, R0
JPOP 	RA, A0, A1
}

#new:EntryList $EntryList
{
~Vec4f:Entry0
~Vec4f:Entry1
~Vec4f:Respawn
}

#new:Script_Main $Script_Main
{
Call    SetSpriteShading  	( -1` )
Call    SetCamPerspective 	( .Cam:Default 00000003 00000019 00000010 00001000 )
Call    SetCamBGColor     	( .Cam:Default 0 0 0 )
Call    SetCamEnabled       ( .Cam:Default .True )
Call    SetCamLeadPlayer    ( .Cam:Default .False )
Set     *Flag_LockInputs_GiantChest .True % lock player inputs at the moment he open a giant chest
Bind    $Script_StandAbove_None .Trigger:FloorAbove ~Collider:Center 00000001 00000000
Bind    $Script_StartMist .Trigger:FloorAbove ~Collider:StartMist 00000001 00000000
Bind    $Script_EndMist .Trigger:FloorAbove ~Collider:EndMist 00000001 00000000
Exec    $Script_MakeEntities
Call    GetEntryID ( *Var[0] )
If  *Var[0] == 2 % Respawn
    Exec    $Script_MakeExits
    Exec    $Script_RespawnPlayer
Else
    If *Var[0] != 0 % player don't comes from the maze
        Set     *MapFlag[00] .True
        Exec    $Script_LockChests
    EndIf
    Set	   *Var[0] $Script_MakeExits
    Exec    EnterWalk
    Exec    $Script_KillMario % track mario hp
    Wait    1
EndIf
Return
End
}

#new:Script $Script_RespawnPlayer
{
Call DisablePlayerInput ( .True )
Set *Flag_Dungeon .False % Disable Timer
/% Display the current star pieces if all chests haven't been opened
Set *Var[0] *Flag_ChestRoom_1
Add *Var[0] *Flag_ChestRoom_2
Add *Var[0] *Flag_ChestRoom_3
Add *Var[0] *Flag_ChestRoom_4
Add *Var[0] *Flag_ChestRoom_5
Add *Var[0] *Flag_ChestRoom_6
Add *Var[0] *Flag_ChestRoom_7
Add *Var[0] *Flag_ChestRoom_8
Add *Var[0] *Flag_ChestRoom_9
If  *Var[0] != 9
    Set *Flag_Dungeon_Lobby .True
EndIf%/
Set *Flag_Dungeon_Lobby .True
% Fully Restore HP, FP and Star Power
% HP
Call $ReadAddress       ( 8010F293 0 *Var[0] .False .False ) % get max hp
Call $WriteAddress      ( 8010F292 0 *Var[0] .False .False ) % set hp as max
% FP
Call $ReadAddress       ( 8010F296 0 *Var[0] .False .False ) % get max fp
Call $WriteAddress      ( 8010F295 0 *Var[0] .False .False ) % set fp as max
% Star Power
Call FullyRestoreSP
Call SetPlayerAnimation ( 00010002 ) % idle
Call SetPlayerAnimation ( 0001000F ) % Dead
Wait 32`
Call SetPlayerAnimation ( 00010030 ) % Get Up
Wait 16`
% Check Partner
Call $ReadAddress ( 8010F2AC 0 *Var[0] .False .False ) % get goombario byte, to know if last floor was a trap one
% Activate partners
If  *Var[0] == .False
    % Goombario
    Call $ReadAddress ( $Maze_PartnerData 0 *Var[0] 0 .False )
    If *Var[0] == .True
        Call $WriteAddress ( 8010F2AC 0 .True .False .False )
    EndIf
    % Kooper
    Call $ReadAddress ( $Maze_PartnerData 0 *Var[0] 1 .False )
    If *Var[0] == .True
        Call $WriteAddress ( 8010F2B4 0 .True .False .False )
    EndIf
    % Bombette
    Call $ReadAddress ( $Maze_PartnerData 0 *Var[0] 2 .False )
    If *Var[0] == .True
        Call $WriteAddress ( 8010F2BC 0 .True .False .False )
    EndIf
    % Parakarry
    Call $ReadAddress ( $Maze_PartnerData 0 *Var[0] 3 .False )
    If *Var[0] == .True
        Call $WriteAddress ( 8010F2C4 0 .True .False .False )
    EndIf
    % Bow
    Call $ReadAddress ( $Maze_PartnerData 0 *Var[0] 4 .False )
    If *Var[0] == .True
        Call $WriteAddress ( 8010F2EC 0 .True .False .False )
    EndIf
    % Watt
    Call $ReadAddress ( $Maze_PartnerData 0 *Var[0] 5 .False )
    If *Var[0] == .True
        Call $WriteAddress ( 8010F2D4 0 .True .False .False )
    EndIf
    % Sushie
    Call $ReadAddress ( $Maze_PartnerData 0 *Var[0] 6 .False )
    If *Var[0] == .True
        Call $WriteAddress ( 8010F2DC 0 .True .False .False )
    EndIf
    % Lakilester
    Call $ReadAddress ( $Maze_PartnerData 0 *Var[0] 7 .False )
    If *Var[0] == .True
        Call $WriteAddress ( 8010F2E4 0 .True .False .False )
    EndIf
    % Nuke $Maze_PartnerData
    Call $WriteAddress ( $Maze_PartnerData 2 .False 0 .False ) % 1st word
    Call $WriteAddress ( $Maze_PartnerData 2 .False 4 .False ) % 2nd word
    Thread % Respawn Partner
        Wait    6
        Set     *LastPartnerUsed *AreaByte[F]
        Call    $RespawnPartner ( *LastPartner )
    EndThread
EndIf
Set *AreaByte[F] 0
Set *AreaFlag[0A0] .False
Set *AreaFlag[0A1] .False
% Get New set of Enemies % in mze_12 only happen when you die
Loop
    Call    RandInt ( 7 *Var[0] ) % AreaByte[1] = Enemies Group ID
    If  *Var[0] != *AreaByte[1]
        Set *AreaByte[1] *Var[0]
        BreakLoop
    EndIf
EndLoop
Call    $WriteAddress ( 80356130 1 .False .False .False ) % nuke temp star pieces
Call    DisablePlayerInput ( .False )
Exec    $Script_KillMario % track mario hp
Return
End
}

#new:Function $RespawnPartner
{
	PUSH	RA
	LW      V0, C (A0)
    JAL     ~Func:get_variable
   	LW      A1, 0 (V0)
   	SLL     V0, V0, 18
   	JAL     800EB168
   	SRA     A0, V0, 18
   	POP		RA
   	JR      RA
	ADDIU   V0, R0, 2
}

#new:Script $Script_MakeEntities
{
Call    MakeEntity 	 ( .Entity:GiantChest ~Vec4d:Chest1 80000000 )
Call    AssignFlag   ( *Flag_ChestRoom_1 )
Call    AssignScript ( $Script_Chest_HP1 )
Call    MakeEntity 	 ( .Entity:GiantChest ~Vec4d:Chest2 80000000 )
Call    AssignFlag   ( *Flag_ChestRoom_2 )
Call    AssignScript ( $Script_Chest_HP2 )
Call    MakeEntity 	 ( .Entity:GiantChest ~Vec4d:Chest3 80000000 )
Call    AssignFlag   ( *Flag_ChestRoom_3 )
Call    AssignScript ( $Script_Chest_HP3 )
Call    MakeEntity 	 ( .Entity:GiantChest ~Vec4d:Chest4 80000000 )
Call    AssignFlag   ( *Flag_ChestRoom_4 )
Call    AssignScript ( $Script_Chest_HP4 )
Call    MakeEntity 	 ( .Entity:GiantChest ~Vec4d:Chest5 80000000 )
Call    AssignFlag   ( *Flag_ChestRoom_5 )
Call    AssignScript ( $Script_Chest_FP1 )
Call    MakeEntity 	 ( .Entity:GiantChest ~Vec4d:Chest6 80000000 )
Call    AssignFlag   ( *Flag_ChestRoom_6 )
Call    AssignScript ( $Script_Chest_FP2 )
Call    MakeEntity 	 ( .Entity:GiantChest ~Vec4d:Chest7 80000000 )
Call    AssignFlag   ( *Flag_ChestRoom_7 )
Call    AssignScript ( $Script_Chest_FP3 )
Call    MakeEntity 	 ( .Entity:GiantChest ~Vec4d:Chest8 80000000 )
Call    AssignFlag   ( *Flag_ChestRoom_8 )
Call    AssignScript ( $Script_Chest_FP4 )
Call    MakeEntity 	 ( .Entity:GiantChest ~Vec4d:Chest9 80000000 )
Call    AssignFlag   ( *Flag_ChestRoom_9 )
Call    AssignScript ( $Script_Chest_FP5 )
Return
End
}

#new:Script $Script_LockChests
{
    Call    $ReadAddress ( 8035612C 1 *Var[4] .False .False ) % load star pieces
    If *Flag_ChestRoom_1 == .True
        Call    ModifyColliderFlags ( .False ~Collider:Chest1 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest1 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest1 7FFFFE00 )
    Else
        Bind    $Script_StandAbove_Chest_HP1 .Trigger:FloorAbove ~Collider:StandAbove_Chest1 00000001 00000000
        % Bind this trigger only if the player can buy this chest
        If  *Var[4] >= 200` % Amount needed to open this chest
            Bind    $Script_BuyChest .Trigger:WallPressA ~Collider:Trigger_Chest1 00000001 00000000
        EndIf
    EndIf
    If *Flag_ChestRoom_2 == .True
        Call    ModifyColliderFlags ( .False ~Collider:Chest2 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest2 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest2 7FFFFE00 )
    Else
        Bind    $Script_StandAbove_Chest_HP2 .Trigger:FloorAbove ~Collider:StandAbove_Chest2 00000001 00000000
        % Bind this trigger only if the player can buy this chest
        If  *Var[4] >= 350` % Amount needed to open this chest
            Bind    $Script_BuyChest .Trigger:WallPressA ~Collider:Trigger_Chest2 00000001 00000000
        EndIf
    EndIf
    If *Flag_ChestRoom_3 == .True
        Call    ModifyColliderFlags ( .False ~Collider:Chest3 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest3 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest3 7FFFFE00 )
    Else
        Bind    $Script_StandAbove_Chest_HP3 .Trigger:FloorAbove ~Collider:StandAbove_Chest3 00000001 00000000
        % Bind this trigger only if the player can buy this chest
        If  *Var[4] >= 350` % Amount needed to open this chest
            Bind    $Script_BuyChest .Trigger:WallPressA ~Collider:Trigger_Chest3 00000001 00000000
        EndIf
    EndIf
    If *Flag_ChestRoom_4 == .True
        Call    ModifyColliderFlags ( .False ~Collider:Chest4 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest4 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest4 7FFFFE00 )
    Else
        Bind    $Script_StandAbove_Chest_HP4 .Trigger:FloorAbove ~Collider:StandAbove_Chest4 00000001 00000000
        % Bind this trigger only if the player can buy this chest
        If  *Var[4] >= 500` % Amount needed to open this chest
            Bind    $Script_BuyChest .Trigger:WallPressA ~Collider:Trigger_Chest4 00000001 00000000
        EndIf
    EndIf
    If *Flag_ChestRoom_5 == .True
        Call    ModifyColliderFlags ( .False ~Collider:Chest5 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest5 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest5 7FFFFE00 )
    Else
        Bind    $Script_StandAbove_Chest_FP1 .Trigger:FloorAbove ~Collider:StandAbove_Chest5 00000001 00000000
        % Bind this trigger only if the player can buy this chest
        If  *Var[4] >= 200` % Amount needed to open this chest
            Bind    $Script_BuyChest .Trigger:WallPressA ~Collider:Trigger_Chest5 00000001 00000000
        EndIf
    EndIf
    If *Flag_ChestRoom_6 == .True
        Call    ModifyColliderFlags ( .False ~Collider:Chest6 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest6 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest6 7FFFFE00 )
    Else
        Bind    $Script_StandAbove_Chest_FP2 .Trigger:FloorAbove ~Collider:StandAbove_Chest6 00000001 00000000
        % Bind this trigger only if the player can buy this chest
        If  *Var[4] >= 350` % Amount needed to open this chest
            Bind    $Script_BuyChest .Trigger:WallPressA ~Collider:Trigger_Chest6 00000001 00000000
        EndIf
    EndIf
    If *Flag_ChestRoom_7 == .True
        Call    ModifyColliderFlags ( .False ~Collider:Chest7 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest7 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest7 7FFFFE00 )
    Else
        Bind    $Script_StandAbove_Chest_FP3 .Trigger:FloorAbove ~Collider:StandAbove_Chest7 00000001 00000000
        % Bind this trigger only if the player can buy this chest
        If  *Var[4] >= 350` % Amount needed to open this chest
            Bind    $Script_BuyChest .Trigger:WallPressA ~Collider:Trigger_Chest7 00000001 00000000
        EndIf
    EndIf
    If *Flag_ChestRoom_8 == .True
        Call    ModifyColliderFlags ( .False ~Collider:Chest8 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest8 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest8 7FFFFE00 )
    Else
        Bind    $Script_StandAbove_Chest_FP4 .Trigger:FloorAbove ~Collider:StandAbove_Chest8 00000001 00000000
        % Bind this trigger only if the player can buy this chest
        If  *Var[4] >= 350` % Amount needed to open this chest
            Bind    $Script_BuyChest .Trigger:WallPressA ~Collider:Trigger_Chest8 00000001 00000000
        EndIf
    EndIf
    If *Flag_ChestRoom_9 == .True
        Call    ModifyColliderFlags ( .False ~Collider:Chest9 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest9 7FFFFE00 )
        Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest9 7FFFFE00 )
    Else
        Bind    $Script_StandAbove_Chest_FP5 .Trigger:FloorAbove ~Collider:StandAbove_Chest9 00000001 00000000
        % Bind this trigger only if the player can buy this chest
        If  *Var[4] >= 350` % Amount needed to open this chest
            Bind    $Script_BuyChest .Trigger:WallPressA ~Collider:Trigger_Chest9 00000001 00000000
        EndIf
    EndIf
    Return
    End
}

#new:Script $Script_StartMist
{
If *Flag_Dungeon != .True
    Set *Flag_Dungeon .True % Enable Timer
    Set *Flag_Dungeon_Lobby .False
    ExecWait $Script_GetNewTrapsData
    ExecWait $Script_GetChestsData
    ExecWait $Script_GetSpecialChestsData
    ExecWait $Script_SavePartnersData
    % Get Set of Enemies % not in mze_12
    %Call    RandInt ( 7 *AreaByte[1] ) % AreaByte[1] = Enemies Group ID
    %Set     *AreaByte[1] 0 % testing
    Call    $Function_SetMazeTimer
EndIf
Return
End
}

#new:Script $Script_EndMist
{
Set *AreaByte[2] 1 % last lobby, used when respawning
Set *Flag_Dungeon .False % Disable Timer
% Refill timer
Call $WriteAddress ( $DungeonTimer 0 D0 .False .False )
% Reset all flags
% Chests Opened Flags
Set *Flag_Maze_Map1_Chest1 .False
Set *Flag_Maze_Map1_Chest2 .False
Set *Flag_Maze_Map2_Chest1 .False
Set *Flag_Maze_Map2_Chest2 .False
Set *Flag_Maze_Map4_Chest1 .False
Set *Flag_Maze_Map4_Chest2 .False
Set *Flag_Maze_Map5_Chest1 .False
Set *Flag_Maze_Map5_Chest2 .False
Set *Flag_Maze_Map6_Chest1 .False
Set *Flag_Maze_Map6_Chest2 .False
Set *Flag_Maze_Map8_Chest1 .False
Set *Flag_Maze_Map8_Chest2 .False
Set *Flag_Maze_Map9_Chest1 .False
Set *Flag_Maze_Map9_Chest2 .False
Set *Flag_Maze_Map10_Chest1 .False
Set *Flag_Maze_Map10_Chest2 .False
Set *Flag_Maze_Map12_Chest1 .False
Set *Flag_Maze_Map12_Chest2 .False
Set *Flag_Maze_Map13_Chest1 .False
Set *Flag_Maze_Map13_Chest2 .False
Set *Flag_Maze_Map14_Chest1 .False
Set *Flag_Maze_Map14_Chest2 .False
Set *Flag_Maze_Map16_Chest1 .False
Set *Flag_Maze_Map16_Chest2 .False
Set *Flag_Maze_Map17_Chest1 .False
Set *Flag_Maze_Map17_Chest2 .False
Set *Flag_Maze_Map18_Chest1 .False
Set *Flag_Maze_Map18_Chest2 .False
Set *Flag_Maze_Map19_Chest1 .False
Set *Flag_Maze_Map19_Chest2 .False
Set *Flag_Maze_Map20_Chest1 .False
Set *Flag_Maze_Map20_Chest2 .False
Set *Flag_Maze_SpecialChest1 .False
Set *Flag_Maze_SpecialChest2 .False
Set *Flag_Maze_HiddenBlock5 .False
Set *Flag_Maze_HiddenBlock9 .False
Set *Flag_Maze_HiddenBlock13 .False
%Set *Flag_LockInputs_GiantChest .False % not in mze_12
% Reset Enemies Defeated Flags
Set *AreaFlag[000] .False
Set *AreaFlag[001] .False
Set *AreaFlag[002] .False
Set *AreaFlag[003] .False
Set *AreaFlag[004] .False
Set *AreaFlag[005] .False
Set *AreaFlag[006] .False
Set *AreaFlag[007] .False
Set *AreaFlag[008] .False
Set *AreaFlag[009] .False
Set *AreaFlag[00A] .False
Set *AreaFlag[00B] .False
Set *AreaFlag[00C] .False
Set *AreaFlag[00D] .False
Set *AreaFlag[00E] .False
% Fuzzies' Flags
Set *Flag_Maze_Fuzzy1 .False
Set *Flag_Maze_Fuzzy2 .False
Set *Flag_Maze_Fuzzy3 .False
% Enemies
%Set *AreaByte[1] .Default % not in mze_12
% Save new Star Pieces
Call $ReadAddress ( 8035612C 1 *Var[0] 0 .False ) % get Star Pieces
Call $ReadAddress ( 80356130 1 *Var[1] 0 .False ) % get temporary Star Pieces
If *Var[1] >= 500`
    Set *Flag_Cheev_Dungeon_02 .True
EndIf
Add  *Var[0] *Var[1]
If  *Var[0] > 9999` % star pieces cap
    Set *Var[0] 9999`
EndIf
Call $WriteAddress ( 8035612C 1 *Var[0] 0 .False ) % Save new Star Pieces
Set *Maze_ChestsOpened_CurrentP .False
Call $Function_NukeTrapsData % Restart trap's data
% Clear Enemies Defeated Flags (RAM)
Call $CleanEnemiesFlags
/% Display the current star pieces if all chests haven't been opened
Set *Var[0] *Flag_ChestRoom_1
Add *Var[0] *Flag_ChestRoom_2
Add *Var[0] *Flag_ChestRoom_3
Add *Var[0] *Flag_ChestRoom_4
Add *Var[0] *Flag_ChestRoom_5
Add *Var[0] *Flag_ChestRoom_6
Add *Var[0] *Flag_ChestRoom_7
Add *Var[0] *Flag_ChestRoom_8
Add *Var[0] *Flag_ChestRoom_9
If  *Var[0] != 9
    Set *Flag_Dungeon_Lobby .True
EndIf%/
Set *Flag_Dungeon_Lobby .True
% Fully Restore HP, FP and Star Power
% HP
Call $ReadAddress       ( 8010F293 0 *Var[0] .False .False ) % get max hp
Call $WriteAddress      ( 8010F292 0 *Var[0] .False .False ) % set hp as max
% FP
Call $ReadAddress       ( 8010F296 0 *Var[0] .False .False ) % get max fp
Call $WriteAddress      ( 8010F295 0 *Var[0] .False .False ) % set fp as max
% Star Power
Call FullyRestoreSP
% Nuke $Maze_PartnerData
Call $WriteAddress ( $Maze_PartnerData 2 .False 0 .False ) % 1st word
Call $WriteAddress ( $Maze_PartnerData 2 .False 4 .False ) % 2nd word
% Bind Chests if they haven't been binded
If *MapFlag[00] == .False
    Set     *MapFlag[00] .True
    Exec    $Script_LockChests
EndIf
Return
End
}

#new:Script $Script_StandAbove_None
{
Set .Chest .False
Set *Flag_ChestRoom_Price .False
% Fully Restore HP, FP and Star Power
% HP
Call $ReadAddress       ( 8010F293 0 *Var[0] .False .False ) % get max hp
Call $WriteAddress      ( 8010F292 0 *Var[0] .False .False ) % set hp as max
% FP
Call $ReadAddress       ( 8010F296 0 *Var[0] .False .False ) % get max fp
Call $WriteAddress      ( 8010F295 0 *Var[0] .False .False ) % set fp as max
% Star Power
Call FullyRestoreSP
Return
End
}

#new:Script $Script_StandAbove_Chest_HP1
{
Set .Chest 1 % current chest
Set .Price 200` % Star Pieces needed to open this chest
Set *Flag_ChestRoom_Price .True
Return
End
}

#new:Script $Script_StandAbove_Chest_HP2
{
Set .Chest 2 % current chest
Set .Price 350` % Star Pieces needed to open this chest
Set *Flag_ChestRoom_Price .True
Return
End
}

#new:Script $Script_StandAbove_Chest_HP3
{
Set .Chest 3 % current chest
Set .Price 350` % Star Pieces needed to open this chest
Set *Flag_ChestRoom_Price .True
Return
End
}

#new:Script $Script_StandAbove_Chest_HP4
{
Set .Chest 4 % current chest
Set .Price 500` % Star Pieces needed to open this chest
Set *Flag_ChestRoom_Price .True
Return
End
}

#new:Script $Script_StandAbove_Chest_FP1
{
Set .Chest 5 % current chest
Set .Price 200`
Set *Flag_ChestRoom_Price .True
Return
End
}

#new:Script $Script_StandAbove_Chest_FP2
{
Set .Chest 6 % current chest
Set .Price 350`
Set *Flag_ChestRoom_Price .True
Return
End
}

#new:Script $Script_StandAbove_Chest_FP3
{
Set .Chest 7 % current chest
Set .Price 350`
Set *Flag_ChestRoom_Price .True
Return
End
}

#new:Script $Script_StandAbove_Chest_FP4
{
Set .Chest 8 % current chest
Set .Price 350`
Set *Flag_ChestRoom_Price .True
Return
End
}

#new:Script $Script_StandAbove_Chest_FP5
{
Set .Chest 9 % current chest
Set .Price 350`
Set *Flag_ChestRoom_Price .True
Return
End
}

#new:Script $Script_Chest_HP1
{
    Set *Var[4] 0 % HP Chest
    Set *Var[5] 5 % Amount to increment HP cap
    ExecWait $Script_UseChest
    Return
    End
}

#new:Script $Script_Chest_HP2
{
    Set *Var[4] 0 % HP Chest
    Set *Var[5] 10` % Amount to increment HP cap
    ExecWait $Script_UseChest
    Return
    End
}

#new:Script $Script_Chest_HP3
{
    Set *Var[4] 0 % HP Chest
    Set *Var[5] 10` % Amount to increment HP cap
    ExecWait $Script_UseChest
    Return
    End
}

#new:Script $Script_Chest_HP4
{
    Set *Var[4] 0 % HP Chest
    Set *Var[5] 15` % Amount to increment HP cap
    ExecWait $Script_UseChest
    Return
    End
}

#new:Script $Script_Chest_FP1
{
    Set *Var[4] 1 % FP Chest
    Set *Var[5] 5 % Amount to increment FP cap
    ExecWait $Script_UseChest
    Return
    End
}

#new:Script $Script_Chest_FP2
{
    Set *Var[4] 1 % FP Chest
    Set *Var[5] 10` % Amount to increment FP cap
    ExecWait $Script_UseChest
    Return
    End
}

#new:Script $Script_Chest_FP3
{
    Set *Var[4] 1 % FP Chest
    Set *Var[5] 10` % Amount to increment FP cap
    ExecWait $Script_UseChest
    Return
    End
}

#new:Script $Script_Chest_FP4
{
    Set *Var[4] 1 % FP Chest
    Set *Var[5] 10` % Amount to increment FP cap
    ExecWait $Script_UseChest
    Return
    End
}

#new:Script $Script_Chest_FP5
{
    Set *Var[4] 1 % FP Chest
    Set *Var[5] 10` % Amount to increment FP cap
    ExecWait $Script_UseChest
    Return
    End
}

#new:Script $Script_BuyChest
{
    Call    DisablePlayerInput ( .True )
    Call    $ReadAddress ( 8035612C 1 *Var[0] .False .False ) % load star pieces
    If *Var[0] < .Price
        Call	ShowMessageAtScreenPos ( $String_CantOpen A0 28 )
        Call    DisablePlayerInput ( .False )
        Return
    EndIf
    Call	ShowMessageAtScreenPos ( $String_Confirmation A0 28 )
    Call    ShowChoice    ( 001E001D ) % yes no
    If  *Var[0] != 0 % no
        Call    CloseMessage
        Call    DisablePlayerInput ( .False )
        Return
    EndIf
    Call    CloseMessage
    Set  *Var[1] .Price
    SetTimescale *Fixed[15.0]
    Loop *Var[1] % Amount to substract
        Call    $ReadAddress   ( 8035612C 1 *Var[0] 0 .False ) % get star pieces
        Sub     *Var[0] 1 % substract 1 by 1
        Call    $WriteAddress  ( 8035612C 1 *Var[0] 0 .False ) % get star pieces
        Call    PlaySound ( 0215 )
        Wait    1
    EndLoop
    SetTimescale *Fixed[1.0]
    % Disable Chest Colliders
    Switch .Chest % current chest, loaded by current collider mario is standing
        Case == 1 % Chest 1
            Call    ModifyColliderFlags ( .False ~Collider:Chest1 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest1 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest1 7FFFFE00 )
            Set     *Var[0] 0 % entity ID
        Case == 2 % Chest 2
            Call    ModifyColliderFlags ( .False ~Collider:Chest2 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest2 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest2 7FFFFE00 )
            Set     *Var[0] 1 % entity ID
        Case == 3 % Chest 3
            Call    ModifyColliderFlags ( .False ~Collider:Chest3 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest3 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest3 7FFFFE00 )
            Set     *Var[0] 2 % entity ID
        Case == 4 % Chest 4
            Call    ModifyColliderFlags ( .False ~Collider:Chest4 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest4 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest4 7FFFFE00 )
            Set     *Var[0] 3 % entity ID
        Case == 5 % ...
            Call    ModifyColliderFlags ( .False ~Collider:Chest5 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest5 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest5 7FFFFE00 )
            Set     *Var[0] 4 % entity ID
        Case == 6
            Call    ModifyColliderFlags ( .False ~Collider:Chest6 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest6 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest6 7FFFFE00 )
            Set     *Var[0] 5 % entity ID
        Case == 7
            Call    ModifyColliderFlags ( .False ~Collider:Chest7 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest7 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest7 7FFFFE00 )
            Set     *Var[0] 6 % entity ID
        Case == 8
            Call    ModifyColliderFlags ( .False ~Collider:Chest8 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest8 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest8 7FFFFE00 )
            Set     *Var[0] 7 % entity ID
        Case == 9
            Call    ModifyColliderFlags ( .False ~Collider:Chest9 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:Trigger_Chest9 7FFFFE00 )
            Call    ModifyColliderFlags ( .False ~Collider:StandAbove_Chest9 7FFFFE00 )
            Set     *Var[0] 8 % entity ID
    EndSwitch 
    % Open chest automatically
    Set     *Flag_AutoOpenChest .True % flag needed to being able to do this % hook at MiscHooks.patch
    % open chest
    % Get to the data of the chest
    Call    $GetEntityPointer ( *Var[0] *Var[0] )
    % ChestData(+6) > Set this address' bit3 as true to open the chest
    Call    $WriteBitFlag ( *Var[0] .False 6 3 .True )
    Call    PlaySound ( 2034 )
    % 8010EFCF = Player Misc Flags
    % bit4 = ! interact symbol active, readed by chests
    Loop 20`
        Call    $WriteBitFlag ( 8010EFCF .False .False 4 .True )
        Wait    1
    EndLoop
    Set     *Flag_AutoOpenChest .False
    Call    $WriteBitFlag ( 8010EFCF .False .False 4 .False ) % put bit4 back to Zero
    Call    DisablePlayerInput ( .False )
    Return
    End
}

#string $String_Confirmation
{
[STYLE:INSPECT][...]
Do you want to open this chest?
[Func_04][END]
}

#string $String_CantOpen
{
[STYLE:INSPECT][...]
You can't open this Chest.
[WAIT][END]
}

#new:Script $Script_UseChest
{	
	Call	ShowMessageAtScreenPos ( $String_P1_1 000000A0 00000028 )
	Loop 6
		Call	PlaySound ( 2095 ) % Eating
		Call	SetPlayerAnimation ( .PlayerAnim:Eat )
		Wait	10`
	EndLoop
	Call	SetPlayerAnimation ( .PlayerAnim:ThumbsUp ) % ThumbsUp
	Wait	25`
    Switch *Var[4] % Kind of Chest
        Case == 0 % HP
            Call    $ReadAddress ( 8010F293 0 *Var[6] .False .False ) % Load Max HP
            Add     *Var[6] *Var[5] % increase max hp
            Call    $WriteAddress ( 8010F292 0 *Var[6] 0 .False ) % set current hp as max hp
            Call    $WriteAddress ( 8010F292 0 *Var[6] 1 .False ) % save new hp cap 1
            Call    $WriteAddress ( 8010F292 0 *Var[6] 2 .False ) % save new hp cap 1
        Case == 1 % FP
            Call    $ReadAddress ( 8010F296 0 *Var[6] .False .False ) % Load Max FP
            Add     *Var[6] *Var[5] % increase max hp
            Call    $WriteAddress ( 8010F295 0 *Var[6] 0 .False ) % set current fp as max hp
            Call    $WriteAddress ( 8010F295 0 *Var[6] 1 .False ) % save new fp cap 1
            Call    $WriteAddress ( 8010F295 0 *Var[6] 2 .False ) % save new fp cap 1
    EndSwitch
	Call	GetPlayerPos	( *Var[0] *Var[1] *Var[2] )
	Call    PlayEffect  	( ~FX:PinkSparkles *Var[0] *Var[1] *Var[2] *Var[0] *Var[1] *Var[2] )
    Call	PlaySound       ( 0378 ) % Healing
    If  *Var[4] == 0 % HP
        Call    SetMessageString ( $String_HP 0 )
    Else % FP
        Call    SetMessageString ( $String_FP 0 )
    EndIf
    Call    SetMessageValue        ( *Var[5] 1 )
	Call	ShowMessageAtScreenPos ( $String_P1_2 A0 65` )
	Call	SetPlayerAnimation ( .PlayerAnim:StandStill )
    Set *Flag_Cheev_Dungeon_07 .True
    Set *Var[0] *Flag_ChestRoom_1
    Add *Var[0] *Flag_ChestRoom_2
    Add *Var[0] *Flag_ChestRoom_3
    Add *Var[0] *Flag_ChestRoom_4
    Add *Var[0] *Flag_ChestRoom_5
    Add *Var[0] *Flag_ChestRoom_6
    Add *Var[0] *Flag_ChestRoom_7
    Add *Var[0] *Flag_ChestRoom_8
    Add *Var[0] *Flag_ChestRoom_9
    If *Var[0] == 9
        Set *Flag_Cheev_Dungeon_08 .True
    EndIf
	Call    DisablePlayerInput	( .False )
	Return
	End
}

#string $String_HP
{
HP[END]
}

#string $String_FP
{
FP[END]
}

#string $String_P1_1
{
[STYLE:INSPECT][...]
It looks like some kind of
Mushroom.
[WAIT][END]
}

#string $String_P1_2
{
[STYLE:POPUP][...]
[Color:0A][PushColor]Max [Color:19][Var:00][PopColor] got increased by [Color:19][Var:01]
[WAIT][END]
}

#new:Function $Function_NukeTrapsData
{
SAW     R0, $Maze_Trap2_Data
SAW     R0, $Maze_Trap4_Data
SAW     R0, $Maze_Trap6_Data
SAW     R0, $Maze_Trap8_Data
SAW     R0, $Maze_Trap10_Data
SAW     R0, $Maze_Trap12_Data
SAW     R0, $Maze_Trap14_Data
SAW     R0, $Maze_Trap16_Data
SAW     R0, $Maze_Trap17_Data
SAW     R0, $Maze_Trap19_Data
SAW     R0, $Maze_ChestData_Map1_5
SAW     R0, $Maze_ChestData_Map9_13
SAW     R0, $Maze_ChestData_Map18_20
SAW     R0, $Maze_ChestData_Special1
SAW     R0, $Maze_ChestData_Special1_Blocks_Coords
SAW     R0, $Maze_ChestData_Special2
SAH     R0, 80356130 % temp star pieces
JR      RA
ADDIU   V0, R0, 2
}

#new:Function $CleanEnemiesFlags
{
% Nuke all Enemies Defeated flags from the Maze
% Each map use 12 Words (48 Bytes) the maze has 12 maps
% 12 * 12 = 144` (90)
ADDIU T1, R0, 0 % loop Counter
LIO   T0, 800B0FC0 % 1st Word (Map ID #0)
.Loop
SW    R0, 0 (T0)
ADDIU T0, T0, 4 % move to next word
ADDIU T1, T1, 1 % loop counter
ADDIU T2, R0, 90 % total loops to do
BNE   T1, T2, .Loop
NOP
JR    RA
ADDIU V0, R0, 2
}

#new:Script $Script_MakeExits
{
Bind     $Script_Exit0  .Trigger:FloorAbove ~Collider:Entry0 1 0
Bind     $Script_Exit1  .Trigger:FloorAbove ~Collider:Entry1 1 0
Return
End
}

#new:Script $Script_Exit0
{
Call     UseExitHeading  	( 3C 0 )
Exec     80285CF4 
Call     GotoMap         	( "mze_02" 1 )
Wait     100` 
Return
End
}

#new:Script $Script_Exit1
{
Call     UseExitHeading  	( 3C 1 )
Exec     80285CF4 
Call     GotoMap         	( "mze_13" 0 )
Wait     100` 
Return
End
}

% Get the data for all traps on this run
#new:Script $Script_GetNewTrapsData
{
    Set  *Var[1] 10` % because there 10 traps
    Loop *Var[1]
        % init vars
        Set *Var[0] 0
        Set *Var[2] 0
        Set *Var[3] 0
        Set *Var[4] 0
        Set *Var[5] 0
        Switch  *Var[1]
            Case == 10`
                Set     *Var[0] $Maze_Trap2_Data
            Case == 9
                Set     *Var[0] $Maze_Trap4_Data
            Case == 8
                Set     *Var[0] $Maze_Trap6_Data
            Case == 7
                Set     *Var[0] $Maze_Trap8_Data
            Case == 6
                Set     *Var[0] $Maze_Trap10_Data
            Case == 5
                Set     *Var[0] $Maze_Trap12_Data
            Case == 4
                Set     *Var[0] $Maze_Trap14_Data
            Case == 3
                Set     *Var[0] $Maze_Trap16_Data
            Case == 2
                Set     *Var[0] $Maze_Trap17_Data
            Case == 1
                Set     *Var[0] $Maze_Trap19_Data
        EndSwitch
        % Get Trap
        Call    RandInt ( 10` *Var[2] )
        Call    $WriteAddress ( *Var[0] 0 *Var[2] 0 .False ) % Trap ID
        % Get Trap Var
        Switch  *Var[2]
            CaseOR == 0 % Spikes - 1 Side - Middle Hole to surpass it
            CaseOR == 5 % Walls - 1 Side
            CaseOR == 6 % Walls - 2 Sides
            CaseOR == 7 % Walls - 1 Side - The first and last wall crash with another moving wall
            CaseOR == 9 % Walls - 2 Sides - 1 side has a chest at the end
                Call    RandInt ( 1 *Var[3] )
            EndCaseGroup
            Default % For traps that doesn't use trap var
                Set *Var[3] 0
        EndSwitch
        Call    $WriteAddress ( *Var[0] 0 *Var[3] 1 .False ) % Trap Var
        % Get Chest Spawn Post
        % If you want to know the location of each chest platform value look at mze_09.mpat
        % An ASCII map is above Script_EnableModels_ChestPlatform_1
        Switch  *Var[2]
            CaseOR == 0 % Spikes - 1 Side - Middle Hole to surpass it
            CaseOR == 5 % Walls - 1 Side
                Call    RandInt ( 100` *Var[5] )
                If  *Var[5] < 60` % 60% chance to spawn a chest
                    If *Var[5] < 30` % 30% chance to spawn 2 chests
                        Set *Var[4] 10`
                    Else
                        Call    RandInt ( 1 *Var[5] )
                        % Read Trap Var
                        If *Var[3] == 0 % Left
                            If *Var[5] == 0
                                Set *Var[4] 2
                            Else
                                Set *Var[4] 1
                            EndIf
                        Else % Right
                            If *Var[5] == 0
                                Set *Var[4] 2
                            Else
                                Set *Var[4] 3
                            EndIf
                        EndIf
                    EndIf
                EndIf
            EndCaseGroup
            CaseOR == 1 % Spikes - 2 Sides - Middle Hole to surpass it
            CaseOR == 2 % Spikes - 2 Sides - Spikes move on different directions (you don't need the middle hole)
                Call    RandInt ( 100` *Var[5] )
                If  *Var[5] < 60` % 60% chance to spawn a chest
                    If *Var[5] < 30` % 30% chance to spawn 2 chests
                        % This chests can't spawn if the middle pillars are thinn
                        If *Var[3] == 0
                            Set *Var[4] 10`
                        Else
                            Set *Var[4] 0 % Don't spawn any chests
                        EndIf
                    Else
                        Set *Var[4] 2
                    EndIf
                EndIf
            EndCaseGroup
            CaseOR == 3 % Spikes - XL Side - Two large groups of spikes move in the opposite direction
            CaseOR == 4 % Spikes - XL Side - Each row move on the opposite direction to the previous one (0101010)
                Set *Var[4] 0 % This traps doesn't spawn chests
            EndCaseGroup
            CaseOR == 6 % Walls - 2 Sides
            CaseOR == 7 % Walls - 1 Side - The first and last wall crash with another moving wall
                Call    RandInt ( 100` *Var[5] )
                If  *Var[5] < 60` % 60% chance to spawn a chest
                    If *Var[5] < 30` % 30% chance to spawn 2 chests
                        % This chests can't spawn if the middle pillars are thinn
                        If *Var[3] == 1
                            If *Var[2] != 6 % Walls - 2 Sides
                                Set *Var[4] 10`
                            Else
                                Set *Var[4] 0
                            EndIf
                        Else
                            Set *Var[4] 0 % Don't spawn any chests
                        EndIf
                    Else
                        Call    RandInt ( 1 *Var[5] )
                        % Read Trap Var
                        If *Var[3] == 0 % Left
                            Set *Var[4] 8
                        Else % Right
                            Set *Var[4] 5
                        EndIf
                    EndIf
                EndIf
            EndCaseGroup
            Case == 8 % Walls - 2 Sides - You need to climb to a platform to enter the trap
                Call    RandInt ( 100` *Var[5] )
                If *Var[5] < 30` % 30% chance to spawn 2 chests
                    Set *Var[4] 10`
                EndIf
            Case == 9 % Walls - 2 Sides - 1 side has a chest at the end
                If *Var[3] == 0 % Left
                    Set *Var[4] 12`
                Else % Right
                    Set *Var[4] 13`
                EndIf
            Case == 10` % Walls - XL Side
                Set *Var[4] 0 % This trap will never spawn a chest
        EndSwitch
        Call    $WriteAddress ( *Var[0] 0 *Var[4] 2 .False ) % Chest Spawn Pos 1
        % unused, always save a 0 in the last byte
        Set     *Var[5] 0
        Call    $WriteAddress ( *Var[0] 0 *Var[5] 3 .False ) % Chest Spawn Pos 2
        /% Testing - Write the same trap on all rooms
        %Set     *Var[2] 6  % Trap ID
        %Set     *Var[3] 0  % Trap Var
        %Set     *Var[4] 8  % Chest Spawn Pos 1
        Call    $WriteAddress ( *Var[0] 0 *Var[2] 0 .False ) % Trap ID
        Call    $WriteAddress ( *Var[0] 0 *Var[3] 1 .False ) % Trap Var
        Call    $WriteAddress ( *Var[0] 0 *Var[4] 2 .False ) % Chest Spawn Pos 1
        Call    $WriteAddress ( *Var[0] 0 *Var[5] 3 .False ) % Chest Spawn Pos 2 % unused
        %/
    EndLoop
    Return
    End
}

/% $Maze_TrapX_Data - Byte Struct
00XXXXXX = TrapID
XX00XXXX = Trap Var % needed in a few traps
XXXX00XX = Chest 1 Spawn Point
XXXXXX00 = Chest 2 Spawn Point
%/

/% Get chest's spawn positions for all rooms with enemies
Chest's Data

Data structure
AABBCCDD
AA= Map 1 - Chest Pos 1
BB= Map 1 - Chest Pos 2

CC= Map 2 - Chest Pos 1
DD= Map 2 - Chest Pos 2
%/
#new:Script $Script_GetChestsData
{

Set  *Var[1] 3 % because 3 words are used for all battle maps (1 word covers 2 maps, so 3x2 = 6 battle maps)
Loop *Var[1]
    Switch  *Var[1]
        Case == 3
            Set     *Var[2] $Maze_ChestData_Map1_5
        Case == 2
            Set     *Var[2] $Maze_ChestData_Map9_13
        Case == 1
            Set     *Var[2] $Maze_ChestData_Map18_20
    EndSwitch
    Set *Var[5] .Default
    % Var5 == Offset
    Loop 2
        % Get Chest 1 Pos
        Call    RandInt ( 3 *Var[4] ) % Get Random Chest Pos
        Call    $WriteAddress ( *Var[2] 0 *Var[4] *Var[5] .False ) % ( Address ByteSize NewValue Offset FollowPointer )
        % Get Chest 2 Pos
        Loop
            Call    RandInt ( 3 *Var[0] ) % Get Random Chest Pos
            If  *Var[0] != *Var[4] % both chest positions are different
                Add     *Var[5] 1 % move offset
                Call    $WriteAddress ( *Var[2] 0 *Var[0] *Var[5] .False  )
                BreakLoop
            EndIf
        EndLoop
        Add *Var[5] 1 % move offset
    EndLoop
EndLoop
Return
End
}

#new:Script $Script_GetSpecialChestsData
{
% Get 8bits Symbols
% Write 1st byte
Set     *Var[1] 2 % write the other 2 bytes
Call    RandInt       ( 4 *Var[0] )
Call    $WriteAddress ( $Maze_ChestData_Special1 0 *Var[0] *Var[1] .False )
Loop *Var[1]
    Label   Start
    Call    RandInt       ( 4 *Var[0] )
    % Check if this symbol has been already used
    Call    $ReadAddress ( $Maze_ChestData_Special1 0 *Var[2] *Var[1] .False )
    If *Var[2] == *Var[0]
        Goto Start
    EndIf
    % Check if is the last byte to write
    % so check if the other byte is different too
    If *Var[1] == 1
        Call $ReadAddress ( $Maze_ChestData_Special1 0 *Var[2] 2 .False )
        If *Var[2] == *Var[0]
            Goto Start
        EndIf
    EndIf
    % Move offset
    Set     *Var[2] *Var[1]
    Sub     *Var[2] 1
    Call    $WriteAddress ( $Maze_ChestData_Special1 0 *Var[0] *Var[2] .False )
EndLoop
% Shuffle Sprite's cubes sprites
Call $ReadAddress ( $Maze_ChestData_Special1 0 *Var[0] 0 .False )
Call $ReadAddress ( $Maze_ChestData_Special1 0 *Var[1] 1 .False )
Call $ReadAddress ( $Maze_ChestData_Special1 0 *Var[2] 2 .False )
Set *Var[3] 3 % number of loops
Loop *Var[3]
    Switch *Var[3]
        Case == 1
            Set *Var[5] *Var[0]
        Case == 2
            Set *Var[5] *Var[1]
        Case == 3
            Set *Var[5] *Var[2]
    EndSwitch
    Loop
        Call RandInt ( 4 *Var[4] )
        If *Var[4] != *Var[5]
            BreakLoop
        EndIf
    EndLoop
    % Save value
    Switch *Var[3]
        Case == 1
            Call $WriteAddress ( $Maze_ChestData_Special1 0 *Var[4] 4 .False )
        Case == 2
            Call $WriteAddress ( $Maze_ChestData_Special1 0 *Var[4] 5 .False )
        Case == 3
            Call $WriteAddress ( $Maze_ChestData_Special1 0 *Var[4] 6 .False )
    EndSwitch
EndLoop
% Save Invicible Blocks Spawn Coords
/% 
mze_03 - misc notes
[1]-112 73 -205
[3]145 73 191
257 0 396

mze_04
[1]-187 73 -193
[2]225 73 122
412 0 315

mze_05
[1]-117 73 -244
[2]151 73 218
268 0 462
%/
% Save mze_03 (Map ID #5) coords
Call    RandInt ( 257` *Var[0] ) % get x
Set     *Var[2] -112`
Add     *Var[0] *Var[2]
Call    RandInt ( 396` *Var[1] ) % get z
Set     *Var[2] -205`
Add     *Var[1] *Var[2]
Call    $WriteAddress ( $Maze_ChestData_Special1_Blocks_Coords 2 *Var[0] 0 .False ) % write x
Call    $WriteAddress ( $Maze_ChestData_Special1_Blocks_Coords 2     63` 4 .False ) % write y
Call    $WriteAddress ( $Maze_ChestData_Special1_Blocks_Coords 2 *Var[1] 8 .False ) % write z
% Save mze_04 (Map ID #9) coords
Call    RandInt ( 412` *Var[0] ) % get x
Set     *Var[2] -187`
Add     *Var[0] *Var[2]
Call    RandInt ( 315` *Var[1] ) % get z
Set     *Var[2] -193`
Add     *Var[1] *Var[2]
Call    $WriteAddress ( $Maze_ChestData_Special1_Blocks_Coords 2 *Var[0] C .False ) % write x
Call    $WriteAddress ( $Maze_ChestData_Special1_Blocks_Coords 2     63` 10 .False ) % write y
Call    $WriteAddress ( $Maze_ChestData_Special1_Blocks_Coords 2 *Var[1] 14 .False ) % write z
% Save mze_05 (Map ID #13) coords
Call    RandInt ( 268` *Var[0] ) % get x
Set     *Var[2] -117`
Add     *Var[0] *Var[2]
Call    RandInt ( 462` *Var[1] ) % get z
Set     *Var[2] -244`
Add     *Var[1] *Var[2]
Call    $WriteAddress ( $Maze_ChestData_Special1_Blocks_Coords 2 *Var[0] 18 .False ) % write x
Call    $WriteAddress ( $Maze_ChestData_Special1_Blocks_Coords 2     63` 1C .False ) % write y
Call    $WriteAddress ( $Maze_ChestData_Special1_Blocks_Coords 2 *Var[1] 20 .False ) % write z
% Get Fuzzie's Chest Data / Special Chest 2
Call    RandInt ( 1 *AreaByte[0] ) % Chest's Corner
Call    RandInt ( 3 *Var[0] )
Switch *Var[0]
    Case == 0
        Set *Var[0] 3
    Case == 1
        Set *Var[0] 7
    Case == 2
        Set *Var[0] 11`
    Case == 3
        Set *Var[0] 15`
EndSwitch
%Set *Var[0] 3 % testing
Call    $WriteAddress ( $Maze_ChestData_Special2 0 *Var[0] .False .False ) % save chest's map ID
Call    RandInt ( 3 *Var[0] ) % Fuzzy's #1 Patch
Call    RandInt ( 3 *Var[1] ) % Fuzzy's #2 Patch
Call    RandInt ( 3 *Var[2] ) % Fuzzy's #3 Patch
Call    $WriteAddress ( $Maze_ChestData_Special2 0 *Var[0] 1 .False )
Call    $WriteAddress ( $Maze_ChestData_Special2 0 *Var[1] 2 .False )
Call    $WriteAddress ( $Maze_ChestData_Special2 0 *Var[2] 3 .False )
Return
End
}

% Save unlocked Partners byte flags in $Maze_PartnerData
#new:Script $Script_SavePartnersData
{
    % Goombario
    Call $ReadAddress ( 8010F2AC 0 *Var[0] .False .False )
    If *Var[0] == .True
        Call $WriteAddress ( $Maze_PartnerData 0 .True 0 .False )
    EndIf
    % Kooper
    Call $ReadAddress ( 8010F2B4 0 *Var[0] .False .False )
    If *Var[0] == .True
        Call $WriteAddress ( $Maze_PartnerData 0 .True 1 .False )
    EndIf
    % Bombette
    Call $ReadAddress ( 8010F2BC 0 *Var[0] .False .False )
    If *Var[0] == .True
        Call $WriteAddress ( $Maze_PartnerData 0 .True 2 .False )
    EndIf
    % Parakarry
    Call $ReadAddress ( 8010F2C4 0 *Var[0] .False .False )
    If *Var[0] == .True
        Call $WriteAddress ( $Maze_PartnerData 0 .True 3 .False )
    EndIf
    % Bow
    Call $ReadAddress ( 8010F2EC 0 *Var[0] .False .False )
    If *Var[0] == .True
        Call $WriteAddress ( $Maze_PartnerData 0 .True 4 .False )
    EndIf
    % Watt
    Call $ReadAddress ( 8010F2D4 0 *Var[0] .False .False )
    If *Var[0] == .True
        Call $WriteAddress ( $Maze_PartnerData 0 .True 5 .False )
    EndIf
    % Sushie
    Call $ReadAddress ( 8010F2DC 0 *Var[0] .False .False )
    If *Var[0] == .True
        Call $WriteAddress ( $Maze_PartnerData 0 .True 6 .False )
    EndIf
    % Lakilester
    Call $ReadAddress ( 8010F2E4 0 *Var[0] .False .False )
    If *Var[0] == .True
        Call $WriteAddress ( $Maze_PartnerData 0 .True 7 .False )
    EndIf
    Return
    End
}

#new:Function $Function_SetMazeTimer
{
    ORI     T0, R0, D0 % Full Timer
    SAB     T0, $DungeonTimer
    JR      RA
    ADDIU   V0, R0, 2
}

#new:Function $Function_GetTattle
{
LIO       V0, $MapTattle
JR        RA
RESERVED
}
	
#string $MapTattle
{
[STYLE:TATTLE][...]
[Func_2B]This is the maze's chest
room.
[WAIT][NEXT][...]
You can buy HP and FP upgrades
here.
[WAIT][NEXT][...]
Ahead you can buy Life Shrooms
or get your coins back
[WAIT][NEXT][...]
if you were so unfortunate as to lose
any coins inside the Pit.
[WAIT][NEXT][...]
Although the price will depend
on the number of coins lost.
[WAIT][END]
}
