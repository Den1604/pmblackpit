% This file is the responsable of making Roguelike mode funny af

% Why is placed in /globals?
% Was placed in map/import before but there was a lot of problems with the insane amount of code
% in the same map, so i moved all the roguelike code to globals, to stop the random crashes and the corruptions in
% some entities and strings.

% I know is a lot of waste in global's space, but it worked and it looks like there's still plenty global's space left
% so that's good enough for me :)

% Entities Flags
#define .Flag_SuperBlock1 *Flag_KZN_09
#define .Flag_SuperBlock2 *Flag_KZN_0A
#define .Flag_GiantChestSpawned *MapFlag[21]
%#define .Flag_PipeSpawning *MapFlag[22] % USED IN PitMain.mpat
#define .Flag_GiantChestParentToSpikes *MapFlag[23]
#define .Flag_GiantChestOpened *MapFlag[24]
#define .Flag_GiantChest *Flag_KZN_07 % looks like for the Giant chest to work the flag doesn't need to be a mapflag
#define .Flag_SpawnedItem *Flag_KZN_08 % looks like is the same for makeitementity, used when an item is spawned, always use this flag

#define .Down   0
#define .Up     1
#define .Right  2
#define .Left   3

/% MapVars used on Normal Floors
MapVar0 - occupied
MapVar1 - occupied
MapVar2 - .Rogue_SpawnAmount
MapVar3 - .Reward_Yaw % unused
MapVar4 - .Rogue_ID
MapVar5 - .Rogue_ID_Flags
MapVar6 - .Rogue_SpawnPoint
MapVar7 - .Rogue_SpawnSide
MapVar8 - occupied
MapVar9 - occupied
MapVarA - .Rogue_Size
MapVarB - .Rogue_SpawnCount % unused
MapVarC - .Rogue_LoadedID
MapVarD - .Rogue_Item_1
MapVarE - .Rogue_Item_2
MapVarF - Rogue Misc
%/

%=======================================================
% lOADED FROM /globals/patch/RogueData.patch
/%#new:Data $Entity_Var1
00000000
% XXYYZZZZ
% XX=Entity ID / YY=SpawnPoint / ZZZZ=Var Value

#new:Data $Entity_Var2
00000000

#new:Data $Entity_Var3
00000000

#new:Data $Entity_Var4
00000000

#new:Data $Data_Reward_DataExtra % Used for Battle Based Springs
00000000

#new:Data $Data_Reward_Data
00000000
%% XXYYZZZZ
% XX=Reward Spawn Point
% YY=Trap ID
% ZZZZ=Rarity Points

#new:Data $Data_Reward_TrapID
00000000%/
%=======================================================

% Amount of items(useful stuff) to spawn on the current floor
#define .Rogue_SpawnAmount 	*MapVar[2]
% To know from what side mario need to come to get to the reward
#define .Reward_Yaw         *MapVar[3]
% ID of the trap to load
#define .Rogue_ID 			*MapVar[4]
% To know the kind of trap loaded
#define .Rogue_ID_Flags  	*MapVar[5]
% Spawn point 
#define .Rogue_SpawnPoint 	*MapVar[6]
% To know the stair used
#define .Rogue_SpawnSide 	*MapVar[7]
% Size of the structure
#define .Rogue_Size 		*MapVar[A]
% Used to know the amount of things already spawned, used only when spawning two traps
#define .Rogue_SpawnCount  	*MapVar[B]
% Save the trap ID of the first trap
#define .Rogue_LoadedID  	*MapVar[C]
% Used to know where to spawn a reward in that floor
#define .Rogue_Item_1 *MapVar[D]
#define .Rogue_Item_2 *MapVar[E]

% for .Rogue_SpawnAmount
#define .1Thing1Trap 1
#define .1Thing2Traps 2
#define .2Things2Traps 3
#define .4Things 4

#new:Script:Map $Script_Roguelike_GetSpawnAmount
{
% Disable Green Pipe from the top right corner
Call     EnableModel 			( 20 .False )
Call     ModifyColliderFlags 	( .False A 7FFFFE00 )
Call     ModifyColliderFlags 	( .False B 7FFFFE00 )
%
Call    $Function_NukeRogueData % set all data used on Rogue back to Zero
Set     .Rogue_LoadedID FF % null
Set     .Rogue_Item_1 .False
Set     .Rogue_Item_2 .False
Set     .Flag_SuperBlock1 .False
Set     .Flag_SuperBlock2 .False
Set     .Flag_GiantChestSpawned .False
Set     .Flag_GiantChest .False
Set     .Flag_SpawnedItem .False
If *4Chests_Cooldown == .False
    Call	RandInt ( 100` *Var[0] )
Else
    Call	RandInt ( 96` *Var[0] )
EndIf
/% Read the current floor, to alter the percentages
Switch *PitMapID % unfinished
EndSwitch%/
Switch *Var[0]
    Case < 31` % 31% spawn 1 thing with one trap
        Set .Rogue_SpawnAmount .1Thing1Trap
    Case < 64` % 33% spawn 1 thing with 2 different kind of traps
        Set .Rogue_SpawnAmount .1Thing2Traps
    Case < 97` % 33% spawn 2 things with 2 different kind of traps
        Set .Rogue_SpawnAmount .2Things2Traps
    Case <= 100` % 3% spawn 4 things without any trap in between
        % 2nd check
        Call	RandInt ( 100` *Var[0] )
        If *Var[0] < 30`
            Set .Rogue_SpawnAmount .4Things
            Set .Rogue_ID 19`
            Set .Rogue_ID_Flags .4Chests % Exclusive for this Trap
            Jump $Script_Roguelike_LoadTraps
        Else
            Set .Rogue_SpawnAmount .2Things2Traps
        EndIf
EndSwitch
% The 1st 10 floors always spawn a single thing
If *PitMapID < 10`
    Set .Rogue_SpawnAmount .1Thing1Trap
EndIf
/% testing stuff
If .Rogue_SpawnAmount == .1Thing1Trap
    Jump $Script_Roguelike_GetSpawnAmount
EndIf%/
%Set .Rogue_SpawnAmount .1Thing1Trap % testing stuff
Jump    $Script_Roguelike_GetFloor
Return
End
}

#export $Script_Roguelike_GetSpawnAmount

/% SpawnAmount  - How each value load everything
2Things2Traps:
Load 1st Trap:    Get Trap ID > Load Floor and (save reward spawn point on Item2) > Load Trap > Save RogueID in LoadedID > Set SpawnAmount as 1Thing1Trap and Jump to the beggining >
Load 2nd Trap:      Get TrapID, Load Floor and TrapID (save reward spawn point on Item1) >
Load Reward 1:         Save LoadedID and Reward Spawn Pos(Item 2) in $Data_Reward_Data2 > Save $Data_Reward_Data2 in DataX > Get Rarity Value and Save in MapVarF > Use that value to spawn the Reward > Save Reward Rarity var in $RewardVar > Check if the trap have a padlock to adjust the value from the lock (if yes, save new amount in $LockVar and save it in the next $Data_Reward_Data available)
Load Reward 2:              Save RogueID and Reward Spawn Pos(Item 1) in $Data_Reward_Data1 > do everything again but using the data from $Data_Reward_Data1 this time
                                End
%/

#define .Blocks 1
#define .Spring 2
#define .OnlySize0 3
#define .Pillars 4
#define .OnlySize2 5
#define .OnlyHorizontal 6
#define .4Chests 7
#define .NotSize0 8
#define .OnlySize1 9

% Rogue ID Type - Trap Flags basically
/% Properties
0= Normal
1= Can't spawn L/R stairs when using vertical floors and can't use a 0 size
2= Springs
3= Always use structures of a size of 0 (just corner and stairs)
4= Pillars
5= Always use structures of a size of 2 (load two floors)
6= Always use horizontals floors
7= Used when spawning the 4 chests/springs
8= Can't use structures with a size of 0
9= Always use structures with a size of 1
%/

% Load the Rogue Geometry for the current floor
#new:Script:Map $Script_Roguelike_GetFloor
{
% Load the kind of obstacles to surpass
Label GetTrap
% Load Keypad traps? or all traps?
Call	RandInt ( 100` *Var[0] )
If *Var[0] < 30` % 30% to spawn keypad traps
    Call	RandInt ( 100` *Var[0] )
    % Format Var0
    Switch *Var[0]
        Case > 60` % Springs - Keys Based % 40%
            Set *Var[0] 17`
        Case > 40` % Springs - Battle Based % 20%
            Set *Var[0] 18`
        Case > 10` % Springs - Coins Based % 30%
            Set *Var[0] 20`
        Case > 0 % Springs - HP Based % 10%
            Set *Var[0] 21`
    EndSwitch
Else % Load all traps
    Call	RandInt ( 21` *Var[0] )
EndIf
Switch	*Var[0]
	Case == 0 % Block - Super Hammer
        Set .Rogue_ID 0
        Set .Rogue_ID_Flags .Blocks % can't spawn L/R stairs when using vertical floors
    Case == 1 % Block - Ultra Hammer
        Call $Function_GetHammer % save in var3
        % If the player have the normal hammer don't spawn
        If  *Var[3] != 0
            Set .Rogue_ID 1
            Set .Rogue_ID_Flags .Blocks
        Else
            Jump $Script_Roguelike_GetFloor
        EndIf
    Case == 2 % Spring - Super Boots
        Set .Rogue_ID 2
        Set .Rogue_ID_Flags .Spring
    Case == 3 % ? Switch - Ultra Boots
        Call $Function_GetBoots % save in var3
        % If the player have the normal boots don't spawn
        If  *Var[3] != 0
            Set .Rogue_ID 3
            Set .Rogue_ID_Flags .OnlySize0 % Always use structures of a size of 0 (just corner and stairs)
        Else
            Jump $Script_Roguelike_GetFloor
        EndIf
	Case == 4 % Switch - Kooper 1 % Middle Pillar
        Set .Rogue_ID 4
        Set .Rogue_ID_Flags .Pillars % When loading pillars
	Case == 5 % Switch - Kooper 2 % L/R Pillar
        Set .Rogue_ID 5
        Set .Rogue_ID_Flags .Pillars
	Case == 6 % Grab Item - Kooper Only
        Set .Rogue_ID 6
        Set .Rogue_ID_Flags .Pillars
	Case == 7 % Grab Item - Kooper and Parakarry
        Set .Rogue_ID 7
        Set .Rogue_ID_Flags .Pillars
	Case == 8 % Rocks - Bombette
        Set .Rogue_ID 8
        Set .Rogue_ID_Flags .NotSize0 % Can't use structures with a size of 0
	Case == 9 % Switches - Bombette % unused
		Set .Rogue_ID 9
	Case == 10` % Gaps - Parakarry
        Set .Rogue_ID 10`
        Set .Rogue_ID_Flags .Pillars
	Case == 11` % Spikes - Bow and Lakilester
        Set .Rogue_ID 11`
        Set .Rogue_ID_Flags .OnlySize2 % Always load more than 1 floor
	Case == 12` % Water Gaps - Sushie
        Set .Rogue_ID 12`
        Set .Rogue_ID_Flags .OnlyHorizontal % Always load horizontals floors
	Case == 13` % Spikes - Lakilester Only
        Set .Rogue_ID 13`
        Set .Rogue_ID_Flags .OnlySize1
	Case == 14` % Spring - Goombario Only
        Set .Rogue_ID 14`
        Set .Rogue_ID_Flags .Spring
    Case == 15` % Spring - Bow Based % unused
        Set .Rogue_ID 15`
	Case == 16` % Spring - Watt Only
        Set .Rogue_ID 16`
        Set .Rogue_ID_Flags .Spring
	Case == 17` % Springs - Keys Based
        Set .Rogue_ID 17`
        Set .Rogue_ID_Flags .Spring
	Case == 18` % Springs - Battle Based
        Set .Rogue_ID 18`
        Set .Rogue_ID_Flags .Spring
	Case == 19` % 4 Chests % very rare
        Jump $Script_Roguelike_GetFloor % ID 19 is set in $Script_Roguelike_GetSpawnAmount
    Case == 20` % Springs - Coins Based
        Set .Rogue_ID 20`
        Set .Rogue_ID_Flags .Spring
    Case == 21` % Springs - HP Based
        Set .Rogue_ID 21`
        Set .Rogue_ID_Flags .Spring
EndSwitch
% The first 10 floors only spawn springs
If *PitMapID < 10` % isn't testing
    Switch .Rogue_ID
        CaseOR == 17` % Springs - Keys Based
        CaseOR == 18` % Springs - Battle Based
        CaseOR == 20` % Springs - Coins Based
        CaseOR == 21` % Springs - HP Based
            Wait 1
            Goto Okay
        EndCaseGroup
        Default
            Jump $Script_Roguelike_GetFloor
    EndSwitch
EndIf%/
Label Okay
Wait  1
% Check if the current ID can be used, needed mostly just when spawning more than one trap
Switch .Rogue_ID
    CaseOR == 0 % Block - Super Hammer
    CaseOR == 1 % Block - Ultra Hammer
    CaseOR == 8 % Rocks - Bombette
        % If the previously loaded size was 2, load another trap
        If .Rogue_SpawnAmount != .1Thing2Traps
            If .Rogue_Size == 2
            % This doesn't apply when loading the same kind of trap
                Jump $Script_Roguelike_GetFloor
            EndIf
        EndIf
    EndCaseGroup
    % Traps that can't be used with 1Thing2Traps
    Case == 3 % ? Switch - Ultra Boots
        If .Rogue_SpawnAmount == .1Thing2Traps
            Jump $Script_Roguelike_GetFloor
        EndIf
        % This trap can't be loaded twice on the same floor
        If .Rogue_LoadedID == 3
            Jump $Script_Roguelike_GetFloor
        EndIf
    CaseOR == 4 % Switch - Kooper 1
        % If is the 2nd time loading this ID on the same floor
        % check some conditions
        If .Rogue_LoadedID == 4
            Switch .Rogue_SpawnPoint
                CaseOR == 1
                CaseOR == 2
                    If .Rogue_SpawnPoint <= 2
                        Jump $Script_Roguelike_GetFloor
                    EndIf
                EndCaseGroup
                CaseOR == 3
                CaseOR == 4
                    If .Rogue_SpawnPoint >= 3
                        Jump $Script_Roguelike_GetFloor
                    EndIf
                EndCaseGroup
            EndSwitch
        EndIf
    CaseOR == 6 % Grab Item - Kooper Only
    CaseOR == 7 % Grab Item - Kooper and Parakarry
        If .Rogue_SpawnAmount == .1Thing2Traps
            Jump $Script_Roguelike_GetFloor
        EndIf
    EndCaseGroup
    Case == 5 % Switch - Kooper 2
        % 1Thing2Traps Check
        If .Rogue_SpawnAmount == .1Thing2Traps
            Jump $Script_Roguelike_GetFloor
        EndIf
        % Loading 2 Different Traps Check
        If .Rogue_LoadedID == 5
            % You can't load this trap twice on the same floor
            Jump $Script_Roguelike_GetFloor
        EndIf
    CaseOR == 9 % Switches - Bombette % unused
    CaseOR == 15` % Spring - Bow Based % unused
        % Scrapped traps
        Jump $Script_Roguelike_GetFloor
    EndCaseGroup
    Case == 10` % Gaps - Parakarry
        If .Rogue_SpawnAmount == .1Thing2Traps
            If .Rogue_Flag_Geometry_Floors_Horizontal == .True
                Jump $Script_Roguelike_GetFloor
            EndIf
        EndIf
    Case == 11` % Spikes - Bow and Lakilester
        If .Rogue_SpawnAmount != .1Thing2Traps
            If .Rogue_Size != 0
                % If the previously loaded size wasn't 0, load another trap
                Jump $Script_Roguelike_GetFloor
            EndIf
        Else
            % This trap can't be the 2nd one when using .1Thing2Traps
            % can be possible but i will need to redone a lot of code
            % and is in very special cases... so rip -__-
            If .Rogue_LoadedID != FF
                Jump $Script_Roguelike_GetFloor
            Else
                % Can't be loaded twice on the same floor
                If .Rogue_LoadedID != 11`
                    Jump $Script_Roguelike_GetFloor
                EndIf
            EndIf
        EndIf
    Case == 12` % Water Gaps - Sushie
        % If any vertical floor has been already loaded (L/R Floors) reload another trap
        If .Rogue_SpawnAmount != .1Thing2Traps
            If  .Rogue_Flag_Geometry_Floors_Horizontal != .False
                Jump $Script_Roguelike_GetFloor
            EndIf
        Else
            % This trap can't be used as the 2nd one in .1Thing2Traps
            If .Rogue_LoadedID != FF
                Jump $Script_Roguelike_GetFloor
            EndIf
        EndIf
    Case == 13` % Spikes - Lakilester Only
        % If the previously loaded size was 2, load another trap
        If .Rogue_SpawnAmount != .1Thing2Traps
            If .Rogue_Size == 2
            % This doesn't apply when loading the same kind of trap
                Jump $Script_Roguelike_GetFloor
            EndIf
        Else
            % Can't be loaded twice on the same floor
            If .Rogue_LoadedID != 13`
                Jump $Script_Roguelike_GetFloor
            EndIf
        EndIf
    Case == 19` % 4 Chests % very rare
        If  .Rogue_SpawnAmount != .1Thing1Trap
            % Just load this trap when a single trap is about to be loaded
            Jump $Script_Roguelike_GetFloor
        EndIf
EndSwitch
% Last Check, use for very specific conditions
% .1Thing2Traps Checks
If .Rogue_SpawnAmount == .1Thing2Traps
    If .Rogue_ID_Flags != .Spring
        % The only compatible trap for ID 12
        % when using .1Thing2Traps are Spring kind of traps
        If .Rogue_LoadedID == 12`
            Jump $Script_Roguelike_GetFloor
        EndIf
    EndIf
    % Check all other flags
    Switch .Rogue_ID_Flags
        Case == .Spring
        % Check if the 1st trap about to being loaded when using having 1Thing2Traps is a spring
            If .Rogue_LoadedID == FF
                Jump $Script_Roguelike_GetFloor
            EndIf
        Case == .Blocks
        % Used to avoid spawning an unbreakable block (when trying to destroy a block from the back)
        % Check all possible outcomes one by one
            If .Rogue_LoadedID != FF
                Switch	.Rogue_SpawnPoint
                    Case == 1 % Upper Left
                        If .Rogue_SpawnSide == 1 % <
                            % Check if Size 2 was used
                            If .Rogue_Flag_Geometry_Floors_Down == .True
                                Jump $Script_Roguelike_GetFloor
                            EndIf
                        EndIf
                    Case == 2 % Upper Right
                        % Check if Size 2 was used
                        If .Rogue_SpawnSide == 1 % <
                            % Check if Size 2 was used
                            If .Rogue_Flag_Geometry_Floors_Down == .True
                                Jump $Script_Roguelike_GetFloor
                            EndIf
                        EndIf
                    Case == 3 % Bottom Right
                        If .Rogue_SpawnSide == 0 % v
                            % Check if Size 2 wasn't used
                            If .Rogue_Flag_Geometry_Floors_Left == .False
                                Jump $Script_Roguelike_GetFloor
                            EndIf
                        EndIf
                    Case == 4 % Bottom Left
                        If .Rogue_SpawnSide == 0 % v
                            % Check if Size 2 wasn't used
                            If .Rogue_Flag_Geometry_Floors_Right == .False
                                Jump $Script_Roguelike_GetFloor
                            EndIf
                        EndIf
                EndSwitch
            EndIf
    EndSwitch
    % Super Spring and Super/Ultra Blocks
    % Don't spawn a super spring/block to help to surpass another super spring/block if the player doesn't have at least a super hammer/bots
    If .Rogue_LoadedID != FF % Is the 2nd trap to load
        Switch .Rogue_LoadedID
            CaseOR == 0 % Block - Super Hammer
            CaseOR == 1 % Block - Ultra Hammer
                If .Rogue_ID == 2 % Spring - Super Boots
                    Call    $ReadAddress ( 8010F290 0 *Var[0] .False .False ) % load boots
                    If *Var[0] == .False
                        % Don't make posible to surpass a block trap with a super spring if the player don't have the super/ultra boots
                        Jump $Script_Roguelike_GetFloor
                    EndIf
                EndIf
            EndCaseGroup
            Case == 2 % Spring - Super Boots
                If .Rogue_ID == 0 % Block - Super Hammer
                    Call    $ReadAddress ( 8010F291 0 *Var[0] .False .False ) % load hammer
                    If *Var[0] <= 1
                        % Don't make posible to surpass a super spring trap with a super block if the player don't have the super/ultra hammer
                        Jump $Script_Roguelike_GetFloor
                    EndIf
                EndIf
        EndSwitch
    EndIf
EndIf
% testing
/% Only this traps can be loaded
Switch .Rogue_ID
    CaseOR == 2
    CaseOR == 6
    CaseOR == 7
    CaseOR == 8
    CaseOR == 10`
    CaseOR == 12`
    CaseOR == 14`
    CaseOR == 16`
    CaseOR == 17`
    CaseOR == 18`
    CaseOR == 19`
    CaseOR == 20`
    CaseOR == 21`
        Jump $Script_Roguelike_GetFloor
EndSwitch%/
/% testing - For multiple traps
If .Rogue_LoadedID != FF
    Set .Rogue_ID 20` % Springs - Coins Based
    Set .Rogue_ID_Flags .Spring
Else % 1st Trap
    Set .Rogue_ID 0 % Block - Super Hammer
    Set .Rogue_ID_Flags .Blocks % can't spawn L/R stairs when using vertical floors
EndIf%/
%/
% testing
/% Always load a kind of traps in specific
If .Rogue_ID_Flags != .Pillars
    Jump $Script_Roguelike_GetFloor
EndIf%/
/% testing
% Always load a trap in specific
Set .Rogue_ID 13` % Spikes - Lakilester Only
Set .Rogue_ID_Flags .OnlySize1 %/
% Check if is the 2nd trap to load when having an Spawn Amount of .1Thing2Traps
If .Rogue_SpawnAmount == .1Thing2Traps
    If .Rogue_LoadedID != FF
        Set .Rogue_SpawnAmount .1Thing1Trap % to not load another trap
        Jump $Script_Roguelike_LoadFloor_1Thing2Traps
    EndIf
EndIf
% Load Spawn Point
Label   SpawnPoint
Call	RandInt ( 3 *Var[0] )
% Check if current spawn point plus spawnside can be used
Switch	*Var[0]
    Case == 0 % Upper Left
        If .Rogue_Flag_Geometry_Corners_1 == .False
            Set .Rogue_SpawnPoint 1
        Else
            Jump $Script_Roguelike_GetFloor
        EndIf
	Case == 1 % Upper Right
		If .Rogue_Flag_Geometry_Corners_2 == .False
            Set .Rogue_SpawnPoint 2
        Else
            Jump $Script_Roguelike_GetFloor
        EndIf
	Case == 2 % Bottom Right
		If .Rogue_Flag_Geometry_Corners_3 == .False
            Set .Rogue_SpawnPoint 3
        Else
            Jump $Script_Roguelike_GetFloor
        EndIf
	Case == 3 % Bottom Left
		If .Rogue_Flag_Geometry_Corners_4 == .False
            Set .Rogue_SpawnPoint 4
        Else
            Jump $Script_Roguelike_GetFloor
        EndIf
EndSwitch
%Set .Rogue_SpawnPoint 4 % testing stuff
% Which stair to use?
Label   SpawnSide
Call	RandInt ( 1 .Rogue_SpawnSide ) % 0 == Down/Up / 1 = Right/Left
%Set .Rogue_SpawnSide 1 % testing stuff
% Check if the loaded stair can be used
Switch .Rogue_ID_Flags
    CaseOR == .Spring % Size 0 only traps, don't need to check this.
    CaseOR == .OnlySize0
        BreakCase
    EndCaseGroup
    Default
        Switch .Rogue_SpawnPoint
            Case == 1 % Top L
                Switch .Rogue_SpawnSide
                    Case == 0 % v
                        If .Rogue_Flag_Geometry_Corners_2 == .True
                            Jump $Script_Roguelike_GetFloor
                        EndIf
                    Case == 1 % >
                        If .Rogue_Flag_Geometry_Corners_4 == .True
                            Jump $Script_Roguelike_GetFloor
                        EndIf
                EndSwitch
            Case == 2 % Top R
                Switch .Rogue_SpawnSide
                    Case == 0 % v
                        If .Rogue_Flag_Geometry_Corners_1 == .True
                            Jump $Script_Roguelike_GetFloor
                        EndIf
                    Case == 1 % >
                        If .Rogue_Flag_Geometry_Corners_3 == .True
                            Jump $Script_Roguelike_GetFloor
                        EndIf
                EndSwitch
            Case == 3 % Bottom R
                Switch .Rogue_SpawnSide
                    Case == 0 % v
                        If .Rogue_Flag_Geometry_Corners_4 == .True
                            Jump $Script_Roguelike_GetFloor
                        EndIf
                    Case == 1 % >
                        If .Rogue_Flag_Geometry_Corners_2 == .True
                            Jump $Script_Roguelike_GetFloor
                        EndIf
                EndSwitch
            Case == 4 % Bottom L
                Switch .Rogue_SpawnSide
                    Case == 0 % v
                        If .Rogue_Flag_Geometry_Corners_3 == .True
                            Jump $Script_Roguelike_GetFloor
                        EndIf
                    Case == 1 % >
                        If .Rogue_Flag_Geometry_Corners_1 == .True
                            Jump $Script_Roguelike_GetFloor
                        EndIf
                EndSwitch
        EndSwitch
EndSwitch
%% Horizontal Only Traps Extra Checks %%
If .Rogue_ID_Flags == .OnlyHorizontal
    Switch .Rogue_SpawnPoint
        Case == 1 % Top L
            If .Rogue_Flag_Geometry_Corners_2 == .True
                Jump $Script_Roguelike_GetFloor
            EndIf
        Case == 2 % Top R
            If .Rogue_Flag_Geometry_Corners_1 == .True
                Jump $Script_Roguelike_GetFloor
            EndIf
        Case == 3 % Bottom R
            If .Rogue_Flag_Geometry_Corners_4 == .True
                Jump $Script_Roguelike_GetFloor
            EndIf
        Case == 4 % Bottom L
            If .Rogue_Flag_Geometry_Corners_3 == .True
                Jump $Script_Roguelike_GetFloor
            EndIf
    EndSwitch
EndIf
% Check special stair conditions
Switch .Rogue_ID_Flags
    Case == .Blocks
        % Don't load L/R stairs when loading vertical floors
        % check spawn point
        Switch .Rogue_SpawnPoint
            CaseOR == 1 % Upper Left
            CaseOR == 2 % Upper Right
              % Used to avoid Mario trying to destroy a block from the back (is impossible)
              Set .Rogue_SpawnSide 0
              % Check if can be used
                Switch .Rogue_SpawnPoint
                    Case == 1 % Upper Left
                        If .Rogue_Flag_Geometry_Corners_2 == .True
                            Jump $Script_Roguelike_GetFloor % Get another trap if can't be loaded
                        EndIf
                    Case == 2 % Upper Right
                        If .Rogue_Flag_Geometry_Corners_1 == .True
                            Jump $Script_Roguelike_GetFloor % Get another trap if can't be loaded
                        EndIf
                EndSwitch
            EndCaseGroup
        EndSwitch
    CaseOR == .OnlyHorizontal
    CaseOR == .Pillars
        If .Rogue_SpawnSide == 1
            Jump $Script_Roguelike_GetFloor % Pillars trap can't have a spawn side of 1
        EndIf
    EndCaseGroup
EndSwitch
% Load longevity of the geometry
% Check special size conditions
Label GetSize
Switch  .Rogue_ID_Flags
    % For Traps that only appear with a 0 size
    CaseOR == .Spring
    CaseOR == .OnlySize0
        Set *Var[0] 0
    EndCaseGroup
    % For Traps that can't appear with a 0 size
    CaseOR == .Blocks
    CaseOR == .NotSize0
        Loop
            Call	RandInt ( 2 *Var[0] )
            If *Var[0] != 0
                BreakLoop
            EndIf
        EndLoop
        BreakCase
    EndCaseGroup
    % For Traps that only appear with a 2 size
    Case == .OnlySize2
        Set *Var[0] 2
    % always use Size 1
    CaseOR == .OnlyHorizontal
    CaseOR == .OnlySize1
    CaseOR == .Pillars
        Set *Var[0] 1
    EndCaseGroup
    Default
        Call	RandInt ( 2 *Var[0] )
EndSwitch
Switch *Var[0]
	Case == 0
		Set .Rogue_Size 0
    Case == 1
        % If there no more space left for a trap of this size
        If .Rogue_SpawnAmount != .1Thing2Traps
            If .Rogue_Size == 2
                Jump $Script_Roguelike_GetFloor
            EndIf
        EndIf
		Set .Rogue_Size 1
    Case == 2
        % If there no more space left for a trap of this size
        % check previously loaded size
        If .Rogue_SpawnAmount != .1Thing2Traps
            If .Rogue_Size != 0
                Jump $Script_Roguelike_GetFloor
            EndIf
        EndIf
        % check if the 2nd floor can be loaded
        Switch .Rogue_SpawnPoint
            Case == 1 % Upper L
                If .Rogue_Flag_Geometry_Corners_3 == .True
                    Jump $Script_Roguelike_GetFloor
                EndIf
            Case == 2 % Upper R
                If .Rogue_Flag_Geometry_Corners_4 == .True
                    Jump $Script_Roguelike_GetFloor
                EndIf
            Case == 3 % Bottom R
                If .Rogue_Flag_Geometry_Corners_1 == .True
                    Jump $Script_Roguelike_GetFloor
                EndIf
            Case == 4 % Bottom L
                If .Rogue_Flag_Geometry_Corners_2 == .True
                    Jump $Script_Roguelike_GetFloor
                EndIf
        EndSwitch
		Set .Rogue_Size 2
EndSwitch
%Set .Rogue_Size 1 % testing stuff
Jump $Script_Roguelike_LoadFloor
Return
End
}

 % Read the values from GetFloor to load the geometry of the floor
#new:Script:Map $Script_Roguelike_LoadFloor
{
% Load geometry %
% Load 1st set of stairs and corners
Label   Start
% Check special geometry conditions
Switch .Rogue_ID_Flags
    Case == .Spring
        ExecWait    $Script_Rogue_LoadFloors_Springs % Load Springs Geometry
        Wait 1
        Goto LoadTrap
    Case == .Pillars
        ExecWait    $Script_Rogue_LoadFloors_Pillars % Load Pillars Geometry
        Wait 1
        Goto LoadTrap
    Case == .4Chests
        Jump    $Script_Roguelike_LoadTraps
EndSwitch
Switch .Rogue_SpawnPoint
	Case == 1 % Upper Left
		% Spawn corner
		ExecWait $Script_Rogue_LoadCorner1
		% Spawn Stair
		If .Rogue_SpawnSide == 0 % V
			ExecWait $Script_Rogue_Load_Stairs1_1-1
		Else % >
			ExecWait $Script_Rogue_Load_Stairs1_1-2
		EndIf
	Case == 2 % Upper Right
		% Spawn corner
		ExecWait $Script_Rogue_LoadCorner2
		% Spawn Stair
		If .Rogue_SpawnSide == 0 % V
			ExecWait $Script_Rogue_Load_Stairs1_2-1
		Else % >
			ExecWait $Script_Rogue_Load_Stairs1_2-2
		EndIf
	Case == 3 % Bottom Right
		% Spawn corner
		ExecWait $Script_Rogue_LoadCorner3
		% Spawn Stair
		If .Rogue_SpawnSide == 0 % V
			ExecWait $Script_Rogue_Load_Stairs1_3-1
		Else % >
			ExecWait $Script_Rogue_Load_Stairs1_3-2
		EndIf
	Case == 4 % Bottom Left
		% Spawn corner
		ExecWait $Script_Rogue_LoadCorner4
		% Spawn Stair
		If .Rogue_SpawnSide == 0 % V
			ExecWait $Script_Rogue_Load_Stairs1_4-1
		Else % >
			ExecWait $Script_Rogue_Load_Stairs1_4-2
		EndIf
EndSwitch
% Load Floor Size
% Check if Size is 0
If .Rogue_Size == 0
    Wait 1
    Goto LoadTrap
EndIf
Switch .Rogue_SpawnPoint
	Case == 1 % Upper L
        If .Rogue_SpawnSide == 0 % Up/Down stairs
            Exec $Script_SetSignPos
            ExecWait $Script_Rogue_LoadFloor_Up
            ExecWait $Script_Rogue_LoadCorner2
            % Set Reward Spawn point
            If .Rogue_SpawnAmount == .2Things2Traps
                Set .Rogue_Item_2 2
                Call $Function_WriteRewardYaw ( 1 .Left )
            Else
            % If an item has already spawned use the other one
                Set .Rogue_Item_1 2
                Call $Function_WriteRewardYaw ( 0 .Left )
            EndIf
            % SIZE 2 %
            If .Rogue_Size == 2
                % Load 2nd Floor
                ExecWait $Script_Rogue_LoadFloor_Right
                ExecWait $Script_Rogue_LoadCorner3
                % Set Reward Spawn point
                If .Rogue_SpawnAmount == .2Things2Traps
                    Set .Rogue_Item_2 3
                    Call $Function_WriteRewardYaw ( 1 .Up )
                Else
                    Set .Rogue_Item_1 3
                    Call $Function_WriteRewardYaw ( 0 .Up )
                EndIf
            EndIf
        Else % L/R stairs
            ExecWait $Script_Rogue_LoadFloor_Left
            ExecWait $Script_Rogue_LoadCorner4
            % Set Reward Spawn point
            If .Rogue_SpawnAmount == .2Things2Traps
                Set .Rogue_Item_2 4
                Call $Function_WriteRewardYaw ( 1 .Up )
            Else
                Set .Rogue_Item_1 4
                Call $Function_WriteRewardYaw ( 0 .Up )
            EndIf
            % SIZE 2 %
            If .Rogue_Size == 2
                % Load 2nd Floor
                ExecWait $Script_Rogue_LoadFloor_Down
                ExecWait $Script_Rogue_LoadCorner3
                % Set Reward Spawn point
                If .Rogue_SpawnAmount == .2Things2Traps
                    Set .Rogue_Item_2 3
                    Call $Function_WriteRewardYaw ( 1 .Left )
                Else
                    Set .Rogue_Item_1 3
                    Call $Function_WriteRewardYaw ( 0 .Left )
                EndIf
            EndIf
		EndIf
	Case == 2 % Upper R
        If .Rogue_SpawnSide == 0 % Up/Down stairs
            Exec $Script_SetSignPos
            ExecWait $Script_Rogue_LoadFloor_Up
            ExecWait $Script_Rogue_LoadCorner1
            % Set Reward Spawn point
            If .Rogue_SpawnAmount == .2Things2Traps
                Set .Rogue_Item_2 1
                Call $Function_WriteRewardYaw ( 1 .Right )
            Else
                Set .Rogue_Item_1 1
                Call $Function_WriteRewardYaw ( 0 .Right )
            EndIf
            % SIZE 2 %
            If .Rogue_Size == 2
                % Load 2nd Floor
                ExecWait $Script_Rogue_LoadFloor_Left
                ExecWait $Script_Rogue_LoadCorner4
                % Set Reward Spawn point
                If .Rogue_SpawnAmount == .2Things2Traps
                    Set .Rogue_Item_2 4
                    Call $Function_WriteRewardYaw ( 1 .Up )
                Else
                    Set .Rogue_Item_1 4
                    Call $Function_WriteRewardYaw ( 0 .Up )
                EndIf
            EndIf
        Else % L/R stairs
            ExecWait $Script_Rogue_LoadFloor_Right
            ExecWait $Script_Rogue_LoadCorner3
            % Set Reward Spawn point
            If .Rogue_SpawnAmount == .2Things2Traps
                Set .Rogue_Item_2 3
                Call $Function_WriteRewardYaw ( 1 .Up )
            Else
                Set .Rogue_Item_1 3
                Call $Function_WriteRewardYaw ( 0 .Up )
            EndIf
            % SIZE 2 %
            If .Rogue_Size == 2
                % Load 2nd Floor
                ExecWait $Script_Rogue_LoadFloor_Down
                ExecWait $Script_Rogue_LoadCorner4
                % Set Reward Spawn point
                If .Rogue_SpawnAmount == .2Things2Traps
                    Set .Rogue_Item_2 4
                    Call $Function_WriteRewardYaw ( 1 .Right )
                Else
                    Set .Rogue_Item_1 4
                    Call $Function_WriteRewardYaw ( 0 .Right )
                EndIf
            EndIf
		EndIf
	Case == 3 % Bottom R
        If .Rogue_SpawnSide == 0 % Up/Down stairs
            ExecWait $Script_Rogue_LoadFloor_Down
            ExecWait $Script_Rogue_LoadCorner4
            % Set Reward Spawn point
            If .Rogue_SpawnAmount == .2Things2Traps
                Set .Rogue_Item_2 4
                Call $Function_WriteRewardYaw ( 1 .Right )
            Else
                Set .Rogue_Item_1 4
                Call $Function_WriteRewardYaw ( 0 .Right )
            EndIf
            % SIZE 2 %
            If .Rogue_Size == 2
                % Load 2nd Floor
                ExecWait $Script_Rogue_LoadFloor_Left
                ExecWait $Script_Rogue_LoadCorner1
                % Set Reward Spawn point
                If .Rogue_SpawnAmount == .2Things2Traps
                    Set .Rogue_Item_2 1
                    Call $Function_WriteRewardYaw ( 1 .Down )
                Else
                    Set .Rogue_Item_1 1
                    Call $Function_WriteRewardYaw ( 0 .Down )
                EndIf
            EndIf
        Else % L/R stairs
            ExecWait $Script_Rogue_LoadFloor_Right
            ExecWait $Script_Rogue_LoadCorner2
            % Set Reward Spawn point
            If .Rogue_SpawnAmount == .2Things2Traps
                Set .Rogue_Item_2 2
                Call $Function_WriteRewardYaw ( 1 .Down )
            Else
                Set .Rogue_Item_1 2
                Call $Function_WriteRewardYaw ( 0 .Down )
            EndIf
            % SIZE 2 %
            If .Rogue_Size == 2
                % Load 2nd Floor
                Exec $Script_SetSignPos
                ExecWait $Script_Rogue_LoadFloor_Up
                ExecWait $Script_Rogue_LoadCorner1
                % Set Reward Spawn point
                If .Rogue_SpawnAmount == .2Things2Traps
                    Set .Rogue_Item_2 1
                    Call $Function_WriteRewardYaw ( 1 .Right )
                Else
                    Set .Rogue_Item_1 1
                    Call $Function_WriteRewardYaw ( 0 .Right )
                EndIf
            EndIf
		EndIf
	Case == 4 % Bottom L
        If .Rogue_SpawnSide == 0 % Up/Down stairs
            ExecWait $Script_Rogue_LoadFloor_Down
            ExecWait $Script_Rogue_LoadCorner3
            % Set Reward Spawn point
            If .Rogue_SpawnAmount == .2Things2Traps
                Set .Rogue_Item_2 3
                Call $Function_WriteRewardYaw ( 1 .Left )
            Else
                Set .Rogue_Item_1 3
                Call $Function_WriteRewardYaw ( 0 .Left )
            EndIf
            % SIZE 2 %
            If .Rogue_Size == 2
                % Load 2nd Floor
                ExecWait $Script_Rogue_LoadFloor_Right
                ExecWait $Script_Rogue_LoadCorner2
                % Set Reward Spawn point
                If .Rogue_SpawnAmount == .2Things2Traps
                    Set .Rogue_Item_2 2
                    Call $Function_WriteRewardYaw ( 1 .Down )
                Else
                    Set .Rogue_Item_1 2
                    Call $Function_WriteRewardYaw ( 0 .Down )
                EndIf
            EndIf
        Else % L/R stairs
            ExecWait $Script_Rogue_LoadFloor_Left
            ExecWait $Script_Rogue_LoadCorner1
            % Set Reward Spawn point
            If .Rogue_SpawnAmount == .2Things2Traps
                Set .Rogue_Item_2 1
                Call $Function_WriteRewardYaw ( 1 .Down )
            Else
                Set .Rogue_Item_1 1
                Call $Function_WriteRewardYaw ( 0 .Down )
            EndIf
            % SIZE 2 %
            If .Rogue_Size == 2
                % Load 2nd Floor
                Exec $Script_SetSignPos
                ExecWait $Script_Rogue_LoadFloor_Up
                ExecWait $Script_Rogue_LoadCorner2
                % Set Reward Spawn point
                If .Rogue_SpawnAmount == .2Things2Traps
                    Set .Rogue_Item_2 2
                    Call $Function_WriteRewardYaw ( 1 .Left )
                Else
                    Set .Rogue_Item_1 2
                    Call $Function_WriteRewardYaw ( 0 .Left )
                EndIf
            EndIf
		EndIf
EndSwitch
% Load traps
Label LoadTrap
Jump  $Script_Roguelike_LoadTraps
Return
End
}

% Load the geometry for the 2nd trap when having an Spawn ID of 1Thing2Traps
% Load Spawn Point
#new:Script:Map $Script_Roguelike_LoadFloor_1Thing2Traps
{
% Check if the current trap use a spring
If .Rogue_ID_Flags == .Spring
    Switch	.Rogue_SpawnPoint
        Case == 1 % Upper Left
            If .Rogue_SpawnSide == 0 % v
                % Check if Size 2 was used
                If .Rogue_Flag_Geometry_Floors_Right == .True
                    Set .Rogue_SpawnPoint 3
                    Set .Rogue_SpawnSide  0
                Else % wasn't used
                    Set .Rogue_SpawnPoint 2
                    Set .Rogue_SpawnSide  1
                EndIf
            Else % <
                % Check if Size 2 was used
                If .Rogue_Flag_Geometry_Floors_Down == .True
                    Set .Rogue_SpawnPoint 3
                    Set .Rogue_SpawnSide  1
                Else % wasn't used
                    Set .Rogue_SpawnPoint 4
                    Set .Rogue_SpawnSide  0
                EndIf
            EndIf
        Case == 2 % Upper Right
            % Check if Size 2 was used
            If .Rogue_SpawnSide == 0 % v
                % Check if Size 2 was used
                If .Rogue_Flag_Geometry_Floors_Left == .True
                    Set .Rogue_SpawnPoint 4
                    Set .Rogue_SpawnSide  0
                Else % wasn't used
                    Set .Rogue_SpawnPoint 1
                    Set .Rogue_SpawnSide  1
                EndIf
            Else % <
                % Check if Size 2 was used
                If .Rogue_Flag_Geometry_Floors_Down == .True
                    Set .Rogue_SpawnPoint 4
                    Set .Rogue_SpawnSide  1
                Else % wasn't used
                    Set .Rogue_SpawnPoint 3
                    Set .Rogue_SpawnSide  0
                EndIf
            EndIf
        Case == 3 % Bottom Right
            % Check if Size 2 was used
            If .Rogue_SpawnSide == 0 % v
                % Check if Size 2 was used
                If .Rogue_Flag_Geometry_Floors_Left == .True
                    Set .Rogue_SpawnPoint 1
                    Set .Rogue_SpawnSide  0
                Else % wasn't used
                    Set .Rogue_SpawnPoint 4
                    Set .Rogue_SpawnSide  1
                EndIf
            Else % <
                % Check if Size 2 was used
                If .Rogue_Flag_Geometry_Floors_Up == .True
                    Set .Rogue_SpawnPoint 1
                    Set .Rogue_SpawnSide  1
                Else % wasn't used
                    Set .Rogue_SpawnPoint 2
                    Set .Rogue_SpawnSide  0
                EndIf
            EndIf
        Case == 4 % Bottom Left
            If .Rogue_SpawnSide == 0 % v
                % Check if Size 2 was used
                If .Rogue_Flag_Geometry_Floors_Right == .True
                    Set .Rogue_SpawnPoint 2
                    Set .Rogue_SpawnSide  0
                Else % wasn't used
                    Set .Rogue_SpawnPoint 3
                    Set .Rogue_SpawnSide  1
                EndIf
            Else % <
                % Check if Size 2 was used
                If .Rogue_Flag_Geometry_Floors_Up == .True
                    Set .Rogue_SpawnPoint 2
                    Set .Rogue_SpawnSide  1
                Else % wasn't used
                    Set .Rogue_SpawnPoint 1
                    Set .Rogue_SpawnSide  0
                EndIf
            EndIf
    EndSwitch
    Wait 1
    Goto LoadTrap
EndIf
% Normal Code - Not for springs traps
Label   SpawnPoint
Switch	.Rogue_SpawnPoint
    Case == 1 % Upper Left
        If .Rogue_SpawnSide == 0 % v
            % Check if Size 2 was used
            If .Rogue_Flag_Geometry_Floors_Right == .True
                Set .Rogue_SpawnPoint 4
                Set .Rogue_SpawnSide  0
                ExecWait $Script_Rogue_LoadFloor_Down
                ExecWait $Script_Rogue_LoadCorner4
                ExecWait $Script_Rogue_Load_Stairs1_4-1
            Else % wasn't used
                Set .Rogue_SpawnPoint 3
                Set .Rogue_SpawnSide  1
                ExecWait $Script_Rogue_LoadFloor_Right
                ExecWait $Script_Rogue_LoadCorner3
                ExecWait $Script_Rogue_Load_Stairs1_3-2
            EndIf
        Else % <
            % Check if Size 2 was used
            If .Rogue_Flag_Geometry_Floors_Down == .True
                Set .Rogue_SpawnPoint 2
                Set .Rogue_SpawnSide  1
                ExecWait $Script_Rogue_LoadFloor_Right
                ExecWait $Script_Rogue_LoadCorner2
                ExecWait $Script_Rogue_Load_Stairs1_2-2
            Else % wasn't used
                Set .Rogue_SpawnPoint 3
                Set .Rogue_SpawnSide  0
                ExecWait $Script_Rogue_LoadFloor_Down
                ExecWait $Script_Rogue_LoadCorner3
                ExecWait $Script_Rogue_Load_Stairs1_3-1
            EndIf
        EndIf
	Case == 2 % Upper Right
		% Check if Size 2 was used
        If .Rogue_SpawnSide == 0 % v
            % Check if Size 2 was used
            If .Rogue_Flag_Geometry_Floors_Left == .True
                Set .Rogue_SpawnPoint 3
                Set .Rogue_SpawnSide  0
                ExecWait $Script_Rogue_LoadFloor_Down
                ExecWait $Script_Rogue_LoadCorner3
                ExecWait $Script_Rogue_Load_Stairs1_3-1
            Else % wasn't used
                Set .Rogue_SpawnPoint 4
                Set .Rogue_SpawnSide  1
                ExecWait $Script_Rogue_LoadFloor_Left
                ExecWait $Script_Rogue_LoadCorner4
                ExecWait $Script_Rogue_Load_Stairs1_4-2
            EndIf
        Else % <
            % Check if Size 2 was used
            If .Rogue_Flag_Geometry_Floors_Down == .True
                Set .Rogue_SpawnPoint 1
                Set .Rogue_SpawnSide  1
                ExecWait $Script_Rogue_LoadFloor_Left
                ExecWait $Script_Rogue_LoadCorner1
                ExecWait $Script_Rogue_Load_Stairs1_1-2
            Else % wasn't used
                Set .Rogue_SpawnPoint 4
                Set .Rogue_SpawnSide  0
                ExecWait $Script_Rogue_LoadFloor_Down
                ExecWait $Script_Rogue_LoadCorner4
                ExecWait $Script_Rogue_Load_Stairs1_4-1
            EndIf
        EndIf
	Case == 3 % Bottom Right
		% Check if Size 2 was used
        If .Rogue_SpawnSide == 0 % v
            % Check if Size 2 was used
            If .Rogue_Flag_Geometry_Floors_Left == .True
                Set .Rogue_SpawnPoint 2
                Set .Rogue_SpawnSide  0
                Exec $Script_SetSignPos
                ExecWait $Script_Rogue_LoadFloor_Up
                ExecWait $Script_Rogue_LoadCorner2
                ExecWait $Script_Rogue_Load_Stairs1_2-1
            Else % wasn't used
                Set .Rogue_SpawnPoint 1
                Set .Rogue_SpawnSide  1
                ExecWait $Script_Rogue_LoadFloor_Left
                ExecWait $Script_Rogue_LoadCorner1
                ExecWait $Script_Rogue_Load_Stairs1_1-2
            EndIf
        Else % <
            % Check if Size 2 was used
            If .Rogue_Flag_Geometry_Floors_Up == .True
                Set .Rogue_SpawnPoint 4
                Set .Rogue_SpawnSide  1
                ExecWait $Script_Rogue_LoadFloor_Left
                ExecWait $Script_Rogue_LoadCorner4
                ExecWait $Script_Rogue_Load_Stairs1_4-2
            Else % wasn't used
                Set .Rogue_SpawnPoint 1
                Set .Rogue_SpawnSide  0
                Exec $Script_SetSignPos
                ExecWait $Script_Rogue_LoadFloor_Up
                ExecWait $Script_Rogue_LoadCorner1
                ExecWait $Script_Rogue_Load_Stairs1_1-1
            EndIf
        EndIf
	Case == 4 % Bottom Left
        If .Rogue_SpawnSide == 0 % v
            % Check if Size 2 was used
            If .Rogue_Flag_Geometry_Floors_Right == .True
                Set .Rogue_SpawnPoint 1
                Set .Rogue_SpawnSide  0
                Exec $Script_SetSignPos
                ExecWait $Script_Rogue_LoadFloor_Up
                ExecWait $Script_Rogue_LoadCorner1
                ExecWait $Script_Rogue_Load_Stairs1_1-1
            Else % wasn't used
                Set .Rogue_SpawnPoint 2
                Set .Rogue_SpawnSide  1
                ExecWait $Script_Rogue_LoadFloor_Right
                ExecWait $Script_Rogue_LoadCorner2
                ExecWait $Script_Rogue_Load_Stairs1_2-2
            EndIf
        Else % <
            % Check if Size 2 was used
            If .Rogue_Flag_Geometry_Floors_Up == .True
                Set .Rogue_SpawnPoint 3
                Set .Rogue_SpawnSide  1
                ExecWait $Script_Rogue_LoadFloor_Right
                ExecWait $Script_Rogue_LoadCorner3
                ExecWait $Script_Rogue_Load_Stairs1_3-2
            Else % wasn't used
                Set .Rogue_SpawnPoint 2
                Set .Rogue_SpawnSide  0
                Exec $Script_SetSignPos
                ExecWait $Script_Rogue_LoadFloor_Up
                ExecWait $Script_Rogue_LoadCorner2
                ExecWait $Script_Rogue_Load_Stairs1_2-1
            EndIf
        EndIf
EndSwitch
% Load traps
Label LoadTrap
Jump  $Script_Roguelike_LoadTraps
Return
End
}

%% Bombette
% Geometry

#new:Script:Map $Script_Rogue_LoadBombette
{
Switch .Rogue_SpawnPoint
	Case == 1 % Upper L
        If .Rogue_SpawnSide == 0 % v
            Call     EnableModel 			( .Model_Bombette_Block_Up .True )
            Call     EnableModel 			( .Model_Bombette_Crack_Up .True )
            Call     ModifyColliderFlags 	( .True .Collider_Bombette_Up 7FFFFE00 )
        Else % <
            Call     EnableModel 			( .Model_Bombette_Block_Left .True )
            Call     EnableModel 			( .Model_Bombette_Crack_Left .True )
            Call     ModifyColliderFlags 	( .True .Collider_Bombette_Left 7FFFFE00 )
        EndIf
    Case == 2 % Upper R
        If .Rogue_SpawnSide == 0 % v
            Call     EnableModel 			( .Model_Bombette_Block_Up .True )
            Call     EnableModel 			( .Model_Bombette_Crack_Up .True )
            Call     ModifyColliderFlags 	( .True .Collider_Bombette_Up 7FFFFE00 )
        Else % <
            Call     EnableModel 			( .Model_Bombette_Block_Right .True )
            Call     EnableModel 			( .Model_Bombette_Crack_Right .True )
            Call     ModifyColliderFlags 	( .True .Collider_Bombette_Right 7FFFFE00 )
        EndIf
    Case == 3 % Bottom R
        If .Rogue_SpawnSide == 0 % v
            Call     EnableModel 			( .Model_Bombette_Block_Down .True )
            Call     EnableModel 			( .Model_Bombette_Crack_Down .True )
            Call     ModifyColliderFlags 	( .True .Collider_Bombette_Down 7FFFFE00 )
        Else % <
            Call     EnableModel 			( .Model_Bombette_Block_Right .True )
            Call     EnableModel 			( .Model_Bombette_Crack_Right .True )
            Call     ModifyColliderFlags 	( .True .Collider_Bombette_Right 7FFFFE00 )
        EndIf
    Case == 4 % Bottom L
        If .Rogue_SpawnSide == 0 % v
            Call     EnableModel 			( .Model_Bombette_Block_Down .True )
            Call     EnableModel 			( .Model_Bombette_Crack_Down .True )
            Call     ModifyColliderFlags 	( .True .Collider_Bombette_Down 7FFFFE00 )
        Else % <
            Call     EnableModel 			( .Model_Bombette_Block_Left .True )
            Call     EnableModel 			( .Model_Bombette_Crack_Left .True )
            Call     ModifyColliderFlags 	( .True .Collider_Bombette_Left 7FFFFE00 )
        EndIf
EndSwitch
Return
End
}

#new:Script:Map $Script_Roguelike_LoadFloor_SpikesMoving
{
% Load geometry %
Label   Start
Switch .Rogue_SpawnPoint
	Case == 1 % Upper L
        If .Rogue_SpawnSide == 0 % Up/Down stairs
            Exec $Script_Rogue_LoadFloor_Up1_Spikes
            Exec $Script_Rogue_LoadCorner2_Spikes
            Exec $Script_Rogue_LoadFloor_Right1_Spikes
            % Enable Holes
            Call     EnableModel ( .Model_Holes_Corners_2 .True )
            Call     EnableModel ( .Model_Holes_Floors_Up .True )
            Call     EnableModel ( .Model_Holes_Floors_Right .True )
        Else % L/R stairs
            Exec $Script_Rogue_LoadFloor_Left1_Spikes
            Exec $Script_Rogue_LoadCorner4_Spikes
            Exec $Script_Rogue_LoadFloor_Down1_Spikes
            % Enable Holes
            Call     EnableModel ( .Model_Holes_Corners_4 .True )
            Call     EnableModel ( .Model_Holes_Floors_Left .True )
            Call     EnableModel ( .Model_Holes_Floors_Down .True )
		EndIf
	Case == 2 % Upper R
        If .Rogue_SpawnSide == 0 % Up/Down stairs
            Exec $Script_Rogue_LoadFloor_Up1_Spikes
            Exec $Script_Rogue_LoadCorner1_Spikes
            Exec $Script_Rogue_LoadFloor_Left1_Spikes
            % Enable Holes
            Call     EnableModel ( .Model_Holes_Corners_1 .True )
            Call     EnableModel ( .Model_Holes_Floors_Up .True )
            Call     EnableModel ( .Model_Holes_Floors_Left .True )
        Else % L/R stairs
            Exec $Script_Rogue_LoadFloor_Right1_Spikes
            Exec $Script_Rogue_LoadCorner3_Spikes
            Exec $Script_Rogue_LoadFloor_Down1_Spikes
            % Enable Holes
            Call     EnableModel ( .Model_Holes_Corners_3 .True )
            Call     EnableModel ( .Model_Holes_Floors_Right .True )
            Call     EnableModel ( .Model_Holes_Floors_Down .True )
		EndIf
	Case == 3 % Bottom R
        If .Rogue_SpawnSide == 0 % Up/Down stairs
            Exec $Script_Rogue_LoadFloor_Down1_Spikes
            Exec $Script_Rogue_LoadCorner4_Spikes
            Exec $Script_Rogue_LoadFloor_Left1_Spikes
            % Enable Holes
            Call     EnableModel ( .Model_Holes_Corners_4 .True )
            Call     EnableModel ( .Model_Holes_Floors_Down .True )
            Call     EnableModel ( .Model_Holes_Floors_Left .True )
        Else % L/R stairs
            Exec $Script_Rogue_LoadFloor_Right1_Spikes
            Exec $Script_Rogue_LoadCorner2_Spikes
            Exec $Script_Rogue_LoadFloor_Up1_Spikes
            % Enable Holes
            Call     EnableModel ( .Model_Holes_Corners_2 .True )
            Call     EnableModel ( .Model_Holes_Floors_Right .True )
            Call     EnableModel ( .Model_Holes_Floors_Up .True )
		EndIf
	Case == 4 % Bottom L
        If .Rogue_SpawnSide == 0 % Up/Down stairs
            Exec $Script_Rogue_LoadFloor_Down1_Spikes
            Exec $Script_Rogue_LoadCorner3_Spikes
            Exec $Script_Rogue_LoadFloor_Right1_Spikes
            % Enable Holes
            Call     EnableModel ( .Model_Holes_Corners_3 .True )
            Call     EnableModel ( .Model_Holes_Floors_Down .True )
            Call     EnableModel ( .Model_Holes_Floors_Right .True )
        Else % L/R stairs
            Exec $Script_Rogue_LoadFloor_Left1_Spikes
            Exec $Script_Rogue_LoadCorner1_Spikes
            Exec $Script_Rogue_LoadFloor_Up1_Spikes
            % Enable Holes
            Call     EnableModel ( .Model_Holes_Corners_1 .True )
            Call     EnableModel ( .Model_Holes_Floors_Left .True )
            Call     EnableModel ( .Model_Holes_Floors_Up .True )
		EndIf
EndSwitch
Return
End
}

#new:Script:Map $Script_Roguelike_LoadFloor_SpikesStatic
{
% Load geometry %
Label   Start
Switch .Rogue_SpawnPoint
    Case == 1 % Upper L
        If .Rogue_SpawnSide == 0 % Up/Down stairs
            Exec $Script_Rogue_Load_Stairs2_1-2
            Exec $Script_Rogue_LoadFloor_Up2_Spikes
            Call     ModifyColliderFlags 	( 3 .Collider_Spikes_Floors_2_Up 2 )
        Else % L/R stairs
            Exec $Script_Rogue_Load_Stairs2_1-1
            Exec $Script_Rogue_LoadFloor_Left2_Spikes
            Call     ModifyColliderFlags 	( 3 .Collider_Spikes_Floors_2_Left 2 )
        EndIf
        Call     ResetFromLava 	        ( $ResetPos1 )
    Case == 2 % Upper R
        If .Rogue_SpawnSide == 0 % Up/Down stairs
            Exec $Script_Rogue_Load_Stairs2_2-2
            Exec $Script_Rogue_LoadFloor_Up2_Spikes
            Call     ModifyColliderFlags 	( 3 .Collider_Spikes_Floors_2_Up 2 )
        Else % L/R stairs
            Exec $Script_Rogue_Load_Stairs2_2-1
            Exec $Script_Rogue_LoadFloor_Right2_Spikes
            Call     ModifyColliderFlags 	( 3 .Collider_Spikes_Floors_2_Right 2 )
        EndIf
        Call     ResetFromLava 	        ( $ResetPos2 )
    Case == 3 % Bottom R
        If .Rogue_SpawnSide == 0 % Up/Down stairs
            Exec $Script_Rogue_Load_Stairs2_3-2
            Exec $Script_Rogue_LoadFloor_Down2_Spikes
            Call     ModifyColliderFlags 	( 3 .Collider_Spikes_Floors_2_Down 2 )
        Else % L/R stairs
            Exec $Script_Rogue_Load_Stairs2_3-1
            Exec $Script_Rogue_LoadFloor_Right2_Spikes
            Call     ModifyColliderFlags 	( 3 .Collider_Spikes_Floors_2_Right 2 )
        EndIf
        Call     ResetFromLava 	        ( $ResetPos3 )
    Case == 4 % Bottom L
        If .Rogue_SpawnSide == 0 % Up/Down stairs
            Exec $Script_Rogue_Load_Stairs2_4-2
            Exec $Script_Rogue_LoadFloor_Down2_Spikes
            Call     ModifyColliderFlags 	( 3 .Collider_Spikes_Floors_2_Down 2 )
        Else % L/R stairs
            Exec $Script_Rogue_Load_Stairs2_4-1
            Exec $Script_Rogue_LoadFloor_Left2_Spikes
            Call     ModifyColliderFlags 	( 3 .Collider_Spikes_Floors_2_Left 2 )
        EndIf
        Call     ResetFromLava 	        ( $ResetPos4 )
EndSwitch
Return
End
}

% 4 Chests/Spring
#new:Script:Map $Script_Rogue_Load_4ChestsCorners1
{
% Corners
Exec    $Script_Rogue_LoadCorner1
Exec    $Script_Rogue_LoadCorner2
Exec    $Script_Rogue_LoadCorner3
Exec    $Script_Rogue_LoadCorner4
% Stairs
Exec    $Script_Rogue_Load_Stairs1_1-1
Exec    $Script_Rogue_Load_Stairs1_1-2
Exec    $Script_Rogue_Load_Stairs1_2-1
Exec    $Script_Rogue_Load_Stairs1_2-2
Exec    $Script_Rogue_Load_Stairs1_3-1
Exec    $Script_Rogue_Load_Stairs1_3-2
Exec    $Script_Rogue_Load_Stairs1_4-1
Exec    $Script_Rogue_Load_Stairs1_4-2
Return
End
}

#new:Script:Map $Script_Rogue_Load_4ChestsCorners2
{
Exec $Script_Rogue_Load_TopCorner1-1
Exec $Script_Rogue_Load_TopCorner1-2
Exec $Script_Rogue_Load_TopCorner2-1
Exec $Script_Rogue_Load_TopCorner2-2
Exec $Script_Rogue_Load_TopCorner3-1
Exec $Script_Rogue_Load_TopCorner3-2
Exec $Script_Rogue_Load_TopCorner4-1
Exec $Script_Rogue_Load_TopCorner4-2
Return
End
}

% Activate Spikes Geometry
% Corners
#new:Script:Map $Script_Rogue_LoadCorner1_Spikes
{
Call     EnableModel 			( .Model_Spikes_Corners_1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Spikes_Corners_1 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_LoadCorner2_Spikes
{
Call     EnableModel 			( .Model_Spikes_Corners_2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Spikes_Corners_2 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_LoadCorner3_Spikes
{
Call     EnableModel 			( .Model_Spikes_Corners_3 .True )
Call     ModifyColliderFlags 	( .True .Collider_Spikes_Corners_3 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_LoadCorner4_Spikes
{
Call     EnableModel 			( .Model_Spikes_Corners_4 .True )
Call     ModifyColliderFlags 	( .True .Collider_Spikes_Corners_4 7FFFFE00 )
Return
End
}

% Spike Floors
% Moving Spikes
#new:Script:Map $Script_Rogue_LoadFloor_Up1_Spikes
{
Call     EnableModel 			( .Model_Spikes_Floors_Up .True )
Call     ModifyColliderFlags 	( .True .Collider_Spikes_Floors_1_Up 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_LoadFloor_Left1_Spikes
{
Call     EnableModel 			( .Model_Spikes_Floors_Left .True )
Call     ModifyColliderFlags 	( .True .Collider_Spikes_Floors_1_Left 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_LoadFloor_Right1_Spikes
{
Call     EnableModel 			( .Model_Spikes_Floors_Right .True )
Call     ModifyColliderFlags 	( .True .Collider_Spikes_Floors_1_Right 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_LoadFloor_Down1_Spikes
{
Call     EnableModel 			( .Model_Spikes_Floors_Down .True )
Call     ModifyColliderFlags 	( .True .Collider_Spikes_Floors_1_Down 7FFFFE00 )
Return
End
}

%Static Spikes
#new:Script:Map $Script_Rogue_LoadFloor_Up2_Spikes
{
Call     EnableModel 			( .Model_Spikes_Floors_Up .True )
Call     ModifyColliderFlags 	( .True .Collider_Spikes_Floors_2_Up 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_LoadFloor_Right2_Spikes
{
Call     EnableModel 			( .Model_Spikes_Floors_Right .True )
Call     ModifyColliderFlags 	( .True .Collider_Spikes_Floors_2_Right 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_LoadFloor_Down2_Spikes
{
Call     EnableModel 			( .Model_Spikes_Floors_Down .True )
Call     ModifyColliderFlags 	( .True .Collider_Spikes_Floors_2_Down 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_LoadFloor_Left2_Spikes
{
Call     EnableModel 			( .Model_Spikes_Floors_Left .True )
Call     ModifyColliderFlags 	( .True .Collider_Spikes_Floors_2_Left 7FFFFE00 )
Return
End
}

%% Water Gaps Loader
#new:Script:Map $Script_Roguelike_LoadFloor_WaterGaps
{
Switch .Rogue_SpawnPoint
    Case == 1 % Upper L
        ExecWait $Script_Rogue_LoadFloor_Up_Water
        ExecWait $Script_Rogue_Load_Stairs2_1-2
        ExecWait $Script_Rogue_Load_TopCorner2-2
        % Set Reward Spawn point
        If .Rogue_SpawnAmount == .2Things2Traps
            Set .Rogue_Item_2 2
            Call $Function_WriteRewardYaw ( 1 .Left )
        Else
        % If an item has already spawned use the other one
            Set .Rogue_Item_1 2
            Call $Function_WriteRewardYaw ( 0 .Left )
        EndIf
    Case == 2 % Upper R
        ExecWait $Script_Rogue_LoadFloor_Up_Water
        ExecWait $Script_Rogue_Load_Stairs2_2-2
        ExecWait $Script_Rogue_Load_TopCorner1-2
        % Set Reward Spawn point
        If .Rogue_SpawnAmount == .2Things2Traps
            Set .Rogue_Item_2 1
            Call $Function_WriteRewardYaw ( 1 .Right )
        Else
        % If an item has already spawned use the other one
            Set .Rogue_Item_1 1
            Call $Function_WriteRewardYaw ( 0 .Right )
        EndIf
    Case == 3 % Bottom R
        ExecWait $Script_Rogue_LoadFloor_Down_Water
        ExecWait $Script_Rogue_Load_Stairs2_3-2
        ExecWait $Script_Rogue_Load_TopCorner4-2
        % Set Reward Spawn point
        If .Rogue_SpawnAmount == .2Things2Traps
            Set .Rogue_Item_2 4
            Call $Function_WriteRewardYaw ( 1 .Right )
        Else
        % If an item has already spawned use the other one
            Set .Rogue_Item_1 4
            Call $Function_WriteRewardYaw ( 0 .Right )
        EndIf
    Case == 4 % Bottom L
        ExecWait $Script_Rogue_LoadFloor_Down_Water
        ExecWait $Script_Rogue_Load_Stairs2_4-2
        ExecWait $Script_Rogue_Load_TopCorner3-2
        % Set Reward Spawn point
        If .Rogue_SpawnAmount == .2Things2Traps
            Set .Rogue_Item_2 3
            Call $Function_WriteRewardYaw ( 1 .Left )
        Else
        % If an item has already spawned use the other one
            Set .Rogue_Item_1 3
            Call $Function_WriteRewardYaw ( 0 .Left )
        EndIf
EndSwitch
Return
End
}

% Load Polls
#new:Script:Map $Script_Rogue_LoadFloor_Up_Water
{
Call     EnableModel 			( .Model_Waterpads_Walls_Up .True )
Call     EnableModel 			( .Model_Waterpads_Pools_Up .True )
Call     EnableModel 			( .Model_Waterpads_Pads_1 .True )
Call     EnableModel 			( .Model_Waterpads_Pads_2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Waterpads_Walls_Up 7FFFFE00 )
Call     ModifyColliderFlags 	( .True .Collider_Waterpads_Pools_Up 7FFFFE00 )
Call     ModifyColliderFlags 	( .True .Collider_Waterpads_Pads_Floor_1 7FFFFE00 )
Call     ModifyColliderFlags 	( .True .Collider_Waterpads_Pads_Floor_2 7FFFFE00 )
Call     ModifyColliderFlags    ( .True .Collider_Waterpads_Pads_Walls_1 7FFFFE00 )
Call     ModifyColliderFlags    ( .True .Collider_Waterpads_Pads_Walls_2 7FFFFE00 )
Call     ModifyColliderFlags 	( 3 .Collider_Waterpads_Pads_Walls_1 00000004 )
Call     ModifyColliderFlags 	( 3 .Collider_Waterpads_Pads_Walls_2 00000004 )
Call     ModifyColliderFlags 	( 0 .Collider_Waterpads_Pads_Walls_1 00080000 )
Call     ModifyColliderFlags 	( 0 .Collider_Waterpads_Pads_Walls_2 00080000 )
Return
End
}

#new:Script:Map $Script_Rogue_LoadFloor_Down_Water
{
Call     EnableModel 			( .Model_Waterpads_Walls_Down .True )
Call     EnableModel 			( .Model_Waterpads_Pools_Down .True )
Call     EnableModel 			( .Model_Waterpads_Pads_3 .True )
Call     EnableModel 			( .Model_Waterpads_Pads_4 .True )
Call     ModifyColliderFlags 	( .True .Collider_Waterpads_Walls_Down 7FFFFE00 )
Call     ModifyColliderFlags 	( .True .Collider_Waterpads_Pools_Down 7FFFFE00 )
Call     ModifyColliderFlags 	( .True .Collider_Waterpads_Pads_Floor_3 7FFFFE00 )
Call     ModifyColliderFlags 	( .True .Collider_Waterpads_Pads_Floor_4 7FFFFE00 )
Call     ModifyColliderFlags    ( .True .Collider_Waterpads_Pads_Walls_3 7FFFFE00 )
Call     ModifyColliderFlags    ( .True .Collider_Waterpads_Pads_Walls_4 7FFFFE00 )
Call     ModifyColliderFlags 	( 3 .Collider_Waterpads_Pads_Walls_3 00000004 )
Call     ModifyColliderFlags 	( 3 .Collider_Waterpads_Pads_Walls_4 00000004 )
Call     ModifyColliderFlags 	( 0 .Collider_Waterpads_Pads_Walls_3 00080000 )
Call     ModifyColliderFlags 	( 0 .Collider_Waterpads_Pads_Walls_4 00080000 )
Return
End
}

%% Load Stairs - Set2
#new:Script:Map $Script_Rogue_Load_Stairs2_1-1
{
Call     EnableModel 			( .Model_Stairs_Set2_1-1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set2_1-1 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs2_1-2
{
Call     EnableModel 			( .Model_Stairs_Set2_1-2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set2_1-2 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs2_2-1
{
Call     EnableModel 			( .Model_Stairs_Set2_2-1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set2_2-1 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs2_2-2
{
Call     EnableModel 			( .Model_Stairs_Set2_2-2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set2_2-2 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs2_3-1
{
Call     EnableModel 			( .Model_Stairs_Set2_3-1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set2_3-1 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs2_3-2
{
Call     EnableModel 			( .Model_Stairs_Set2_3-2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set2_3-2 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs2_4-1
{
Call     EnableModel 			( .Model_Stairs_Set2_4-1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set2_4-1 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs2_4-2
{
Call     EnableModel 			( .Model_Stairs_Set2_4-2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set2_4-2 7FFFFE00 )
Return
End
}

% Blast Blocks
#new:Data $Bomb_Up
{
-532.00000000000 26.00000000000 -56.00000000000 0.00000000000
}

#new:Data $Bomb_Right
{
-345.00000000000 26.00000000000 34.00000000000 0.00000000000
}

#new:Data $Bomb_Down
{
-532.00000000000 26.00000000000 148.00000000000 0.00000000000
}

#new:Data $Bomb_Left
{
-726.00000000000 26.00000000000 34.00000000000 0.00000000000
}

#new:Script:Map $Script_BlastBombetteBlockUp
{
    Call     PlayEffect  	( 66` 0 .Model_Bombette_Block_Up .Model_Bombette_Block_Up 1 10` 30` ) % fxID ParticlesFxID ModelIDforPos ModelIDforParticles size ? time
    Call     EnableModel 	( .Model_Bombette_Block_Up .False )
    Call     EnableModel 	( .Model_Bombette_Crack_Up .False )
    Call     ModifyColliderFlags 	( .False .Collider_Bombette_Up 7FFFFE00 )
    Unbind
    Return
    End
}

    #new:Script:Map $Script_BlastBombetteBlockRight
{
    % Right
    Call     PlayEffect  	( 66` 0 .Model_Bombette_Block_Right .Model_Bombette_Block_Right 1 10` 30` )
    Call     EnableModel 	( .Model_Bombette_Block_Right .False )
    Call     EnableModel 	( .Model_Bombette_Crack_Right .False )
    Call     ModifyColliderFlags 	( .False .Collider_Bombette_Right 7FFFFE00 )
    Unbind
    Return
    End
}

    #new:Script:Map $Script_BlastBombetteBlockDown
{
    % Down
    Call     PlayEffect  	( 66` 0 .Model_Bombette_Block_Down .Model_Bombette_Block_Down 1 10` 30` )
    Call     EnableModel 	( .Model_Bombette_Block_Down .False )
    Call     EnableModel 	( .Model_Bombette_Crack_Down .False )
    Call     ModifyColliderFlags 	( .False .Collider_Bombette_Down 7FFFFE00 )
    Unbind
    Return
    End
}

    #new:Script:Map $Script_BlastBombetteBlockLeft
{
    % left
    Call     PlayEffect  	( 66` 0 .Model_Bombette_Block_Left .Model_Bombette_Block_Left 1 10` 30` )
    Call     EnableModel 	( .Model_Bombette_Block_Left .False )
    Call     EnableModel 	( .Model_Bombette_Crack_Left .False )
    Call     ModifyColliderFlags 	( .False .Collider_Bombette_Left 7FFFFE00 )
    Unbind
    Return
    End
}

#new:Script:Map $Script_Destroy_SuperBlock_Left
{
Call    $Function_GetHammer % save in var3
If  *Var[3] == 0
    Return
EndIf
Call     PlayEffect  	        ( 66` 0 .Model_Block_Super_Left .Model_Block_Super_Left 1 10` 26` ) % fxID ParticlesFxID ModelIDforPos ModelIDforParticles size ? time
Call     PlaySound       ( 0150 ) % Super Block Destroyed
Call     EnableModel 	        ( .Model_Block_Super_Left .False )
Call     ModifyColliderFlags 	( .False .Collider_Block_Left 7FFFFE00 )
Unbind
Return
End
}

#new:Script:Map $Script_Bind_PointBomb
{
    Switch .Rogue_SpawnPoint
        Case == 1 % Upper L
            If .Rogue_SpawnSide == 0 % v
                Bind     $Script_BlastBombetteBlockUp .Trigger:PointBomb $Bomb_Up 00000001 00000000
            Else % <
                Bind     $Script_BlastBombetteBlockLeft .Trigger:PointBomb $Bomb_Left 00000001 00000000
            EndIf
        Case == 2 % Upper R
            If .Rogue_SpawnSide == 0 % v
                Bind     $Script_BlastBombetteBlockUp .Trigger:PointBomb $Bomb_Up 00000001 00000000
            Else % <
                Bind     $Script_BlastBombetteBlockRight .Trigger:PointBomb $Bomb_Right 00000001 00000000
            EndIf
        Case == 3 % Bottom R
            If .Rogue_SpawnSide == 0 % v
                Bind     $Script_BlastBombetteBlockDown .Trigger:PointBomb $Bomb_Down 00000001 00000000
            Else % <
                Bind     $Script_BlastBombetteBlockRight .Trigger:PointBomb $Bomb_Right 00000001 00000000
            EndIf
        Case == 4 % Bottom L
            If .Rogue_SpawnSide == 0 % v
                Bind     $Script_BlastBombetteBlockDown .Trigger:PointBomb $Bomb_Down 00000001 00000000
            Else % <
                Bind     $Script_BlastBombetteBlockLeft .Trigger:PointBomb $Bomb_Left 00000001 00000000
            EndIf
    EndSwitch
    Return
    End
}

#new:Script:Map $Script_Rogue_LoadEngine
{
Switch	.Rogue_SpawnPoint
Case == 1 % Upper Left
    Call EnableGroup ( .Model_Group_Engine_1 .True )
    Call EnableModel ( .Model_Engine_1_Green .False )
Case == 2 % Upper Right
    Call EnableGroup ( .Model_Group_Engine_2 .True )
    Call EnableModel ( .Model_Engine_2_Green .False )
Case == 3 % Bottom Right
    Call EnableGroup ( .Model_Group_Engine_3 .True )
    Call EnableModel ( .Model_Engine_3_Green .False )
Case == 4 % Bottom Left
    Call EnableGroup ( .Model_Group_Engine_4 .True )
    Call EnableModel ( .Model_Engine_4_Green .False )
EndSwitch
Return
End
}

#new:Script:Map $Script_Roguelike_LoadTraps
{
Switch .Rogue_ID
    %% Why all MakeEntities use Rogue_Entity1? (those are just the coordinates to spawn the entity, isn't an ID)
    % The coordinates to spawn the entity get rewrited when using $Script_Rogue_CheckFlags_Entities
    CaseOR == 0 % Block - Super Hammer
    CaseOR == 1 % Block - Ultra Hammer
        If .Rogue_ID == 0
            Call     MakeEntity  	( .Entity:Hammer2Block 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        Else
            Call     MakeEntity  	( .Entity:Hammer3Block 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        EndIf
        ExecWait $Script_Rogue_Entities_SetSpawn
    EndCaseGroup
    Case == 2 % Spring - Super Boots
        Call     MakeEntity  	( .Entity:ScriptSpring 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        Call     AssignScript 	( $Script_UseSpring )
        ExecWait $Script_Rogue_Entities_SpawnSprings
    Case == 3 % ? Switch - Ultra Boots
        Call     MakeEntity  	( .Entity:SingleTriggerBlock 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        Call     AssignScript 	( $Script_Reward_Spawn_Switches_TrapID3 )
        ExecWait $Script_Rogue_Entities_SetSpawn
    Case == 4 % Switch - Kooper 1
        Call     MakeEntity  	( .Entity:BlueSwitch 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        Call     AssignScript 	( $Script_Reward_Spawn_Switches_TrapID4 )
        ExecWait $Script_Rogue_Entities_SetSpawn
    Case == 5 % Switch - Kooper 2
        Call     MakeEntity  	( .Entity:BlueSwitch 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        Call     AssignScript 	( $Script_Reward_Spawn_Switches_TrapID5 )
        ExecWait $Script_Rogue_Entities_SetSpawn
    Case == 6 % Grab Item - Kooper Only
        % spawn item and all that stuff
    Case == 7 % Grab Item - Kooper and Parakarry
        % spawn item and all that stuff
    Case == 8 % Rocks - Bombette
        ExecWait $Script_Rogue_LoadBombette
        ExecWait $Script_Bind_PointBomb
    Case == 11` % Spikes - Bow and Lakilester
        Exec $Script_Roguelike_LoadFloor_SpikesMoving % uses Exec, it doesn't load the reward when using ExecWait (why o.o?!)
        Exec $Script_Roguelike_MoveSpikes
        Wait 6
    Case == 12` % Water Gaps - Sushie
        ExecWait $Script_Roguelike_LoadFloor_WaterGaps
    Case == 13` % Spikes - Lakilester Only
        Exec $Script_Roguelike_LoadFloor_SpikesStatic % uses Exec, it doesn't load the reward when using ExecWait (why o.o?!)
        Wait 3
    Case == 14` % Spring - Goombario Only
        Call     MakeEntity  	( .Entity:ScriptSpring 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        Call     AssignScript 	( $Script_UseSpring )
        ExecWait $Script_Rogue_Entities_SpawnSprings
    Case == 16` % Spring - Watt Only
        Call     MakeEntity  	( .Entity:ScriptSpring 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        Call     AssignScript 	( $Script_UseSpring )
        ExecWait $Script_Rogue_Entities_SpawnSprings
        ExecWait $Script_Rogue_LoadEngine
    Case == 17` % Spring - Keys Based
        Call     MakeEntity  	( .Entity:ScriptSpring 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        Call     AssignScript 	( $Script_UseSpring )
        Call     MakeEntity  	( .Entity:Padlock 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        ExecWait $Script_Rogue_Entities_SpawnSprings
    Case == 18` % Springs - Battle Based
        Call     MakeEntity  	( .Entity:ScriptSpring 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        Call     AssignScript 	( $Script_UseSpring )
        ExecWait $Script_Rogue_Entities_SpawnSprings
    Case == 19` % 4 Chests/Springs
        Jump     $Script_Rogue_4Chests
    Case == 20` % Springs - Coins Based
        Call     MakeEntity  	( .Entity:ScriptSpring 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        Call     AssignScript 	( $Script_UseSpring )
        Call     MakeEntity  	( .Entity:PadlockBlueFace 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        ExecWait $Script_Rogue_Entities_SpawnSprings
    Case == 21` % Springs - HP Based
        Call     MakeEntity  	( .Entity:ScriptSpring 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        Call     AssignScript 	( $Script_UseSpring )
        Call     MakeEntity  	( .Entity:PadlockRedFace 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1
        ExecWait $Script_Rogue_Entities_SpawnSprings
EndSwitch
If .Rogue_SpawnAmount != .1Thing1Trap % save only if loadedID is still FF
    Set .Rogue_LoadedID .Rogue_ID % save previously loaded trap
EndIf
Switch .Rogue_SpawnAmount
    Case == .2Things2Traps % Spawn 2 things
        Set .Rogue_SpawnAmount .1Thing1Trap % to not load another trap again
        Jump $Script_Roguelike_GetFloor
    Case == .1Thing2Traps % Spawn 1 thing with 2 ways to reach to that thing
        Jump $Script_Roguelike_GetFloor
        Return
EndSwitch
% Spawn Rewards
ExecWait $Script_Reward_SetSwitch_SpawnPoint % check if the trap is a switch based
% Check if a second reward need to be spawned
If .Rogue_Item_2 != .False
    % 1st Reward - from LoadedID
    Call $Function_Reward_WriteData2
    Call $Function_Reward_GetData2
    % Save Yaw from Yaw2 in YawX
    Call $Function_GetRewardYaw      ( 1 *Var[0] )
    Call $Function_WriteRewardYawVar ( 2 *Var[0] )
    ExecWait $Script_InitReward
    % 2nd Reward - from RogueID
    Call $Function_Reward_WriteData1
    Call $Function_Reward_GetData1
    % Save Yaw from Yaw1 in YawX
    Call $Function_GetRewardYaw      ( 0 *Var[0] )
    Call $Function_WriteRewardYawVar ( 2 *Var[0] )
    ExecWait $Script_InitReward
    Return
EndIf
% Just a single reward
% Check if 1Thing2Traps was used
If  .Rogue_LoadedID != FF
    % 1Thing2Traps was loaded
    Call    $Function_Reward_WriteData1B
Else
    Call    $Function_Reward_WriteData1
EndIf
Call $Function_Reward_GetData1
% Save Yaw from Yaw1 in YawX
Call $Function_GetRewardYaw      ( 0 *Var[0] ) % YawID output
Call $Function_WriteRewardYawVar ( 2 *Var[0] ) % YawID ValueToSave
ExecWait $Script_InitReward
Return
End
}

% used just for switch style traps
#new:Script:Map $Script_Reward_SetSwitch_SpawnPoint
{
Switch .Rogue_ID
    /%
    *Var[A]=Spawn Position ID
    *Var[B]=Trap ID
    *Var[C]=Rarity Points
    %/
    CaseOR == 3 % ? Switch - Ultra Boots
    CaseOR == 4 % Switch - Kooper 1
    CaseOR == 5 % Switch - Kooper 2
        Set .Rogue_Item_1 5 % Reward Spawn Point - Switch Trap 1
    EndCaseGroup
EndSwitch
% Check if loaded ID was used
If .Rogue_LoadedID != FF
    Switch .Rogue_LoadedID
        /%
        *Var[A]=Spawn Position ID
        *Var[B]=Trap ID
        *Var[C]=Rarity Points
        %/
        CaseOR == 3 % ? Switch - Ultra Boots
        CaseOR == 4 % Switch - Kooper 1
        CaseOR == 5 % Switch - Kooper 2
            If .Rogue_Item_1 == 5 % Switch Reward Position L
                Set .Rogue_Item_2 6 % Reward Spawn Point - Switch Trap 2
            Else
                Set .Rogue_Item_2 5
            EndIf
        EndCaseGroup
    EndSwitch
EndIf
Return
End
}


#new:Function $Function_Reward_WriteData1
{
PUSH	RA, V0, A1, A2
LIO 	A1, *MapVar[D] % .Rogue_Item_1
JAL 	~Func:get_variable 
RESERVED
SAH     V0, $Data_Reward_Data1
LIO 	A1, *MapVar[4] % .Rogue_ID
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Data_Reward_Data1
SB      V0, 2 (T0)
JPOP    RA, V0, A1, A2
}

#new:Function $Function_Reward_WriteData1B
{
PUSH	RA, V0, A1, A2
LIO 	A1, *MapVar[D] % .Rogue_Item_1
JAL 	~Func:get_variable 
RESERVED
SAH     V0, $Data_Reward_Data1
LIO 	A1, *MapVar[C] % .Rogue_LoadedID
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Data_Reward_Data1
SB      V0, 2 (T0)
JPOP    RA, V0, A1, A2
}

#new:Function $Function_Reward_WriteData2
{
PUSH	RA, V0, A1, A2
LIO 	A1, *MapVar[E] % .Rogue_Item_2
JAL 	~Func:get_variable 
RESERVED
SAH     V0, $Data_Reward_Data2
LIO 	A1, *MapVar[C] % .Rogue_LoadedID
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Data_Reward_Data2
SB      V0, 2 (T0)
JPOP    RA, V0, A1, A2
}

#new:Function $Function_Reward_GetData1
{
PUSH	RA, V0, A1, A2
LIO     T0, $Data_Reward_Data1
LHU     A2, 0 (T0)
LIO 	A1, *Var[A]
JAL 	~Func:set_variable
RESERVED
LIO     T0, $Data_Reward_Data1
LBU     A2, 2 (T0)
LIO 	A1, *Var[B]
JAL 	~Func:set_variable
RESERVED
LIO     T0, $Data_Reward_Data1
LBU     A2, 3 (T0)
LIO 	A1, *Var[C]
JAL 	~Func:set_variable
RESERVED
JPOP	RA, V0, A1, A2
}

#new:Function $Function_Reward_GetData2
{
PUSH	RA, V0, A1, A2
LIO     T0, $Data_Reward_Data2
LHU     A2, 0 (T0)
LIO 	A1, *Var[A]
JAL 	~Func:set_variable
RESERVED
LIO     T0, $Data_Reward_Data2
LBU     A2, 2 (T0)
LIO 	A1, *Var[B]
JAL 	~Func:set_variable
RESERVED
LIO     T0, $Data_Reward_Data2
LBU     A2, 3 (T0)
LIO 	A1, *Var[C]
JAL 	~Func:set_variable
RESERVED
JPOP	RA, V0, A1, A2
}

% writes in VarA/B/C
#new:Function $Function_Reward_GetDataX
{
PUSH	RA, V0, A1, A2
LAHU    A2, $Data_Reward_DataX
LIO 	A1, *Var[A] % Reward Spawn Point
JAL 	~Func:set_variable
RESERVED
LIO     A2, $Data_Reward_DataX
LBU     A2, 2 (A2)
LIO 	A1, *Var[B] % Trap ID
JAL 	~Func:set_variable
RESERVED
LIO     A2, $Data_Reward_DataX
LBU     A2, 3 (A2)
LIO 	A1, *Var[C] % Rarity Points
JAL 	~Func:set_variable
RESERVED
JPOP	RA, V0, A1, A2
}

#new:Function $Function_Reward_GetDataX_Alt
{
PUSH	RA, V0, A1, A2
LAHU    A2, $Data_Reward_DataX
LIO 	A1, *Var[4] % Reward Spawn Point
JAL 	~Func:set_variable
RESERVED
LIO     A2, $Data_Reward_DataX
LBU     A2, 2 (A2)
LIO 	A1, *Var[5] % Trap ID
JAL 	~Func:set_variable
RESERVED
LIO     A2, $Data_Reward_DataX
LBU     A2, 3 (A2)
LIO 	A1, *Var[6] % Rarity Points
JAL 	~Func:set_variable
RESERVED
JPOP	RA, V0, A1, A2
}

#new:Function $Function_Reward_WriteDataX
{
PUSH	RA, V0, A1, A2
LIO 	A1, *Var[A] % Reward Spawn Point
JAL 	~Func:get_variable 
RESERVED
SAH     V0, $Data_Reward_DataX
LIO 	A1, *Var[B] % Trap ID
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Data_Reward_DataX
SB      V0, 2 (T0)
LIO 	A1, *Var[C] % Rarity Points
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Data_Reward_DataX
SB      V0, 3 (T0)
JPOP    RA, V0, A1, A2
}

#new:Function $Function_Reward_WriteDataX_Alt
{
PUSH	RA, V0, A1, A2
LIO 	A1, *Var[4] % Reward Spawn Point
JAL 	~Func:get_variable 
RESERVED
SAH     V0, $Data_Reward_DataX
LIO 	A1, *Var[5] % Trap ID
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Data_Reward_DataX
SB      V0, 2 (T0)
LIO 	A1, *Var[6] % Rarity Points
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Data_Reward_DataX
SB      V0, 3 (T0)
JPOP    RA, V0, A1, A2
}

#new:Function $Function_NukeRogueData
{
SAW     R0, $Entity_Var1
SAW     R0, $Entity_Var2
SAW     R0, $Entity_Var3
SAW     R0, $Entity_Var4
SAB     R0, $LockVar
SAB     R0, $RewardVar
SAW     R0, $Data_Reward_Data1
SAW     R0, $Data_Reward_Data2
SAW     R0, $Data_Reward_DataX
SAW     R0, $Data_Reward_DataExtra
SAW     R0, $Entity_Switch_Var1
SAW     R0, $Entity_Switch_Var2
SAW     R0, $Reward_SuperBlock_Data1
SAW     R0, $Reward_SuperBlock_Data2
SAH     R0, $Reward_RewardID1
SAH     R0, $Reward_RewardID2
SAH     R0, $Reward_RewardID3
SAH     R0, $Reward_RewardID4
SAH     R0, $Data_Reward_GiantChestID
SAH     R0, $Data_GiantChestYaw
JR      RA
NOP
}

#new:Data $ItemList_ImpossibleItem
{
.Item:ToadDoll
00000000
}

#new:Function $Function_LockAnimation
{
    0:  ADDIU     SP, SP, FFE8
    4:  SW        RA, 10 (SP)
    8:  JAL       ~Func:get_entity_by_index
    C:  LW        A0, 84 (A0)
   10:  DADDU     V1, V0, R0
   14:  LW        A0, 0 (V1)
   18:  LUI       A1, 10
   1C:  OR        A0, A0, A1
   20:  SW        A0, 0 (V1)
   24:  LW        RA, 10 (SP)
   28:  ADDIU     V0, R0, 2
   2C:  JR        RA
   30:  ADDIU     SP, SP, 18
}

#new:Function $Function_GetEntityPosition
{
    0:  ADDIU     SP, SP, FFE0
    4:  SW        S2, 18 (SP)
    8:  DADDU     S2, A0, R0
    C:  SW        RA, 1C (SP)
   10:  SW        S1, 14 (SP)
   14:  SW        S0, 10 (SP)
   18:  LW        S0, C (S2)
   1C:  LW        A1, 0 (S0)
   20:  JAL       ~Func:get_variable
   24:  ADDIU     S0, S0, 4
   28:  JAL       ~Func:get_entity_by_index
   2C:  DADDU     A0, V0, R0
   30:  LW        A1, 0 (S0)
   34:  ADDIU     S0, S0, 4
   38:  DADDU     S1, V0, R0
   3C:  LWC1      F0, 48 (S1)
   40:  TRUNC.W.S F2, F0
   44:  MFC1      A2, F2
   48:  JAL       ~Func:set_variable
   4C:  DADDU     A0, S2, R0
   50:  LW        A1, 0 (S0)
   54:  ADDIU     S0, S0, 4
   58:  LWC1      F0, 4C (S1)
   5C:  TRUNC.W.S F2, F0
   60:  MFC1      A2, F2
   64:  JAL       ~Func:set_variable
   68:  DADDU     A0, S2, R0
   6C:  LWC1      F0, 50 (S1)
   70:  LW        A1, 0 (S0)
   74:  TRUNC.W.S F2, F0
   78:  MFC1      A2, F2
   7C:  JAL       ~Func:set_variable
   80:  DADDU     A0, S2, R0
   84:  LW        RA, 1C (SP)
   88:  LW        S2, 18 (SP)
   8C:  LW        S1, 14 (SP)
   90:  LW        S0, 10 (SP)
   94:  ADDIU     V0, R0, 2
   98:  JR        RA
   9C:  ADDIU     SP, SP, 20
}

%%%%%% Load Level 1 Stairs
#new:Script:Map $Script_Rogue_Load_Stairs1_1-1
{
Call     EnableModel 			( .Model_Stairs_Set1_1-1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set1_1-1 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Stairs_1-1 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs1_1-2
{
Call     EnableModel 			( .Model_Stairs_Set1_1-2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set1_1-2 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Stairs_1-1 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs1_2-1
{
Call     EnableModel 			( .Model_Stairs_Set1_2-1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set1_2-1 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Stairs_1-1 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs1_2-2
{
Call     EnableModel 			( .Model_Stairs_Set1_2-2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set1_2-2 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Stairs_1-1 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs1_3-1
{
Call     EnableModel 			( .Model_Stairs_Set1_3-1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set1_3-1 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Stairs_1-1 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs1_3-2
{
Call     EnableModel 			( .Model_Stairs_Set1_3-2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set1_3-2 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Stairs_1-1 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs1_4-1
{
Call     EnableModel 			( .Model_Stairs_Set1_4-1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set1_4-1 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Stairs_1-1 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_Stairs1_4-2
{
Call     EnableModel 			( .Model_Stairs_Set1_4-2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Stairs_Set1_4-2 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Stairs_1-1 .True
Return
End
}

%%%%%% Load Level 1 Corners
#new:Script:Map $Script_Rogue_LoadCorner1
{
Call     EnableModel 			( .Model_Corners_Set1_1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Corners_Set1_1 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Corners_1 .True
Return
End
}

#new:Script:Map $Script_Rogue_LoadCorner2
{
Call     EnableModel 			( .Model_Corners_Set1_2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Corners_Set1_2 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Corners_2 .True
Return
End
}

#new:Script:Map $Script_Rogue_LoadCorner3
{
Call     EnableModel 			( .Model_Corners_Set1_3 .True )
Call     ModifyColliderFlags 	( .True .Collider_Corners_Set1_3 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Corners_3 .True
Return
End
}

#new:Script:Map $Script_Rogue_LoadCorner4
{
Call     EnableModel 			( .Model_Corners_Set1_4 .True )
Call     ModifyColliderFlags 	( .True .Collider_Corners_Set1_4 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Corners_4 .True
Return
End
}

%% Load Top Corners
#new:Script:Map $Script_Rogue_Load_TopCorner1-1
{
Call     EnableModel 			( .Model_Corners_Set2_1-1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Corners_Set2_1-1 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Corners_1 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_TopCorner1-2
{
Call     EnableModel 			( .Model_Corners_Set2_1-2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Corners_Set2_1-2 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Corners_1 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_TopCorner2-1
{
Call     EnableModel 			( .Model_Corners_Set2_2-1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Corners_Set2_2-1 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Corners_2 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_TopCorner2-2
{
Call     EnableModel 			( .Model_Corners_Set2_2-2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Corners_Set2_2-2 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Corners_2 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_TopCorner3-1
{
Call     EnableModel 			( .Model_Corners_Set2_3-1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Corners_Set2_3-1 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Corners_3 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_TopCorner3-2
{
Call     EnableModel 			( .Model_Corners_Set2_3-2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Corners_Set2_3-2 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Corners_3 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_TopCorner4-1
{
Call     EnableModel 			( .Model_Corners_Set2_4-1 .True )
Call     ModifyColliderFlags 	( .True .Collider_Corners_Set2_4-1 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Corners_4 .True
Return
End
}

#new:Script:Map $Script_Rogue_Load_TopCorner4-2
{
Call     EnableModel 			( .Model_Corners_Set2_4-2 .True )
Call     ModifyColliderFlags 	( .True .Collider_Corners_Set2_4-2 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Corners_4 .True
Return
End
}

%%%%%% Load Pillars
% Up
#new:Script:Map $Script_Rogue_Load_PillarUp_001
{
Call    EnableModel 		( .Model_Pillars_Up_001 .True )
Call    ModifyColliderFlags ( .True .Collider_Pillars_Up_001 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_Load_PillarUp_010
{
Call    EnableModel 		( .Model_Pillars_Up_010 .True )
Call    ModifyColliderFlags ( .True .Collider_Pillars_Up_010 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_Load_PillarUp_100
{
Call    EnableModel 		( .Model_Pillars_Up_100 .True )
Call    ModifyColliderFlags ( .True .Collider_Pillars_Up_100 7FFFFE00 )
Return
End
}

% Down
#new:Script:Map $Script_Rogue_Load_PillarDown_001
{
Call    EnableModel 		( .Model_Pillars_Down_001 .True )
Call    ModifyColliderFlags ( .True .Collider_Pillars_Down_001 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_Load_PillarDown_010
{
Call    EnableModel 		( .Model_Pillars_Down_010 .True )
Call    ModifyColliderFlags ( .True .Collider_Pillars_Down_010 7FFFFE00 )
Return
End
}

#new:Script:Map $Script_Rogue_Load_PillarDown_100
{
Call    EnableModel 		( .Model_Pillars_Down_100 .True )
Call    ModifyColliderFlags ( .True .Collider_Pillars_Down_100 7FFFFE00 )
Return
End
}

%%%%%% Load Floors
#new:Script:Map $Script_Rogue_LoadFloor_Up
{
Call     EnableModel 			( .Model_Floors_Up .True )
Call     ModifyColliderFlags 	( .True .Collider_Floors_Up 7FFFFE00 )
Call     ModifyColliderFlags 	( .True .Collider_Walls_Up 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Floors_Up .True
Set     .Rogue_Flag_Geometry_Floors_Horizontal .True
Return
End
}

#new:Script:Map $Script_Rogue_LoadFloor_Right
{
Call     EnableModel 			( .Model_Floors_Right .True )
Call     ModifyColliderFlags 	( .True .Collider_Floors_Right 7FFFFE00 )
Call     ModifyColliderFlags 	( .True .Collider_Walls_Right 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Floors_Right .True
Set     .Rogue_Flag_Geometry_Floors_Vertical .True
Return
End
}

#new:Script:Map $Script_Rogue_LoadFloor_Down
{
Call     EnableModel 			( .Model_Floors_Down .True )
Call     ModifyColliderFlags 	( .True .Collider_Floors_Down 7FFFFE00 )
Call     ModifyColliderFlags 	( .True .Collider_Walls_Down 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Floors_Down .True
Set     .Rogue_Flag_Geometry_Floors_Horizontal .True
Return
End
}

#new:Script:Map $Script_Rogue_LoadFloor_Left
{
Call     EnableModel 			( .Model_Floors_Left .True )
Call     ModifyColliderFlags 	( .True .Collider_Floors_Left 7FFFFE00 )
Call     ModifyColliderFlags 	( .True .Collider_Walls_Left 7FFFFE00 )
Set     .Rogue_Flag_Geometry_Floors_Left .True
Set     .Rogue_Flag_Geometry_Floors_Vertical .True
Return
End
}

%%% Load Geometry for Springs
% Reward Yaw %
%% Springs always use a .Down yaw, is the default one so isn't neccesary to add anything here
#new:Script:Map $Script_Rogue_LoadFloors_Springs
{
Switch  .Rogue_SpawnPoint
    Case == 1 % Top Left
        ExecWait $Script_Rogue_Load_TopCorner1-1
        ExecWait $Script_Rogue_Load_TopCorner1-2
        % Set Reward Spawn point
        If .Rogue_SpawnAmount == .2Things2Traps
            Set .Rogue_Item_2 1
        Else
            Set .Rogue_Item_1 1
        EndIf
    Case == 2 % Top Right
        ExecWait $Script_Rogue_Load_TopCorner2-1
        ExecWait $Script_Rogue_Load_TopCorner2-2
        % Set Reward Spawn point
        If .Rogue_SpawnAmount == .2Things2Traps
            Set .Rogue_Item_2 2
        Else
            Set .Rogue_Item_1 2
        EndIf
    Case == 3 % Bottom Right
        ExecWait $Script_Rogue_Load_TopCorner3-1
        ExecWait $Script_Rogue_Load_TopCorner3-2
        % Set Reward Spawn point
        If .Rogue_SpawnAmount == .2Things2Traps
            Set .Rogue_Item_2 3
        Else
            Set .Rogue_Item_1 3
        EndIf
    Case == 4 % Bottom Left
        ExecWait $Script_Rogue_Load_TopCorner4-1
        ExecWait $Script_Rogue_Load_TopCorner4-2
        % Set Reward Spawn point
        If .Rogue_SpawnAmount == .2Things2Traps
            Set .Rogue_Item_2 4
        Else
            Set .Rogue_Item_1 4
        EndIf
EndSwitch
Return
End
}

%%% Load the Geometry used when a Pillar is active
#new:Script:Map $Script_Rogue_LoadFloors_Pillars
{
Set     .Rogue_Flag_Geometry_Floors_Horizontal .True
Switch  .Rogue_SpawnPoint
    Case == 1 % Top Left
        % Spawn corner and stair
        ExecWait $Script_Rogue_LoadCorner1
        ExecWait $Script_Rogue_Load_Stairs1_1-1
        Set .Rogue_SpawnSide 0
        % Load Pillars
        Switch .Rogue_ID
            CaseOR == 4 % Switch - Kooper 1
            CaseOR == 6 % Grab Item - Kooper Only
                ExecWait $Script_Rogue_Load_PillarUp_010
                If .Rogue_SpawnAmount == .2Things2Traps
                    If .Rogue_ID == 4
                        Set .Rogue_Item_2 0
                    Else
                        Set .Rogue_Item_2 0100
                    EndIf
                Else
                    If .Rogue_ID == 4
                        Set .Rogue_Item_1 0
                    Else
                        Set .Rogue_Item_1 0100
                    EndIf
                EndIf
            EndCaseGroup
            CaseOR == 5 % Switch - Kooper 2
            CaseOR == 7 % Grab Item - Kooper and Parakarry
                ExecWait $Script_Rogue_Load_PillarUp_100
                If .Rogue_SpawnAmount == .2Things2Traps
                    If .Rogue_ID == 5
                        Set .Rogue_Item_2 0
                    Else
                        Set .Rogue_Item_2 1000
                    EndIf
                Else
                    If .Rogue_ID == 5
                        Set .Rogue_Item_1 0
                    Else
                        Set .Rogue_Item_1 1000
                    EndIf
                EndIf
            Case == 10` % Gaps - Parakarry
                ExecWait $Script_Rogue_Load_PillarUp_100
                ExecWait $Script_Rogue_Load_PillarUp_001
            EndCaseGroup
        EndSwitch
        Set  .Rogue_Flag_Geometry_Floors_Up .True
        If .Rogue_ID == 10` % Gaps - Parakarry
            % Last Corner
            ExecWait $Script_Rogue_LoadCorner2
            % Set Reward Spawn point
            If .Rogue_SpawnAmount == .2Things2Traps
                Set .Rogue_Item_2 2
                Call $Function_WriteRewardYaw ( 1 .Left )
            Else
                Set .Rogue_Item_1 2
                Call $Function_WriteRewardYaw ( 0 .Left )
            EndIf
        EndIf
    Case == 2 % Top Right
        % Spawn corner and stair
        ExecWait $Script_Rogue_LoadCorner2
        ExecWait $Script_Rogue_Load_Stairs1_2-1
        Set .Rogue_SpawnSide 0
        % Load Pillars
        Switch .Rogue_ID
            CaseOR == 4 % Switch - Kooper 1
            CaseOR == 6 % Grab Item - Kooper Only
                ExecWait $Script_Rogue_Load_PillarUp_010
                If .Rogue_SpawnAmount == .2Things2Traps
                    If .Rogue_ID == 4
                        Set .Rogue_Item_2 0
                    Else
                        Set .Rogue_Item_2 0100
                    EndIf
                Else
                    If .Rogue_ID == 4
                        Set .Rogue_Item_1 0
                    Else
                        Set .Rogue_Item_1 0100
                    EndIf
                EndIf
            EndCaseGroup
            CaseOR == 5 % Switch - Kooper 2
            CaseOR == 7 % Grab Item - Kooper and Parakarry
                ExecWait $Script_Rogue_Load_PillarUp_001
                If .Rogue_SpawnAmount == .2Things2Traps
                    If .Rogue_ID == 5
                        Set .Rogue_Item_2 0
                    Else
                        Set .Rogue_Item_2 0010
                    EndIf
                Else
                    If .Rogue_ID == 5
                        Set .Rogue_Item_1 0
                    Else
                        Set .Rogue_Item_1 0010
                    EndIf
                EndIf
            Case == 10` % Gaps - Parakarry
                ExecWait $Script_Rogue_Load_PillarUp_100
                ExecWait $Script_Rogue_Load_PillarUp_001
            EndCaseGroup
        EndSwitch
        Set  .Rogue_Flag_Geometry_Floors_Up .True
        % Last Corner
        If .Rogue_ID == 10` % Gaps - Parakarry
            % Last Corner
            ExecWait $Script_Rogue_LoadCorner1
            % Set Reward Spawn point
            If .Rogue_SpawnAmount == .2Things2Traps
                Set .Rogue_Item_2 1
                Call $Function_WriteRewardYaw ( 1 .Right )
            Else
                Set .Rogue_Item_1 1
                Call $Function_WriteRewardYaw ( 0 .Right )
            EndIf
        EndIf
    Case == 3 % Bottom Right
        % Spawn corner and stair
        ExecWait $Script_Rogue_LoadCorner3
        ExecWait $Script_Rogue_Load_Stairs1_3-1
        Set .Rogue_SpawnSide 0
        % Load Pillars
        Switch .Rogue_ID
            CaseOR == 4 % Switch - Kooper 1
            CaseOR == 6 % Grab Item - Kooper Only
                ExecWait $Script_Rogue_Load_PillarDown_010
                If .Rogue_SpawnAmount == .2Things2Traps
                    If .Rogue_ID == 4
                        Set .Rogue_Item_2 0
                    Else
                        Set .Rogue_Item_2 0101
                    EndIf
                Else
                    If .Rogue_ID == 4
                        Set .Rogue_Item_1 0
                    Else
                        Set .Rogue_Item_1 0101
                    EndIf
                EndIf
            EndCaseGroup
            CaseOR == 5 % Switch - Kooper 2
            CaseOR == 7 % Grab Item - Kooper and Parakarry
                ExecWait $Script_Rogue_Load_PillarDown_001
                If .Rogue_SpawnAmount == .2Things2Traps
                    If .Rogue_ID == 5
                        Set .Rogue_Item_2 0
                    Else
                        Set .Rogue_Item_2 0011
                    EndIf
                Else
                    If .Rogue_ID == 5
                        Set .Rogue_Item_1 0
                    Else
                        Set .Rogue_Item_1 0011
                    EndIf
                EndIf
            Case == 10` % Gaps - Parakarry
                ExecWait $Script_Rogue_Load_PillarDown_100
                ExecWait $Script_Rogue_Load_PillarDown_001
            EndCaseGroup
        EndSwitch
        Set  .Rogue_Flag_Geometry_Floors_Down .True
        % Last Corner
        If .Rogue_ID == 10` % Gaps - Parakarry
            % Last Corner
            ExecWait $Script_Rogue_LoadCorner4
            % Set Reward Spawn point
            If .Rogue_SpawnAmount == .2Things2Traps
                Set .Rogue_Item_2 4
                Call $Function_WriteRewardYaw ( 1 .Right )
            Else
                Set .Rogue_Item_1 4
                Call $Function_WriteRewardYaw ( 0 .Right )
            EndIf
        EndIf
    Case == 4 % Bottom Left
        % Spawn corner and stair
        ExecWait $Script_Rogue_LoadCorner4
        ExecWait $Script_Rogue_Load_Stairs1_4-1
        Set .Rogue_SpawnSide 0
        % Load Pillars
        Switch .Rogue_ID
            CaseOR == 4 % Switch - Kooper 1
            CaseOR == 6 % Grab Item - Kooper Only
                ExecWait $Script_Rogue_Load_PillarDown_010
                If .Rogue_SpawnAmount == .2Things2Traps
                    If .Rogue_ID == 4
                        Set .Rogue_Item_2 0
                    Else
                        Set .Rogue_Item_2 0101
                    EndIf
                Else
                    If .Rogue_ID == 4
                        Set .Rogue_Item_1 0
                    Else
                        Set .Rogue_Item_1 0101
                    EndIf
                EndIf
            EndCaseGroup
            CaseOR == 5 % Switch - Kooper 2
            CaseOR == 7 % Grab Item - Kooper and Parakarry
                ExecWait $Script_Rogue_Load_PillarDown_100
                If .Rogue_SpawnAmount == .2Things2Traps
                    If .Rogue_ID == 5
                        Set .Rogue_Item_2 0
                    Else
                        Set .Rogue_Item_2 1001
                    EndIf
                Else
                    If .Rogue_ID == 5
                        Set .Rogue_Item_1 0
                    Else
                        Set .Rogue_Item_1 1001
                    EndIf
                EndIf
            Case == 10` % Gaps - Parakarry
                ExecWait $Script_Rogue_Load_PillarDown_100
                ExecWait $Script_Rogue_Load_PillarDown_001
            EndCaseGroup
        EndSwitch
        Set  .Rogue_Flag_Geometry_Floors_Down .True
        % Last Corner
        If .Rogue_ID == 10` % Gaps - Parakarry
            % Last Corner
            ExecWait $Script_Rogue_LoadCorner3
            % Set Reward Spawn point
            If .Rogue_SpawnAmount == .2Things2Traps
                Set .Rogue_Item_2 3
                Call $Function_WriteRewardYaw ( 1 .Left )
            Else
                Set .Rogue_Item_1 3
                Call $Function_WriteRewardYaw ( 0 .Left )
            EndIf
        EndIf
EndSwitch
Return
End
}

% Entities Scripts
#new:Script:Map $Script_Null % Used for entities who need an script assigned
{
Return
End
}

% Traps Code - Start
% Springs
#new:Script:Map $Script_UseSpring
{
    Call     DisablePlayerInput 	( .True )
    Call     DisablePlayerPhysics 	( .True )
    Call     SetPlayerActionState ( 6 )
    Wait     2 
    Call     GetPlayerPos 	( *Var[7] *Var[8] *Var[9] )
    Exec     $Script_UpdateCamera *Var[A] 
    Call     SetPlayerJumpscale 	( *Fixed[0.7001953] )
    % Set Player jump by reading his position
    Call     GetPlayerPos 	( *Var[A] .False *Var[C] )
    % Mario is on the left side of the room?
    If  *Var[A] < -534`
        If *Var[C] < 43` % 1 % Top Left
            Call     PlayerJump  	( -724` 93` -45` 30` ) % xyz height
        Else % 4 % Bottom Left
            Call     PlayerJump  	( -724` 93` 143` 30` ) % xyz height
        EndIf
    EndIf
    % Mario is on the right side of the room?
    If  *Var[A] > -534`
        If *Var[C] < 43` % 2 % Top Right
            Call     PlayerJump  	( -342` 93` -45` 30` ) % xyz height
        Else % 3 % Bottom Right
            Call     PlayerJump  	( -342` 93` 143` 30` ) % xyz height
        EndIf
    EndIf
    Call     SetPlayerActionState ( 0 )
    Call     DisablePlayerPhysics 	( .False )
    Call     DisablePlayerInput 	( .False )
    Return
    End
}

#new:Script:Map $Script_UpdateCamera
{
    Label    .Default
    Call     GetPlayerPos 	( *Var[0] *Var[1] *Var[2] )
    Call     SetCamTarget ( 0 *Var[0] *Var[1] *Var[2] )
    Wait     1 
    Goto     .Default
    Return
    End
}

#new:Script:Map $Script_Springs_EnableTopCollider
{
    Switch .Rogue_SpawnPoint
        Case == 1 % Top Left
            Call    ModifyColliderFlags ( .True .Collider_Spring_Top_1 7FFFFE00 )
        Case == 2 % Top Right
            Call    ModifyColliderFlags ( .True .Collider_Spring_Top_2 7FFFFE00 )
        Case == 3 % Bottom Right
            Call    ModifyColliderFlags ( .True .Collider_Spring_Top_3 7FFFFE00 )
        Case == 4 % Bottom Left
            Call    ModifyColliderFlags ( .True .Collider_Spring_Top_4 7FFFFE00 )
    EndSwitch
    Return
    End
}

% Spawn the reward from switches traps
#new:Script:Map $Script_Reward_Spawn_Switches_TrapID3
{
 % to known what SwitchVar have this trap ID
Set *Var[2] 3 % ? Switch - Ultra Boots
ExecWait $Script_Reward_Switches_MakeItemPickable
Return
End
}

#new:Script:Map $Script_Reward_Spawn_Switches_TrapID4
{
 % to known what SwitchVar have this trap ID
Set *Var[2] 4 % Switch - Kooper 1
ExecWait $Script_Reward_Switches_MakeItemPickable
Return
End
}

#new:Script:Map $Script_Reward_Spawn_Switches_TrapID5
{
 % to known what SwitchVar have this trap ID
Set *Var[2] 5 % Switch - Kooper 2
ExecWait $Script_Reward_Switches_MakeItemPickable
Return
End
}

#new:Script:Map $Script_Reward_Switches_MakeItemPickable
{
/% Testing
Call    SetItemPos ( 0 -579` -12` 33` )
Return
%/
% Var[B]=Trap ID
Call    $Function_Reward_GetData1
If *Var[B] == *Var[2]
    % Var[0]=ItemPos
    % Var[1]=ItemIndex
    Call    $Function_Reward_GetSwich_Var1
    If  *Var[0] == 7
         % if this item has been already spawned use data2 instead
         % used just when there are two switch traps with the same
         % kind of ID.
        Wait 1
        Goto Data2
    EndIf
    Set     *Var[3] 1 % to know what data was used
Else
    % Use data 2 instead
    Label   Data2
    Call    $Function_Reward_GetSwich_Var2
    Set     *Var[3] 2 % to know what data was used
EndIf
% Make the Item Visible
Switch *Var[0]
    Case == 5
        Call    PlaySound  ( .Sound:SmokeBurst )
        Call    PlayEffect ( ~FX:BigSmokePuff -579` -6` 63` ) % xyz
        Call    SetItemPos ( *Var[1] -579` -12` 60` )
    Case == 6
        Call    PlaySound  ( .Sound:SmokeBurst )
        Call    PlayEffect ( ~FX:BigSmokePuff -492` -6` 63` ) % xyz
        Call    SetItemPos ( *Var[1] -492` -12` 60` )
EndSwitch
% Set Switch Item data as already spawned, set pos to 7
Switch *Var[3]
    Case == 1
        Call    $Function_Reward_Swich_LockVar1
    Case == 2
        Call    $Function_Reward_Swich_LockVar2
EndSwitch
Return
End
}

#new:Function $Function_Reward_Swich_LockVar1
{
ADDIU   T0, R0, 7 % Item can be grabbed
SAH     T0, $Entity_Switch_Var1
JR      RA
NOP
}

#new:Function $Function_Reward_Swich_LockVar2
{
ADDIU   T0, R0, 7 % Item can be grabbed
SAH     T0, $Entity_Switch_Var2
JR      RA
NOP
}

#new:Function $Function_Reward_GetSwich_Var1
{
PUSH	RA, V0, A1, A2
LIO     T0, $Entity_Switch_Var1
LBU     A2, 1 (T0) % ItemPos
LIO 	A1, *Var[0]
JAL 	~Func:set_variable
RESERVED
LIO     T0, $Entity_Switch_Var1
LHU     A2, 2 (T0) % ItemIndex
LIO 	A1, *Var[1]
JAL 	~Func:set_variable
RESERVED
JPOP	RA, V0, A1, A2
}

#new:Function $Function_Reward_GetSwich_Var2
{
PUSH	RA, V0, A1, A2
LIO     T0, $Entity_Switch_Var2
LBU     A2, 1 (T0) % ItemPos
LIO 	A1, *Var[0]
JAL 	~Func:set_variable
RESERVED
LIO     T0, $Entity_Switch_Var2
LHU     A2, 2 (T0) % ItemIndex
LIO 	A1, *Var[1]
JAL 	~Func:set_variable
RESERVED
JPOP	RA, V0, A1, A2
}

%% XXXXYYZZ
% XXXX=Reward Spawn Point
% YY=Trap ID
#new:Function $Function_Reward_GetSwitchVarToUse
{
PUSH	RA, V0, A1, A2, S0, S1, S2, S3
LIO 	A1, *Var[A] % Reward Spawn Position
JAL 	~Func:get_variable 
RESERVED
COPY    S0, V0
LIO 	A1, *Var[B] % Trap ID
JAL 	~Func:get_variable 
RESERVED
COPY    S1, V0
SLL     S0, S0, 8 % leave space for the trap ID
OR      S0, S0, S1 % Get XXXXYY / xxxx=spawn pos , yy=trapID
% Load ItemPos
LIO 	A1, *Var[3] % ItemPos
JAL 	~Func:get_variable 
RESERVED
COPY    S3, V0
% Load ItemIndex in v0
LIO 	A1, *Var[0] % ItemIndexID
JAL 	~Func:get_variable 
RESERVED
% Check if Data1 is the correct one to use
LAW     S2, $Data_Reward_Data1
SRL     S2, S2, 8 % don't read the rarity points
BNE     S0, S2, .UseData2
NOP
% save the handle in Data1
LIO     T0, $Entity_Switch_Var1
SB      S3, 1 (T0)
SH      V0, 2 (T0)
BEQ     R0, R0, .End
NOP
.UseData2
% If wasn't data1, just use data2
% save the handle in Data2
LIO     T0, $Entity_Switch_Var2
SB      S3, 1 (T0)
SH      V0, 2 (T0)
.End
JPOP    RA, V0, A1, A2, S0, S1, S2, S3
}

% Set Spawn position for the entities
#new:Script:Map $Script_Rogue_Entities_SetSpawn
{
ExecWait    $Script_Rogue_CheckFlags_Entities % check entity to use now
% Load SpawnPoint
Switch .Rogue_ID
    CaseOR == 0 % Super Blocks
    CaseOR == 1 % Ultra Blocks
    CaseOR == 8 % Rocks - Bombette
        ExecWait    $Script_Rogue_Entities_LoadVectorList_MiddleFloor
    EndCaseGroup
    Case == 3 % ? Switch - Ultra Boots
        ExecWait    $Script_Rogue_Entities_LoadVectorList_Block2
    Case == 4 % Switch - Kooper 1
        ExecWait    $Script_Rogue_Entities_LoadVectorList_MiddleFloor0X0 % just for this ID
    Case == 5 % Switch - Kooper 2
        Set .Rogue_SpawnSide 0
        ExecWait    $Script_Rogue_Entities_LoadVectorList_MiddleFloorX0X % just for this ID
EndSwitch
% Set Coordinates
ExecWait $Script_Rogue_SetEntityPos
Return
End
}

#new:Script:Map $Script_Rogue_Entities_SetSpawn_SuperBlock
{
Call $Function_Reward_GetDataX
ExecWait    $Script_Rogue_CheckFlags_Entities % check entity to use now
% Load SpawnPoint
Switch *Var[B] % trap ID
    CaseOR == 2
    CaseOR == 12`
    CaseOR == 14`
    CaseOR == 16`
    CaseOR == 17`
    CaseOR == 18`
    CaseOR == 20`
    CaseOR == 21`
        Switch  *Var[A] % Reward Spawn Point
            Case == 1 % Upper Left
                Set *Var[4] $VectorList_Entity_Block_Set2_1
	        Case == 2 % Upper Right
    		    Set *Var[4] $VectorList_Entity_Block_Set2_2
	        Case == 3 % Bottom Right
    		    Set *Var[4] $VectorList_Entity_Block_Set2_3
	        Case == 4 % Bottom Left
		        Set *Var[4] $VectorList_Entity_Block_Set2_4
        EndSwitch
    EndCaseGroup
    Default
        Switch  *Var[A] % Reward Spawn Point
            Case == 1 % Upper Left
                Set *Var[4] $VectorList_Entity_Block_Set1_1
            Case == 2 % Upper Right
                Set *Var[4] $VectorList_Entity_Block_Set1_2
            Case == 3 % Bottom Right
                Set *Var[4] $VectorList_Entity_Block_Set1_3
            Case == 4 % Bottom Left
                Set *Var[4] $VectorList_Entity_Block_Set1_4
        EndSwitch
EndSwitch
% Set Coordinates
ExecWait $Script_Rogue_SetEntityPos
Return
End
}

#new:Script:Map $Script_Rogue_Entities_SetSpawn_Chests
{
Call $Function_Reward_GetDataX
ExecWait    $Script_Rogue_CheckFlags_Entities % check entity to use now
% Load SpawnPoint
Switch *Var[B] % trap ID
    CaseOR == 2
    CaseOR == 12`
    CaseOR == 14`
    CaseOR == 16`
    CaseOR == 17`
    CaseOR == 18`
    CaseOR == 20`
    CaseOR == 21`
        Switch  *Var[A] % Reward Spawn Point
            Case == 1 % Upper Left
                Set *Var[4] $VectorList_Entity_Spawn_Corners_Set2_1
	        Case == 2 % Upper Right
    		    Set *Var[4] $VectorList_Entity_Spawn_Corners_Set2_2
	        Case == 3 % Bottom Right
    		    Set *Var[4] $VectorList_Entity_Spawn_Corners_Set2_3
	        Case == 4 % Bottom Left
		        Set *Var[4] $VectorList_Entity_Spawn_Corners_Set2_4
        EndSwitch
    EndCaseGroup
    Default
        Switch  *Var[A] % Reward Spawn Point
            Case == 1 % Upper Left
                Set *Var[4] $VectorList_Entity_Spawn_Corners_Set1_1
            Case == 2 % Upper Right
                Set *Var[4] $VectorList_Entity_Spawn_Corners_Set1_2
            Case == 3 % Bottom Right
                Set *Var[4] $VectorList_Entity_Spawn_Corners_Set1_3
            Case == 4 % Bottom Left
                Set *Var[4] $VectorList_Entity_Spawn_Corners_Set1_4
        EndSwitch
EndSwitch
% Set Coordinates
ExecWait $Script_Rogue_SetEntityPos
Return
End
}

#new:Script:Map $Script_Rogue_Entities_LoadVectorList_MiddleFloor
{
Switch .Rogue_SpawnPoint
    Case == 1 % Upper Left
        % Check stairs side
        If .Rogue_SpawnSide == 0 % v
            Set *Var[4] $VectorList_Entity_Spawn_Middle_Up_010
        Else % <
            Set *Var[4] $VectorList_Entity_Spawn_Middle_Left_010
        EndIf
	Case == 2 % Upper Right
		% Check stairs side
        If .Rogue_SpawnSide == 0 % v
            Set *Var[4] $VectorList_Entity_Spawn_Middle_Up_010
        Else % <
            Set *Var[4] $VectorList_Entity_Spawn_Middle_Right_010
        EndIf
	Case == 3 % Bottom Right
		% Check stairs side
        If .Rogue_SpawnSide == 0 % v
            Set *Var[4] $VectorList_Entity_Spawn_Middle_Down_010
        Else % <
            Set *Var[4] $VectorList_Entity_Spawn_Middle_Right_010
        EndIf
	Case == 4 % Bottom Left
		% Check stairs side
        If .Rogue_SpawnSide == 0 % v
            Set *Var[4] $VectorList_Entity_Spawn_Middle_Down_010
        Else % <
            Set *Var[4] $VectorList_Entity_Spawn_Middle_Left_010
        EndIf
EndSwitch
Return
End
}

% Just for Trap ID 4
#new:Script:Map $Script_Rogue_Entities_LoadVectorList_MiddleFloor0X0
{
Switch .Rogue_SpawnPoint
    CaseOR == 1 % Upper Left
    CaseOR == 2 % Upper Right
        Set *Var[4] $VectorList_Entity_Spawn_Middle_Up_Switch_010
        Set *Var[4] $VectorList_Entity_Spawn_Middle_Up_Switch_010
    EndCaseGroup
    CaseOR == 3 % Bottom Right
    CaseOR == 4 % Bottom Left
        Set *Var[4] $VectorList_Entity_Spawn_Middle_Down_Switch_010
        Set *Var[4] $VectorList_Entity_Spawn_Middle_Down_Switch_010
    EndCaseGroup
EndSwitch
Return
End
}

% Just for Trap ID 5
#new:Script:Map $Script_Rogue_Entities_LoadVectorList_MiddleFloorX0X
{
Switch .Rogue_SpawnPoint
    Case == 1 % Upper Left
        Set *Var[4] $VectorList_Entity_Spawn_Middle_Up_100
	Case == 2 % Upper Right
        Set *Var[4] $VectorList_Entity_Spawn_Middle_Up_001
	Case == 3 % Bottom Right
        Set *Var[4] $VectorList_Entity_Spawn_Middle_Down_001
	Case == 4 % Bottom Left
        Set *Var[4] $VectorList_Entity_Spawn_Middle_Down_100
EndSwitch
Return
End
}

% Set Entity position in the bottom corners
#new:Script:Map $Script_Rogue_Entities_LoadVectorList_Corners1
{
Switch *Var[A]
    Case == 1 % Upper Left
        Set *Var[4] $VectorList_Entity_Spawn_Corners_Set1_1
	Case == 2 % Upper Right
		Set *Var[4] $VectorList_Entity_Spawn_Corners_Set1_2
	Case == 3 % Bottom Right
		Set *Var[4] $VectorList_Entity_Spawn_Corners_Set1_3
	Case == 4 % Bottom Left
		Set *Var[4] $VectorList_Entity_Spawn_Corners_Set1_4
EndSwitch
Return
End
}

% Set Locks Position for the Springs
#new:Script:Map $Script_Rogue_Entities_LoadVectorList_Lockpads
{
Switch .Rogue_SpawnPoint
    Case == 1 % Upper Left
        Set *Var[4] $VectorList_Entity_Lock_Spring_1
    Case == 2 % Upper Right
		Set *Var[4] $VectorList_Entity_Lock_Spring_2
    Case == 3 % Bottom Right
		Set *Var[4] $VectorList_Entity_Lock_Spring_3
    Case == 4 % Bottom Left
		Set *Var[4] $VectorList_Entity_Lock_Spring_4
EndSwitch
Return
End
}

% Set Block Positions - High 2
#new:Script:Map $Script_Rogue_Entities_LoadVectorList_Block2
{
Switch .Rogue_SpawnPoint
    Case == 1 % Upper Left
        Set *Var[4] $VectorList_Entity_Block_Set2_1
	Case == 2 % Upper Right
		Set *Var[4] $VectorList_Entity_Block_Set2_2
	Case == 3 % Bottom Right
		Set *Var[4] $VectorList_Entity_Block_Set2_3
	Case == 4 % Bottom Left
		Set *Var[4] $VectorList_Entity_Block_Set2_4
EndSwitch
Return
End
}

% Spawn Springs and all his stuff (padlocks, enemies, and other entities)
#new:Script:Map $Script_Rogue_Entities_SpawnSprings
{
ExecWait    $Script_Rogue_CheckFlags_Entities % check entity to use now
% Load Spring Spawning Coordinates
Switch .Rogue_SpawnPoint
    Case == 1 % Top Left
        Set *Var[4] $VectorList_Entity_Spring1
    Case == 2 % Top Right
        Set *Var[4] $VectorList_Entity_Spring2
    Case == 3 % Bottom Right
        Set *Var[4] $VectorList_Entity_Spring3
    Case == 4 % Bottom Left
        Set *Var[4] $VectorList_Entity_Spring4
EndSwitch
% Set Coordinates
ExecWait $Script_Rogue_SetEntityPos
Switch .Rogue_ID
    Case == 2 % Super/Ultra Boots Spring
        ExecWait $Script_Springs_EnableTopCollider
        Switch .Rogue_SpawnPoint
            Case == 1 % Top Left
                Call    EnableModel 	    ( .Model_Boots_1 .True )
                Bind    $Script_Track_GroundPound .Trigger:FloorTouch .Collider_Spring_Top_1 00000001 00000000
            Case == 2 % Top Right
                Call    EnableModel 	    ( .Model_Boots_2 .True )
                Bind    $Script_Track_GroundPound .Trigger:FloorTouch .Collider_Spring_Top_2 00000001 00000000
            Case == 3 % Bottom Right
                Call    EnableModel 	    ( .Model_Boots_3 .True )
                Bind    $Script_Track_GroundPound .Trigger:FloorTouch .Collider_Spring_Top_3 00000001 00000000
            Case == 4 % Bottom Left
                Call    EnableModel 	    ( .Model_Boots_4 .True )
                Bind    $Script_Track_GroundPound .Trigger:FloorTouch .Collider_Spring_Top_4 00000001 00000000
        EndSwitch
    Case == 14` % Spring - Goombario Only
        ExecWait $Script_Springs_EnableColliders
        Switch .Rogue_SpawnPoint
            Case == 1 % Top Left
                Call    EnableModel 	    ( .Model_Goombario_1 .True )
                Bind    $Script_Track_Goombario .Trigger:WallPressA .Collider_Spring_Wall_1 00000001 00000000 
            Case == 2 % Top Right
                Call    EnableModel 	    ( .Model_Goombario_2 .True )
                Bind    $Script_Track_Goombario .Trigger:WallPressA .Collider_Spring_Wall_2 00000001 00000000
            Case == 3 % Bottom Right
                Call    EnableModel 	    ( .Model_Goombario_3 .True )
                Bind    $Script_Track_Goombario .Trigger:WallPressA .Collider_Spring_Wall_3 00000001 00000000
            Case == 4 % Bottom Left
                Call    EnableModel 	    ( .Model_Goombario_4 .True )
                Bind    $Script_Track_Goombario .Trigger:WallPressA .Collider_Spring_Wall_4 00000001 00000000
        EndSwitch
    Case == 16` % Spring - Watt Only
        ExecWait $Script_Springs_EnableColliders
        Switch .Rogue_SpawnPoint
            Case == 1 % Top Left
                Call     EnableModel 	    ( .Model_Watt_1 .True )
                Bind     $Script_Track_Watt .Trigger:WallPressA .Collider_Spring_Wall_1 00000001 00000000 
            Case == 2 % Top Right
                Call    EnableModel 	    ( .Model_Watt_2 .True )
                Bind    $Script_Track_Watt .Trigger:WallPressA .Collider_Spring_Wall_2 00000001 00000000
            Case == 3 % Bottom Right
                Call    EnableModel 	    ( .Model_Watt_3 .True )
                Bind    $Script_Track_Watt .Trigger:WallPressA .Collider_Spring_Wall_3 00000001 00000000
            Case == 4 % Bottom Left
                Call    EnableModel 	    ( .Model_Watt_4 .True )
                Bind    $Script_Track_Watt .Trigger:WallPressA .Collider_Spring_Wall_4 00000001 00000000
        EndSwitch
    CaseOR == 17` % Springs - Keys Based
    CaseOR == 20` % Springs - Coins Based
    CaseOR == 21` % Springs - HP Based
        ExecWait $Script_Springs_EnableTopCollider
        ExecWait $Script_Rogue_CheckFlags_Entities % check entity to use now
        Call     $Function_Entity_Lock_SaveEntityID % save ID in entity data
        Set     *Var[A] 00004000 % Var[A] == Entity to Bind in BindLock % 000040XX - XX=EntityID
        Add     *Var[A] *Var[9] % set entity ID
        Switch .Rogue_ID
            Case == 17` % Springs - Keys Based
                BindLock $Script_Padlock_Keys .Trigger:WallPressA *Var[A] $ItemList_ImpossibleItem 00000000 00000001
            Case == 20` % Springs - Coins Based
                BindLock $Script_Padlock_Coins .Trigger:WallPressA *Var[A] $ItemList_ImpossibleItem 00000000 00000001
            Case == 21` % Springs - HP Based
                BindLock $Script_Padlock_HP .Trigger:WallPressA *Var[A] $ItemList_ImpossibleItem 00000000 00000001
        EndSwitch
        % Enable Color Circle, was when a lot of entites got removed to stop a bug
        % at the end of the day got fixed so, I no longer used the color circles.
        /%Switch .Rogue_SpawnPoint
            Case == 1 % Top Left
                Switch .Rogue_ID
                    Case == 17` % Springs - Keys Based
                        Call    EnableModel ( .Model_Color_Blue_1 .True )
                    Case == 20` % Springs - Coins Based
                        Call    EnableModel ( .Model_Color_Yellow_1 .True )
                    Case == 21` % Springs - HP Based
                        Call    EnableModel ( .Model_Color_Red_1 .True )
                EndSwitch
            Case == 2 % Top Right
                Switch .Rogue_ID
                    Case == 17` % Springs - Keys Based
                        Call    EnableModel ( .Model_Color_Blue_2 .True )
                    Case == 20` % Springs - Coins Based
                        Call    EnableModel ( .Model_Color_Yellow_2 .True )
                    Case == 21` % Springs - HP Based
                        Call    EnableModel ( .Model_Color_Red_2 .True )
                EndSwitch
            Case == 3 % Bottom Right
                Switch .Rogue_ID
                    Case == 17` % Springs - Keys Based
                        Call    EnableModel ( .Model_Color_Blue_3 .True )
                    Case == 20` % Springs - Coins Based
                        Call    EnableModel ( .Model_Color_Yellow_3 .True )
                    Case == 21` % Springs - HP Based
                        Call    EnableModel ( .Model_Color_Red_3 .True )
                EndSwitch
            Case == 4 % Bottom Left
                Switch .Rogue_ID
                    Case == 17` % Springs - Keys Based
                        Call    EnableModel ( .Model_Color_Blue_4 .True )
                    Case == 20` % Springs - Coins Based
                        Call    EnableModel ( .Model_Color_Yellow_4 .True )
                    Case == 21` % Springs - HP Based
                        Call    EnableModel ( .Model_Color_Red_4 .True )
                EndSwitch
        EndSwitch%/
        ExecWait $Script_Rogue_Entities_LoadVectorList_Lockpads
        % Set Coordinates
        ExecWait $Script_Rogue_SetEntityPos
    EndCaseGroup
    Case == 18` % Springs - Battle Based
        /% notes -
        Floors 4/9 Koopatropa
        Floor 15 Forest Fuzzy
        Floors 24/29 Bleft 
        Floor 35 Spy Guy
        Floor 45 Jungle Fuzzy
        Floors 54/59 Crazee Dayzee
        Floors 61/66 Lakitu
        Floors 74/79 White Clubba
        Floors 82/87 Hammer Bros
        Floors 93/98 Ember Guy
        %/
        ExecWait $Script_Springs_EnableTopCollider
        ExecWait $Script_SetPos_SpringKeeper
    %Case == 19` % 4 Chests/Springs
    % this ID load everything from $Script_Rogue_4Chests
EndSwitch
Return
End
}

% Used for Lock Based Springs
#new:Function $Function_SaveLockVar
{
PUSH	RA, V0, A1, A2
LIO 	A1, *Var[D]
JAL 	~Func:get_variable 
RESERVED
SAB     V0, $LockVar
JPOP    RA, V0, A1, A2
}

#new:Function $Function_ReadLockVar
{
PUSH	RA, V0, A1, A2
LABU    A2, $LockVar
LIO 	A1, *Var[D]
JAL 	~Func:set_variable
RESERVED
JPOP	RA, V0, A1, A2
}

% Save amount needed to open a lock
#new:Script:Map $Script_SetLockAmount
{
Call    $Function_Entity_Lock_SaveKeyAmount % save amount in next available var
Return
End
}

% Main Script used for this ID
#new:Script:Map $Script_Rogue_4Chests
{
    Call     MakeEntity  	( .Entity:Chest 00000000 00000000 00000000 00000000 00000000 80000000 )
    Call     AssignScript 	( $Script_Reward_Chest_Main )
    Call     MakeEntity  	( .Entity:Chest 00000000 00000000 00000000 00000000 00000000 80000000 )
    Call     AssignScript 	( $Script_Reward_Chest_Main )
    Call     MakeEntity  	( .Entity:Chest 00000000 00000000 00000000 00000000 00000000 80000000 )
    Call     AssignScript 	( $Script_Reward_Chest_Main )
    Call     MakeEntity  	( .Entity:Chest 00000000 00000000 00000000 00000000 00000000 80000000 )
    Call     AssignScript 	( $Script_Reward_Chest_Main )
    Exec     $Script_Rogue_Load_4ChestsCorners1 % load all corners+stairs from set1
    Set     .Rogue_SpawnPoint 1
    % Set Chests Positions
    Loop
        ExecWait    $Script_Rogue_CheckFlags_Entities % check entity to use now
        Set         *Var[A] .Rogue_SpawnPoint
        ExecWait    $Script_Rogue_Entities_LoadVectorList_Corners1
        ExecWait    $Script_Rogue_SetEntityPos
        Wait 1
        Add .Rogue_SpawnPoint 1
        % All positions has been already set?
        If .Rogue_SpawnPoint > 4
            Set .Rogue_SpawnPoint 1
            BreakLoop
        EndIf
    EndLoop
    % Set a cooldown to not spawn the 4 chests again
    Set  *Var[0] 30`
    Call  RandInt ( 10` *Var[1] )
    Add   *Var[0] *Var[1]
    Set   *4Chests_Cooldown *Var[0]
Return
End
}

#new:Script:Map $Script_Rogue_SetEntityPos
{
Call    LoadPath 	( 3 *Var[4] 3 0 ) % time vectorList numVectors ???
Loop
	Call    GetNextPathPos
	Call    $Function_Global_GetPos ( *Var[9] *Var[1] *Var[2] *Var[3] ) % *Var[9] == Entity ID
	Wait 	1
	If  *Var[0]  ==  0
		BreakLoop
	EndIf
EndLoop
Return
End
}

#export $Script_Rogue_SetEntityPos

#new:Function $Function_Global_GetPos
{
    0:  ADDIU		SP, SP, FFC8
    4:  SW			S1, 14 (SP)
    8:  COPY		S1, A0
    C:  SW			RA, 1C (SP)
   10:  SW			S2, 18 (SP)
   14:  SW			S0, 10 (SP)
   18:  SDC1		F24, 30 (SP)
   1C:  SDC1		F22, 28 (SP)
   20:  SDC1		F20, 20 (SP)
   24:  LW			S0, C (S1)
   28:  LW			A1, 0 (S0)
   2C:  JAL			~Func:get_variable
   30:  ADDIU		S0, S0, 4
   34:  LW			A1, 0 (S0)
   38:  ADDIU		S0, S0, 4
   3C:  COPY		A0, S1
   40:  JAL			~Func:get_variable
   44:  COPY		S2, V0
   48:  LW			A1, 0 (S0)
   4C:  ADDIU		S0, S0, 4
   50:  MTC1		V0, F24
   54:  NOP
   58:  CVT.S.W		F24, F24
   5C:  JAL			~Func:get_variable
   60:  COPY		A0, S1
   64:  LW			A1, 0 (S0)
   68:  MTC1		V0, F22
   6C:  NOP
   70:  CVT.S.W		F22, F22
   74:  JAL			~Func:get_variable
   78:  COPY		A0, S1
   7C:  MTC1		V0, F20
   80:  NOP
   84:  CVT.S.W		F20, F20
   88:  JAL			~Func:get_entity_by_index
   8C:  COPY		A0, S2
   90:  COPY		V1, V0
   94:  SWC1		F24, 48 (V1)
   98:  SWC1		F22, 4C (V1)
   9C:  SWC1		F20, 50 (V1)
   A0:  LW			RA, 1C (SP)
   A4:  LW			S2, 18 (SP)
   A8:  LW			S1, 14 (SP)
   AC:  LW			S0, 10 (SP)
   B0:  LDC1		F24, 30 (SP)
   B4:  LDC1		F22, 28 (SP)
   B8:  LDC1		F20, 20 (SP)
   BC:  ADDIU		V0, R0, 2
   C0:  JR			RA
   C4:  ADDIU		SP, SP, 38
}

#new:Script:Map $Script_SetSignPos
{
Call	TranslateModel	        ( .Model_Sign 23` -18` 63` ) % ModelID XYZ Offset
Call    ParentColliderToModel 	( .Collider_Sign .Model_Sign ) % ColliderID ModelID
Return
End
}

#new:Script:Map $Script_Padlock_Keys
{
    % Get amount needed for this lock
    ExecWait $Script_Locks_GetAmount % save amount in var8
    Set *Var[7] 1 % Padlock ID - 1 = Key
    Set *Var[A] *Rogue_Keys
    ExecWait $Script_CheckPadlock
    Return
    End
}

#new:Script:Map $Script_Padlock_Coins
{
    % Get amount needed for this lock
    ExecWait $Script_Locks_GetAmount % save amount in var8
    Set *Var[7] 2 % Padlock ID - 2 = Coins
    Call $Function_GetMarioCoins ( *Var[A] ) % output
    ExecWait $Script_CheckPadlock
    Return
    End
}

#new:Script:Map $Script_Padlock_HP
{
    % Get amount needed for this lock
    ExecWait $Script_Locks_GetAmount % save amount in var8
    Set *Var[7] 3 % Padlock ID - 3 = HP
    ExecWait $Script_CheckPadlock
    Return
    End
}

#new:Script:Map $Script_CheckPadlock
{
    /%
    Var7 = LockID
    Var8 = Amount to open the padlock
    Var9 = StringID
    VarA = Mario's keys/coins/hp
    %/
    SetGroup    .Default
    SuspendAll  .True
    If *Var[8] == 0 % sometimes this can happen a lock asking for Zero something, set the value as 1 instead
        % I know isn't the most appropriate fix but I will check this later.
        Set *Var[8] 1
    EndIf
    Call    DisablePlayerInput ( .True )
    Call    SetMessageValue ( *Var[8] 0 )
    Switch *Var[7]
        Case == 1 % keys
            % Check if is a single key
            If *Var[8] == 1
                Set *Var[9] $MessageString_key
            Else
                Set *Var[9] $MessageString_keys
            EndIf
        Case == 2 % coins
            Set *Var[9] $MessageString_coins
        Case == 3 % hp
            Wait 1
            Goto HPLock_Start
    EndSwitch
    Call    SetMessageString ( *Var[9] 1 )
    Call    ShowMessageAtScreenPos 	( $String_Lockamount A0 28 )
    % False
    If  *Var[A]  <  *Var[8]
        Call    ShowMessageAtScreenPos 	( 001D00D8 A0 28 ) % It's locked! You can't open it.
        ResumeAll .True
        Call    DisablePlayerInput ( .False )
		Return
    EndIf
    % is a hp padlock?
    Label HPLock_Start
    If  *Var[7] == 3 % Hp lock
        If  *Flag_Rogue_1stTime_HPLock == .False
            Call    ShowMessageAtScreenPos ( $String_HPLockamount A0 28 )
            Call    ShowChoice  ( 001E001D ) % yes no
            Call    802D0A98 % close message box
            If  *Var[0] == 1 % no
                ResumeAll .True
                Call    DisablePlayerInput ( .False )
                Return
            EndIf
        EndIf
    Else
        Call    ShowMessageAtScreenPos ( $String_LockConfirmation A0 28 )
        Call    ShowChoice  ( 001E001D ) % yes no
        Call    802D0A98 % close message box
        If  *Var[0] == 1 % no
            ResumeAll .True
            Call    DisablePlayerInput ( .False )
            Return
        EndIf
    EndIf
    % substract
    Switch  *Var[7]
        Case == 1 % Key lock
            Call    $ShowStatusBar
            Wait    10`
            Loop *Var[8]
                Sub     *Rogue_Keys 1
                Call    PlaySound ( 2099 ) % was 0215
                Add     *Rogue_Padlocks_KeysSpended 1
                Wait    3
            EndLoop
            If *Rogue_Padlocks_KeysSpended >= 60`
                Set *Flag_Cheev_Rogue_23 .True % Challenge Completed
            EndIf
        Case == 2 % Coin lock
            Loop *Var[8]
                Call	PlaySound ( 0211 ) % Coin
                Call    AddCoin ( -1 )
                Call    $Function_Add_CoinsSpended_Half
                Wait	1
            EndLoop
            Call    $Function_Get_CoinsSpended_Half ( *Var[0] )
            If  *Var[0] >= 800`
                Set *Flag_Cheev_Rogue_21 .True % Challenge Completed
            EndIf
        Case == 3 % HP lock
            % Check if Mario doesn't have enough HP
            Call    $Function_GetMarioHP ( *Var[0] )
            If *Var[0] == 1
                Call    ShowMessageAtScreenPos ( $String_HPLockImpossible A0 28 )
                ResumeAll .True
                Call    DisablePlayerInput ( .False )
                Return
            EndIf
            % If the player animation isn't idle, walking or running don't do anything
            Call    GetPlayerAnimation ( *Var[0] )
            Switch *Var[0]
                CaseOR == 00010002 % idle
                CaseOR == 00010004 % walking
                CaseOR == 00010005 % running
                    Wait    1
                    Goto    SubHP
                EndCaseGroup
                Default
                    ResumeAll .True
                    Call    DisablePlayerInput ( .False )
                    Return
            EndSwitch
            Label   SubHP
            Wait    1
            Call    $Function_SubMarioHP
            Call    SetPlayerAnimation ( 00010002 ) % idle
            Call    SetPlayerAnimation ( 00010017 ) % taking damage
            Call    PlaySound ( 00E1 ) % taking damage
            Add     *Rogue_Padlocks_HPSpended 1
            If  *Rogue_Padlocks_HPSpended >= 100`
                Set *Flag_Cheev_Rogue_22 .True % Challenge Completed
            EndIf
            Call    GetPlayerPos  ( *Var[0] *Var[1] *Var[2] )
            Add     *Var[1] 13` % y
            Call    PlayEffect   ( ~FX:Firework:White *Var[0] *Var[1] *Var[2] *Fixed[0.7] 0 0 0 0 0 0 0 0 )
            Call    DisablePlayerPhysics ( .True )
            Call    GetPlayerPos  ( *Var[0] *Var[1] *Var[2] )
            Loop 2
                Add *Var[1] 2
                Call SetPlayerPos ( *Var[0] *Var[1] *Var[2] )
                Wait 2
                Sub *Var[1] 2
                Call SetPlayerPos ( *Var[0] *Var[1] *Var[2] )
                Wait 2
            EndLoop
            Call    DisablePlayerPhysics ( .False )
            Call    SetPlayerAnimation ( 00010002 ) % idle
            If  *Flag_Rogue_1stTime_HPLock == .False
                Call    ShowMessageAtScreenPos ( $String_HPLockTouchIt A0 28 )
                Set     *Flag_Rogue_1stTime_HPLock .True
            EndIf
            ExecWait $Script_Locks_GetAmount % save amount in var8 and entity pointer in varF
            Sub     *Var[8] 1
            Call    $Function_Entity_Lock_SetAmount ( *Var[F] *Var[8] ) % VarPointer NewAmount
            % is time to open the lock?
            ExecWait $Script_Locks_GetAmount % save amount in var8
            If *Var[8] != .False
                ResumeAll .True
                Call    DisablePlayerInput ( .False )
                Return
            EndIf
    EndSwitch
    % Know the correct lock by using Mario's position
    ExecWait $Script_Locks_GetAmount
    /%
    *Var[6]=EntityID
    *Var[7]=SpawnPoint
    *Var[8]=Var
    *Var[F]=EntityVar Pointer % only used on hp padlocks
    %/
    Label   OpenLock
    Add *Rogue_PadlocksOpened 1
    If *Rogue_PadlocksOpened < 0 % Is 0x80 or above
        Set *Rogue_PadlocksOpened 50`
    EndIf
    Switch *Rogue_PadlocksOpened
        Case >= 50`
            Set *Flag_Cheev_Rogue_19 .True % Challenge Completed
            Set *Flag_Cheev_Rogue_20 .True % Challenge Completed
        Case >= 20`
            Set *Flag_Cheev_Rogue_19 .True % Challenge Completed
    EndSwitch
	Call     $Function_GetEntityPosition ( *Var[6] *Var[0] *Var[1] *Var[2] )
	Call     PlaySoundAt 	( 0269 0 *Var[0] *Var[1] *Var[2] )
	Set      *Var[0]  *Var[6]
	Call     $Function_LockAnimation
    ExecWait $Script_ActivateSpring
    Unbind
    ResumeAll .True
    Call    DisablePlayerInput ( .False )
	Return
    End
}

    #new:Function $Function_Add_CoinsSpended_Half
{
    LAHU    T0, 80356092 % Rogue_Padlocks_CoinsSpended_Byte1
    ADDIU   T0, T0, 1
    SAH     T0, 80356092
    JR      RA
    ADDIU   V0, R0, 2
}

    #new:Function $Function_Get_CoinsSpended_Half
{
    PUSH    RA, A1, A2, A3, V0, V1
    LAHU    A2, 80356092 % Rogue_Padlocks_CoinsSpended_Byte1
    LW      A1, C (A0)
    JAL     ~Func:set_variable
    LW      A1, 0 (A1)
    POP     RA, A1, A2, A3, V0, V1
    JR      RA
    ADDIU   V0, R0, 2
}

#new:Script:Map $Script_Locks_GetAmount
{
    Call     GetPlayerPos 	( *Var[A] .False *Var[C] )
    If  *Var[A] < -534`
        If *Var[C] < 78` % 1 % Top Left
            Set *Var[0] 1
            ExecWait $Script_GetCurrentSpring
        Else % 4 % Bottom Left
            Set *Var[0] 4
            ExecWait $Script_GetCurrentSpring
        EndIf
    EndIf
    % Mario is on the right side of the room?
    If  *Var[A] > -534`
        If *Var[C] < 78` % 2 % Top Right
            Set *Var[0] 2
            ExecWait $Script_GetCurrentSpring
        Else % 3 % Bottom Right
            Set *Var[0] 3
            ExecWait $Script_GetCurrentSpring
        EndIf
    EndIf
    Return
    End
}

    #new:Script:Map $Script_GetCurrentSpring
{
    Call $Function_Load_Entity_Data1 % save data in Vars6/7/8
    If *Var[7] == *Var[0]
        Set *Var[F] $Entity_Var1 % used for coins and hp locks
        Return
    EndIf
    Call $Function_Load_Entity_Data2
    If *Var[7] == *Var[0]
        Set *Var[F] $Entity_Var2
        Return
    EndIf
    Call $Function_Load_Entity_Data3
    If *Var[7] == *Var[0]
        Set *Var[F] $Entity_Var3
        Return
    EndIf
    Call $Function_Load_Entity_Data4
    Set *Var[F] $Entity_Var4
    Return
    End
}
    
    #new:Function $Function_GetMarioHP
{
    PUSH	RA, V0, A0, A1, A2
    LABU 	A2, 8010F292
    LW     A1, C (A0) % load Var from arg0
    JAL 	~Func:set_variable
    LW     A1, 0 (A1)
    JPOP	RA, V0, A0, A1, A2
}

    #new:Function $Function_GetMarioCoins
{
    PUSH	RA, V0, A0, A1, A2
    LAHU 	A2, 8010F29C
    LW     A1, C (A0) % load Var from arg0
    JAL 	~Func:set_variable
    LW     A1, 0 (A1)
    JPOP	RA, V0, A0, A1, A2
}

    #new:Function $Function_SubMarioHP
{
    LABU 	T0, 8010F292 % Current HP
    ADDIU   T1, R0, 1
    SUBU    T0, T0, T1
    SAB     T0, 8010F292
    JR  	RA
    ADDIU   V0, R0, 2
}

% Set the value needed to open the lock
#new:Function $Function_Entity_Lock_SaveEntityID
{
PUSH	RA, V0, A1, A2
LIO 	A1, *Var[9] % get entity ID
JAL 	~Func:get_variable 
NOP
% Check what Var is available
.CheckVar1
LAW     T0, $Entity_Var1
BNE     T0, R0, .CheckVar2
NOP
LIO     T0, $Entity_Var1
BEQ     R0, R0, .SetID
NOP
.CheckVar2
LAW     T0, $Entity_Var2
BNE     T0, R0, .CheckVar3
NOP
LIO     T0, $Entity_Var2
BEQ     R0, R0, .SetID
NOP
.CheckVar3
LAW     T0, $Entity_Var3
BNE     T0, R0, .CheckVar4
NOP
LIO     T0, $Entity_Var3
BEQ     R0, R0, .SetID
NOP
.CheckVar4
LIO     T0, $Entity_Var4
.SetID
SB      V0, 0 (T0) % Save entity ID in XX000000 on that EntityVar
LIO 	A1, *MapVar[6] %.Rogue_SpawnPoint
JAL 	~Func:get_variable
RESERVED
SB      V0, 1 (T0) % Save the SpawnPosition used by the Entity
POP 	RA, V0, A1, A2
JR      RA
ORI     V0, R0, 2
}

#new:Function $Function_Entity_Lock_SaveKeyAmount
{
PUSH	RA, V0, A1, A2
% Check what Var is available
.CheckVar1
LIO     T0, $Entity_Var1
LHU     T0, 2 (T0)
BNE     T0, R0, .CheckVar2
NOP
LIO     T0, $Entity_Var1
BEQ     R0, R0, .SetAmount
NOP
.CheckVar2
LIO     T0, $Entity_Var2
LHU     T0, 2 (T0)
BNE     T0, R0, .CheckVar3
NOP
LIO     T0, $Entity_Var2
BEQ     R0, R0, .SetAmount
NOP
.CheckVar3
LIO     T0, $Entity_Var3
LHU     T0, 2 (T0)
BNE     T0, R0, .CheckVar4
NOP
LIO     T0, $Entity_Var3
BEQ     R0, R0, .SetAmount
NOP
.CheckVar4
LIO     T0, $Entity_Var4
.SetAmount
LABU    V0, $LockVar
SH      V0, 2 (T0) % Save amount in 0000XXXX on that EntityVar
POP 	RA, V0, A1, A2
JR      RA
ORI     V0, R0, 2
}

% used only on HP based padlocks, to modify the amount everytime mario get hurt
#new:Function $Function_Entity_Lock_SetAmount
{
PUSH	RA, V0, A0, A1, A2, S0, S1, S2
% load Entity Var pointer
LW      S0, C (A0) % load args pointer
LW      A1, 0 (S0) % load Var from arg0
JAL     ~Func:get_variable
NOP
COPY    S1, V0
% Load new amount to set
LW      A1, 4 (S0) % load Var from arg1
JAL     ~Func:get_variable
NOP
COPY    S2, V0
SH      S2, 2 (S1) % Save new amount in 0000XXXX on that EntityVar
POP 	RA, V0, A0, A1, A2, S0, S1, S2
JR      RA
ORI     V0, R0, 2
}

#new:Function $Function_Load_Entity_Data1
{
PUSH	RA, V0, A1, A2
LABU    A2, $Entity_Var1
LIO 	A1, *Var[6] 
JAL 	~Func:set_variable
RESERVED
LABU    A2, $Entity_Var1[1]
LIO 	A1, *Var[7]
JAL 	~Func:set_variable
RESERVED
LAHU    A2, $Entity_Var1[2]
LIO 	A1, *Var[8]
JAL 	~Func:set_variable
RESERVED
POP	    RA, V0, A1, A2
JR      RA
ORI     V0, R0, 2
}

#new:Function $Function_Load_Entity_Data2
{
PUSH	RA, V0, A1, A2
LABU    A2, $Entity_Var2
LIO 	A1, *Var[6]
JAL 	~Func:set_variable
RESERVED
LABU    A2, $Entity_Var2[1]
LIO 	A1, *Var[7]
JAL 	~Func:set_variable
RESERVED
LAHU    A2, $Entity_Var2[2]
LIO 	A1, *Var[8]
JAL 	~Func:set_variable
RESERVED
POP	    RA, V0, A1, A2
JR      RA
ORI     V0, R0, 2
}

#new:Function $Function_Load_Entity_Data3
{
PUSH	RA, V0, A1, A2
LABU    A2, $Entity_Var3
LIO 	A1, *Var[6]
JAL 	~Func:set_variable
RESERVED
LABU    A2, $Entity_Var3[1]
LIO 	A1, *Var[7]
JAL 	~Func:set_variable
RESERVED
LAHU    A2, $Entity_Var3[2]
LIO 	A1, *Var[8]
JAL 	~Func:set_variable
RESERVED
POP 	RA, V0, A1, A2
JR      RA
ORI     V0, R0, 2
}

#new:Function $Function_Load_Entity_Data4
{
PUSH	RA, V0, A1, A2
LABU    A2, $Entity_Var4
LIO 	A1, *Var[6]
JAL 	~Func:set_variable
RESERVED
LABU    A2, $Entity_Var4[1]
LIO 	A1, *Var[7]
JAL 	~Func:set_variable
RESERVED
LAHU    A2, $Entity_Var4[2]
LIO 	A1, *Var[8]
JAL 	~Func:set_variable
RESERVED
POP 	RA, V0, A1, A2
JR      RA
ORI     V0, R0, 2
}

#string $String_Lockamount
{
[STYLE:INSPECT][...]
Looks like the lock has a [PushColor][Color:07][Var:00][PopColor]
engraved.
[WAIT][END]
}

#string $String_LockConfirmation
{
[STYLE:INSPECT][...]
Do you want to open the lock?
(You will need [PushColor][Color:07][Var:00][PopColor] [Var:01])
[Func_04][END]
}

#string $String_HPLockamount
{
[STYLE:INSPECT][...]
Looks like the padlock has some
kind of dangerous mechanism.
[WAIT][NEXT][...]
Looks like [PushColor][Color:07]I will get hurt[PopColor] if I try
to touch it.
[WAIT][NEXT][...]
Do you want to try to open the
padlock anyways?
[Func_04][END]
}

#string $String_HPLockImpossible
{
[STYLE:INSPECT][...]
Looks like trying to do that right
now, will be [PushColor][Color:07]fatal[PopColor].
[WAIT][NEXT][...]
Maybe when I have [PushColor][Color:07]a little more
health[PopColor].
[WAIT][END]
}

#string $String_HPLockTouchIt
{
[STYLE:INSPECT][...]
Looks like the padlock is [PushColor][Color:07]slightly
more open[PopColor] now.
[WAIT][END]
}

#string $MessageString_key
{
key[END]
}

#string $MessageString_keys
{
keys[END]
}

#string $MessageString_coins
{
coins[END]
}

#new:Script:Map $Script_ActivateSpring
{
    % Activate the Spring by reading Mario's position
    % Was using .Rogue_SpawnPoint but there's some problems
    % when load more than one trap by using that approach.
    Call     GetPlayerPos 	( *Var[A] .False *Var[C] )
    % Mario is on the left side of the room?
    If  *Var[A] < -534`
        If *Var[C] < 78` % 1 % Top Left
            Call ModifyColliderFlags ( .False .Collider_Spring_Top_1 7FFFFE00 )
        Else % 4 % Bottom Left
            Call ModifyColliderFlags ( .False .Collider_Spring_Top_4 7FFFFE00 )
        EndIf
    EndIf
    % Mario is on the right side of the room?
    If  *Var[A] > -534`
        If *Var[C] < 78` % 2 % Top Right
            Call ModifyColliderFlags ( .False .Collider_Spring_Top_2 7FFFFE00 )
        Else % 3 % Bottom Right
            Call ModifyColliderFlags ( .False .Collider_Spring_Top_3 7FFFFE00 )
        EndIf
    EndIf
    Return
    End
}

#new:Script:Map $Script_Springs_EnableColliders
{
Switch .Rogue_SpawnPoint
Case == 1 % Top Left
    Call    ModifyColliderFlags ( .True .Collider_Spring_Top_1 7FFFFE00 )
    Call    ModifyColliderFlags ( .True .Collider_Spring_Wall_1 7FFFFE00 )
Case == 2 % Top Right
    Call    ModifyColliderFlags ( .True .Collider_Spring_Top_2 7FFFFE00 )
    Call    ModifyColliderFlags ( .True .Collider_Spring_Wall_2 7FFFFE00 )
Case == 3 % Bottom Right
    Call    ModifyColliderFlags ( .True .Collider_Spring_Top_3 7FFFFE00 )
    Call    ModifyColliderFlags ( .True .Collider_Spring_Wall_3 7FFFFE00 )
Case == 4 % Bottom Left
    Call    ModifyColliderFlags ( .True .Collider_Spring_Top_4 7FFFFE00 )
    Call    ModifyColliderFlags ( .True .Collider_Spring_Wall_4 7FFFFE00 )
EndSwitch
Return
End
}

% Track if Mario made a ground pound on a spring
#new:Script:Map $Script_Track_GroundPound
{
% Get Current Spring
Call     GetPlayerPos 	( *Var[A] .False *Var[C] )
% Mario is on the left side of the room?
If  *Var[A] < -534`
    If *Var[C] < 51` % 1 % Top Left
        Set *Var[1] .Collider_Spring_Top_1
    Else % 4 % Bottom Left
        Set *Var[1] .Collider_Spring_Top_4
    EndIf
Else
% Mario is on the right side of the room?
    If *Var[C] < 51` % 2 % Top Right
        Set *Var[1] .Collider_Spring_Top_2
    Else % 3 % Bottom Right
        Set *Var[1] .Collider_Spring_Top_3
    EndIf
EndIf
Call GetPlayerActionState *Var[0]
Switch *Var[0]
    CaseOR == E % Ground Pound (Super Boots)
    CaseOR == F % Ground Pound (Ultra Boots)
        Call    ModifyColliderFlags ( .False *Var[1] 7FFFFE00 )
        % Enable the collider after using the spring
        Wait    10`
        Call    ModifyColliderFlags ( .True *Var[1] 7FFFFE00 )
    EndCaseGroup
EndSwitch
Return
End
}

% Track if Goombario has fixed a Spring
#new:Script:Map $Script_Track_Goombario
{
SetGroup 0
SuspendAll .True
Call DisablePlayerInput ( .True )
% Check if Goombario is unlocked
Call $Function_CheckGoombarioFlag
If  *Var[0] == .True
    Call GetCurrentPartnerID ( *Var[0] )
    % Bring Goombario out if he isn't the current partner
    If  *Var[0] != .Partner:Goombario
        Call BringPartnerOut .Partner:Goombario
        Wait 20`
        Call PlaySound ( 0010 ) % save
        Call PutPartnerAway
    Else
        % If the current partner was indeed Goombario
        Wait    10`
        Call PlaySound ( 0010 ) % save
    EndIf
    % Get Current Spring
    Call     GetPlayerPos 	( *Var[A] .False *Var[C] )
    % Mario is on the left side of the room?
    If  *Var[A] < -534`
        If *Var[C] < 78` % 1 % Top Left
            Set *Var[1] .Collider_Spring_Top_1
            Set *Var[2] .Collider_Spring_Wall_1
        Else % 4 % Bottom Left
            Set *Var[1] .Collider_Spring_Top_4
            Set *Var[2] .Collider_Spring_Wall_4
        EndIf
    EndIf
    % Mario is on the right side of the room?
    If  *Var[A] > -534`
        If *Var[C] < 78` % 2 % Top Right
            Set *Var[1] .Collider_Spring_Top_2
            Set *Var[2] .Collider_Spring_Wall_2
        Else % 3 % Bottom Right
            Set *Var[1] .Collider_Spring_Top_3
            Set *Var[2] .Collider_Spring_Wall_3
        EndIf
    EndIf
    ResumeAll .True
    Call    DisablePlayerInput ( .False )
    Call    ModifyColliderFlags ( .False *Var[1] 7FFFFE00 )
    Call    ModifyColliderFlags ( .False *Var[2] 7FFFFE00 )
Else
    % If Goombario isn't unlocked
    Call    ShowMessageAtScreenPos ( $String_GoombarioSpring 000000A0 00000028 )
    ResumeAll .True
    Call    DisablePlayerInput ( .False )
EndIf
Return
End
}

#new:Function $Function_CheckGoombarioFlag
{
PUSH	RA, V0, A1, A2
LABU 	A2, 8010F2AC % Goombario Flag
LIO 	A1, *Var[0]
JAL 	~Func:set_variable
RESERVED
JPOP	RA, V0, A1, A2
}

#string $String_GoombarioSpring
{
[STYLE:INSPECT][...]
Looks like the Spring is stuck.
[WAIT][NEXT][...]
Maybe If I knew someone with
enough knowledge.
[WAIT][END]
}

% Track if Goombario has fixed a Spring
#new:Script:Map $Script_Track_Watt
{
SetGroup 0
SuspendAll .True
Call DisablePlayerInput ( .True )
% Check if Goombario is unlocked
Call $Function_CheckWattFlag
If  *Var[0] == .True
    Call GetCurrentPartnerID ( *Var[0] )
    % Bring Goombario out if he isn't the current partner
    If  *Var[0] != .Partner:Watt
        Call BringPartnerOut .Partner:Watt
        Wait 20`
        Call PlaySound ( 0010 ) % save
        Call PutPartnerAway
    Else
        % If the current partner was indeed Goombario
        Wait    10`
        Call PlaySound ( 0010 ) % save
    EndIf
    % Get Current Spring
    Call     GetPlayerPos 	( *Var[A] .False *Var[C] )
    % Mario is on the left side of the room?
    If  *Var[A] < -534`
        If *Var[C] < 78` % 1 % Top Left
            Set *Var[1] .Collider_Spring_Top_1
            Set *Var[2] .Collider_Spring_Wall_1
            Call EnableModel ( .Model_Engine_1_Red .False )
            Call EnableModel ( .Model_Engine_1_Green .True )
        Else % 4 % Bottom Left
            Set *Var[1] .Collider_Spring_Top_4
            Set *Var[2] .Collider_Spring_Wall_4
            Call EnableModel ( .Model_Engine_4_Red .False )
            Call EnableModel ( .Model_Engine_4_Green .True )
        EndIf
    Else
    % Mario is on the right side of the room?
        If *Var[C] < 78` % 2 % Top Right
            Set *Var[1] .Collider_Spring_Top_2
            Set *Var[2] .Collider_Spring_Wall_2
            Call EnableModel ( .Model_Engine_2_Red .False )
            Call EnableModel ( .Model_Engine_2_Green .True )
        Else % 3 % Bottom Right
            Set *Var[1] .Collider_Spring_Top_3
            Set *Var[2] .Collider_Spring_Wall_3
            Call EnableModel ( .Model_Engine_3_Red .False )
            Call EnableModel ( .Model_Engine_3_Green .True )
        EndIf
    EndIf
    ResumeAll .True
    Call    DisablePlayerInput ( .False )
    Call    ModifyColliderFlags ( .False *Var[1] 7FFFFE00 )
    Call    ModifyColliderFlags ( .False *Var[2] 7FFFFE00 )
Else
    % If Watt isn't unlocked
    Call    ShowMessageAtScreenPos ( $String_WattSpring 000000A0 00000028 )
    ResumeAll .True
    Call    DisablePlayerInput ( .False )
EndIf
Return
End
}

#new:Function $Function_CheckWattFlag
{
PUSH	RA, V0, A1, A2
LABU 	A2, 8010F2D4 % Watt Flag
LIO 	A1, *Var[0]
JAL 	~Func:set_variable
RESERVED
JPOP	RA, V0, A1, A2
}

#string $String_WattSpring
{
[STYLE:INSPECT][...]
Look's like the Spring doesn't
have the enough energy.
[WAIT][NEXT][...]
Maybe If I knew someone with
the enough power.
[WAIT][END]
}

%%
#new:Script:Map $Script_SetPos_SpringKeeper
{
% Check if is the 2nd trap from 1thing2traps to overwrite the ID
% acordingly to the
If .Rogue_Item_2 == .False
    If .Rogue_LoadedID != FF
        Return
    EndIf
EndIf
% Load an Enemy according to the current floor plus reward value
Set *Var[0] *PitMapID
%% Load Current Reward - unfinished
% Put special values if a 4Chest ID is
% being used?
%%% asdf %%%
% Get NPC ID
/% Why IDs from 50 through 59? 
There's floors with special IDs
Like Level 35 it use IDs 32-34
I just put a range of values
i'm pretty sure any floor doesn't use
%/
If .Rogue_ID != 19` % 4 chests/springs
    % If isn't the 2nd time loading this trap
    If .Rogue_LoadedID != 18` % battle based
        %Call RandInt ( 90` *Var[0] ) % testing stuff
        Switch *Var[0]
            Case < 10` % Koopatropa
                Set *Var[0] 50 % npcID
            Case < 20` % Forest Fuzzy
                Set *Var[0] 51
            Case < 30` % Bleft
                Set *Var[0] 52
            Case < 40` % Spy Guy
                Set *Var[0] 53
            Case < 50` % Jungle Fuzzy
                Set *Var[0] 54
            Case < 60` % Crazee Dayzee
                Set *Var[0] 55
            Case < 70` % Lakitu
                Set *Var[0] 56
            Case < 80` % White Clubba
                Set *Var[0] 57
            Case < 90` % Hammer Bros.
                Set *Var[0] 58
            Case > 90` % Ember Guy
                Set *Var[0] 59
        EndSwitch
        Call $Function_Reward_SaveExtraData ( *Var[0] )
    Else
        % 2nd time loading this trap on the same floor
        % Check what NPC was put on the spring
        Call $Function_Reward_GetExtraData ( *Var[9] )
        Set  *Var[0] *Var[9]
        Switch *Var[0]
            Case <= 54
                Add *Var[0] 1
            Case >= 55
                Sub *Var[0] 1
        EndSwitch
        Call $Function_Reward_SaveExtraData ( *Var[0] )
    EndIf
Else
% ID 19 use a different loader
    Switch .Rogue_SpawnPoint
        Case == 1
            Switch *Var[0]
                Case < 10` % Koopatropa
                    Set *Var[0] 50 % npcID
                Case < 20` % Forest Fuzzy
                    Set *Var[0] 51
                Case < 30` % Bleft
                    Set *Var[0] 52
                Case < 40` % Spy Guy
                    Set *Var[0] 53
                Case < 50` % Jungle Fuzzy
                    Set *Var[0] 54
                Case < 60` % Crazee Dayzee
                    Set *Var[0] 55
                Case < 70` % Lakitu
                    Set *Var[0] 56
                Case < 80` % White Clubba
                    Set *Var[0] 57
                Case < 90` % Hammer Bros.
                    Set *Var[0] 58
                Case > 90` % Ember Guy
                    Set *Var[0] 59
            EndSwitch
            Call $Function_Reward_SaveExtraData ( *Var[0] )
        CaseOR == 2
        CaseOR == 3
        CaseOR == 4
            Call $Function_Reward_GetExtraData ( *Var[9] )
            Set *Var[0] *Var[9]
            Switch *Var[0]
                Case <= 54
                    Add *Var[0] 1
                Case >= 55
                    Sub *Var[0] 1
            EndSwitch
            % Save ID to load
            Call $Function_Reward_SaveExtraData ( *Var[0] )
        EndCaseGroup
    EndSwitch
EndIf
/% Set NPC Position
Label SetPosition
Switch .Rogue_SpawnPoint
    Case == 1 % upper L
        Call SetNpcPos ( *Var[0] -650` -12` 37` )
    Case == 2 % upper R
        Call SetNpcPos ( *Var[0] -413` -12` 37` )
    Case == 3 % bottom R
        Call SetNpcPos ( *Var[0] -413` -12` 125` )
    Case == 4 % bottom L
        Call SetNpcPos ( *Var[0] -650` -12` 125` )
EndSwitch%/
Return
End
}

#new:Script:Map $Script_Spring_SetNPC
{
Call $Function_Load_RewardData ( *Var[E] )
% Format value
Switch *Var[E]
    Case == 1 % Koopatropa, Forest Fuzzy, Bleft
        Call RandInt ( 2 *Var[9] )
        Set *Var[E] 50
        Add *Var[E] *Var[9]
    Case == 2 % Spy Guy, Jungle Fuzzy, Crazee Dayzee, Lakitu
        Call RandInt ( 3 *Var[9] )
        Set *Var[E] 53
        Add *Var[E] *Var[9]
    Case >= 3 % White Clubba
        Set *Var[E] 57
    Case >= 4 % Hammer Bros.
        Set *Var[E] 58
    Default
        Set *Var[E] 50 % Koopatropa
EndSwitch
% set pos
Call    $Function_Reward_GetDataX % save in varA/B/C
% Check if 1thing2traps was used
If .Rogue_Item_2 == .False
    If .Rogue_LoadedID != FF
        Set *Var[A] .Rogue_SpawnPoint % use SpawnPoint instead
    EndIf
EndIf
% *Var[A] - Reward Spawn Point
Switch *Var[A]
    Case == 1 % upper L
        Call SetNpcPos ( *Var[E] -650` -12` 37` )
        Call SetNpcYaw ( *Var[E] 90` ) % change orientation
    Case == 2 % upper R
        Call SetNpcPos ( *Var[E] -413` -12` 37` )
    Case == 3 % bottom R
        Call SetNpcPos ( *Var[E] -413` -12` 125` )
    Case == 4 % bottom L
        Call SetNpcPos ( *Var[E] -650` -12` 125` )
        Call SetNpcYaw ( *Var[E] 90` ) % change orientation
EndSwitch
Return
End
}

#new:Function $Function_Reward_GetExtraData
{
PUSH	RA, V0, A0, A1, A2
LAW     A2, $Data_Reward_DataExtra
LW     A1, C (A0) % load from arg0
JAL     ~Func:set_variable
LW     A1, 0 (A1)
JPOP	RA, V0, A0, A1, A2
}

#new:Function $Function_Reward_SaveExtraData
{
PUSH	RA, V0, A0, A1, A2
LW     A1, C (A0) % load from arg0
JAL     ~Func:get_variable
LW     A1, 0 (A1)
SAW     V0, $Data_Reward_DataExtra
JPOP    RA, V0, A0, A1, A2
}

#new:Function $Function_Load_RewardData
{
PUSH	RA, V0, A0, A1, A2
LABU    A2, $RewardVar
LW     A1, C (A0) % load from arg0
JAL     ~Func:set_variable
LW     A1, 0 (A1)
JPOP	RA, V0, A0, A1, A2
}

#new:Function $Function_Save_RewardData
{
PUSH	RA, V0, A0, A1, A2
LW     A1, C (A0) % load from arg0
JAL     ~Func:get_variable
LW     A1, 0 (A1)
SAB     V0, $RewardVar
JPOP    RA, V0, A0, A1, A2
}

% Init Springkeeper
#new:Script:Map $Script_NPC_Init_Springkeeper
{
Call     BindNpcInteract	( .Npc:Self $Springkeeper_Interact )
Call     BindNpcIdle 	    ( .Npc:Self $Springkeeper_Idle )
Call     BindNpcDefeat 	    ( .Npc:Self $Springkeeper_TrackBattle )
Return
End
}

#export $Script_NPC_Init_Springkeeper

#new:Script:Map $Springkeeper_Interact
{
SuspendOthers .True
Call    DisablePlayerInput ( .True )
% Check if Mario has already talked to him
Call    GetSelfVar     ( 1 *Var[0] )
If  *Var[0] == .True
    Call	SetNpcVar       ( .Npc:Self .Default .True )
    Return
EndIf
% Get String to say
Call    RandInt ( 1 *Var[0] )
Switch *Var[0]
    Case == 0
        Set *Var[0] $String_Spring_1
    Case == 1
        Set *Var[0] $String_Spring_2
EndSwitch
% Say string
Call    GetSelfNpcID   ( *Var[1] )
Switch  *Var[1]
    Case == 50 % Koopa
        Call    SpeakToPlayer 	( .Npc:Self 00290101 00290101 00000000 *Var[0] )
    Case == 51 % Fuzzy
        Call    SpeakToPlayer 	( .Npc:Self 002B0101 002B0101 00000000 *Var[0] )
    Case == 52 % Bleft
        Call    SpeakToPlayer 	( .Npc:Self 00300902 00300902 00000000 *Var[0] )
    Case == 53 % Spy Guy
        Call    SpeakToPlayer 	( .Npc:Self 003F0002 003F0002 00000000 *Var[0] )
    Case == 54 % Jungle Fuzzy
        Call    SpeakToPlayer 	( .Npc:Self 002B0301 002B0301 00000000 *Var[0] )
    Case == 55 % Crazee Dayzee
        Call    SpeakToPlayer 	( .Npc:Self 00480001 00480001 00000000 *Var[0] )
    Case == 56 % Lakitu
        Call    SpeakToPlayer 	( .Npc:Self 00490001 00490001 00000000 *Var[0] )
    Case == 57 % White Clubba
        Call    SpeakToPlayer 	( .Npc:Self 00390102 00390102 00000000 *Var[0] )
    Case == 58 % Hammer Bros
        Call    SpeakToPlayer 	( .Npc:Self 005A0003 005A0003 00000000 *Var[0] )
    Case == 59 % Ember Guy
        Call    SpeakToPlayer 	( .Npc:Self 003E0801 003E0801 00000000 *Var[0] )
EndSwitch
Call    SetSelfVar     ( 1 .True ) % Var1 = Already talked to him
Call	SetNpcVar       ( .Npc:Self .Default .True )
Return
End
}

#new:Script:Map $Springkeeper_Idle
{
Loop
    Call    GetSelfVar ( .Default *Var[0] )
    If *Var[0] == .True
        Call    DisablePlayerInput ( .False )
        ResumeOthers .True
        Call    SetSelfVar ( .Default .False )
        Call	StartBattle
    EndIf
    Wait    1
EndLoop
Return
End
}

% Track Battle
#new:Script:Map $Springkeeper_TrackBattle
{
	Call     GetBattleOutcome 	( *Var[0] )
	Switch  *Var[0] 
		Case  ==  0 % When you won
			Exec    $Script_ActivateSpring
			Call	DoNpcDefeat
		Case  ==  1 % When you die %
			SuspendOthers .True
			Call SetPlayerAnimation ( 0001000F ) % Dead
			Call GetCurrentPartnerID 	( *Var[0] )
			If  *Var[0]  !=  0 
				Call DisablePartnerAI ( .True )
			EndIf
			Call     $Function_Global_RevivePlayer
			WaitSeconds 2
            Call DisablePlayerInput	( .True )
            ExecWait $Script_Rogue_GiveHalfCoins
            If *Flag_Demo == .True
                Call GotoMap ( $ASCII_dmo_00 0 )
            Else
                Call GotoMap ( $ASCII_pt_00 6 )
            EndIf
	EndSwitch
	Return
	End
}

#new:Script $Script_Rogue_GiveHalfCoins
{
	Call  ShowMessageAtScreenPos  ( $String_Rogue_CoinsGained_Failed 000000A0 00000028 )
	Call  $ReadAddress ( 8010F2AA 1 *Var[0] .False .False ) % load Total Gained Coins in actual Pit playthrough
    If *Var[0] <= 1 % 1 or zero coins
        Return
    EndIf
    Div   *Var[0] 2 % get half of the coins
    Set   *Var[A] *Var[0]
	% show bank's coin box
	Set	*BankTextBoxPosition 1
	Set	*TalkingToFishmael .True
	Wait 10`
	% save coins
	Call 	$ReadAddress  ( 803560DC 2 *Var[1] .False .False ) % load bank account
	Add	*Var[1] *Var[0]
	SetTimescale *Fixed[15.0]
	Loop
		Call 	$ReadAddress  ( 803560DC 2 *Var[2] .False .False ) % load bank account
		Add	*Var[2] 1
		% Bank Account Cap
		If *Var[2] > 9999999` % 9,999,999 / 0098967F
			BreakLoop
		EndIf
		Call 	$WriteAddress ( 803560DC 2 *Var[2] .False .False ) % save bank account
		Call	PlaySound ( 0211 ) % coin
		If *Var[2] == *Var[1]
			BreakLoop
		EndIf
		Wait	1
	EndLoop
	SetTimescale *Fixed[1.0] % Back to Normal
      Call $ReadAddress ( 803560DC 2 *Var[1] .False .False ) % load bank account
	% Check Challenges
	Switch *Var[1]
            Case >= 40000`
                  Set *Flag_Cheev_Global_13 .True
                  Set *Flag_Cheev_Global_12 .True
                  Set *Flag_Cheev_Global_11 .True
            Case >= 10000`
                  Set *Flag_Cheev_Global_12 .True
                  Set *Flag_Cheev_Global_11 .True
            Case >= 1000`
                  Set *Flag_Cheev_Global_11 .True
	EndSwitch
    Call  SetMessageValue ( *Var[A] 1 )
	Call  ShowMessageAtScreenPos  ( $String_Rogue_CoinsAdded 000000A0 00000028 )
	% close bank's coin box
	Call 	$WriteAddress ( $BoxAnimation_State  2 2 .False .False )
	Call 	$WriteAddress ( $BoxAnimation_Offset 2 7 .False .False )
	Wait	10`
	Return
	End
}

#string $String_Rogue_CoinsGained_Failed
{
[STYLE:EPILOGUE][...]
You got beaten inside the
Roguelike Pit.
[WAIT][NEXT][...]
You will get half of all the
coins you got from battles.
[WAIT][END]
}

#string $String_Rogue_CoinsAdded
{
[STYLE:EPILOGUE][...]
[PushColor][Color:07][Var:01][PopColor] coins got added
to your Bank Account.
[WAIT][END]
}

#export $Script_Rogue_GiveHalfCoins
#export $String_Rogue_CoinsGained_Failed
#export $String_Rogue_CoinsAdded

#export:ASCII $ASCII_dmo_00
{
    "dmo_00"
}

#export:ASCII $ASCII_pt_00
{
    "pt_00"
}

#new:Function $Function_Global_RevivePlayer
{
	PUSH      RA
	ADDIU     V0, R0, 1
	SAB       V0, 8010F292
	JAL       800E9B6C
	NOP
	POP       RA
	JR        RA
	ADDIU     V0, R0, 2
}

#string $String_Spring_1
{
[STYLE:RIGHT][...]
Yoo, do you like this Spring?
[WAIT][NEXT][...]
Hehe, don't say a thing I
already know what you will say.
[WAIT][NEXT][...]
This spring is mine and I love
it from the bottom of my heart.
[WAIT][NEXT][...]
So... please stop staring at
my spring!
[WAIT][END]
}

#string $String_Spring_2
{
[STYLE:RIGHT][...]
Hey, do you know the thing
I like the most in this world?!
[WAIT][NEXT][...]
Yeah that's right, I'm talking
about this spring!
[WAIT][NEXT][...]
So, can you please just stop
staring at it!
[WAIT][END]
}

% Entities Spawn Positions
% Why always 3 vectors? I dunno, when using at least 3 was always the only time it worked :) (yeah i changed the amount on LoadPath)

% Corners
% Set 1
% Upper Left
#new:Data $VectorList_Entity_Spawn_Corners_Set1_1
{
-724.000000 24.000000 -64.000000
-724.000000 25.000000 -64.000000
-724.000000 26.000000 -64.000000 % Spawn Coords
}

% Upper Right
#new:Data $VectorList_Entity_Spawn_Corners_Set1_2
{
-340.000000 24.000000 -64.000000
-340.000000 25.000000 -64.000000
-340.000000 26.000000 -64.000000 % Spawn Coords
}

% Bottom Right
#new:Data $VectorList_Entity_Spawn_Corners_Set1_3
{
-330.000000 24.000000 128.000000
-330.000000 25.000000 128.000000
-330.000000 26.000000 128.000000 % Spawn Coords
}

% Bottom Left
#new:Data $VectorList_Entity_Spawn_Corners_Set1_4
{
-734.000000 24.000000 128.000000
-734.000000 25.000000 128.000000
-734.000000 26.000000 128.000000 % Spawn Coords
}

% Set 2
% Upper Left
#new:Data $VectorList_Entity_Spawn_Corners_Set2_1
{
-724.000000 62.000000 -65.000000
-724.000000 63.000000 -65.000000
-724.000000 64.000000 -65.000000 % Spawn Coords
}

% Upper Right
#new:Data $VectorList_Entity_Spawn_Corners_Set2_2
{
-343.000000 62.000000 -65.000000
-343.000000 63.000000 -65.000000
-343.000000 64.000000 -65.000000 % Spawn Coords
}

% Bottom Right
#new:Data $VectorList_Entity_Spawn_Corners_Set2_3
{
-343.000000 62.000000 128.000000
-343.000000 63.000000 128.000000
-343.000000 64.000000 128.000000 % Spawn Coords
}

% Bottom Left
#new:Data $VectorList_Entity_Spawn_Corners_Set2_4
{
-724.000000 62.000000 128.000000
-724.000000 63.000000 128.000000
-724.000000 64.000000 128.000000 % Spawn Coords
}

%%%
%%% Floors
% Middle - 001
% Up
#new:Data $VectorList_Entity_Spawn_Middle_Up_001
{
-487.000000 28.000000 -73.000000
-487.000000 29.000000 -73.000000
-487.000000 30.000000 -73.000000 % Spawn Coords
}

% Down
#new:Data $VectorList_Entity_Spawn_Middle_Down_001
{
-487.000000 28.000000 168.000000
-487.000000 29.000000 168.000000
-487.000000 30.000000 168.000000 % Spawn Coords
}

% Middle - 100
% Up
#new:Data $VectorList_Entity_Spawn_Middle_Up_100
{
-581.000000 28.000000 -73.000000
-581.000000 29.000000 -73.000000
-581.000000 30.000000 -73.000000 % Spawn Coords
}

% Down
#new:Data $VectorList_Entity_Spawn_Middle_Down_100
{
-581.000000 28.000000 168.000000
-581.000000 29.000000 168.000000
-581.000000 30.000000 168.000000 % Spawn Coords
}

% Middle - 010
% Up
#new:Data $VectorList_Entity_Spawn_Middle_Up_010
{
-533.000000 28.000000 -49.000000
-533.000000 29.000000 -49.000000
-533.000000 30.000000 -49.000000 % Spawn Coords
}

% Right
#new:Data $VectorList_Entity_Spawn_Middle_Right_010
{
-340.000000 28.000000 35.000000
-340.000000 29.000000 35.000000
-340.000000 30.000000 35.000000 % Spawn Coords
}

% Down
#new:Data $VectorList_Entity_Spawn_Middle_Down_010
{
-533.000000 28.000000 155.000000
-533.000000 29.000000 155.000000
-533.000000 30.000000 155.000000 % Spawn Coords
}

% Left
#new:Data $VectorList_Entity_Spawn_Middle_Left_010
{
-724.000000 28.000000 35.000000
-724.000000 29.000000 35.000000
-724.000000 30.000000 35.000000 % Spawn Coords
}

% Middle - 010 - Only Switches
% Up
#new:Data $VectorList_Entity_Spawn_Middle_Up_Switch_010
{
-533.000000 28.000000 -73.000000
-533.000000 29.000000 -73.000000
-533.000000 30.000000 -73.000000 % Spawn Coords
}

% Down
#new:Data $VectorList_Entity_Spawn_Middle_Down_Switch_010
{
-533.000000 28.000000 168.000000
-533.000000 29.000000 168.000000
-533.000000 30.000000 168.000000 % Spawn Coords
}

%% Springs
#new:Data $VectorList_Entity_Spring1
{
-664.000000 -10.000000 11.000000
-664.000000 -11.000000 11.000000
-664.000000 -12.000000 11.000000 % Spawn Coords
}

#new:Data $VectorList_Entity_Spring2
{
-402.000000 -10.000000 11.000000
-402.000000 -11.000000 11.000000
-402.000000 -12.000000 11.000000 % Spawn Coords
}

#new:Data $VectorList_Entity_Spring3
{
-402.000000 -10.000000 83.000000
-402.000000 -11.000000 83.000000
-402.000000 -12.000000 83.000000 % Spawn Coords
}

#new:Data $VectorList_Entity_Spring4
{
-664.000000 -10.000000 83.000000
-664.000000 -11.000000 83.000000
-664.000000 -12.000000 83.000000 % Spawn Coords
}

%% Padlocks - Springs
#new:Data $VectorList_Entity_Lock_Spring_1
{
-664.000000 -7.000000 33.000000
-664.000000 -8.000000 33.000000
-664.000000 -9.000000 33.000000 % Spawn Coords
}

#new:Data $VectorList_Entity_Lock_Spring_2
{
-402.000000 -10.000000 33.000000
-402.000000 -11.000000 33.000000
-402.000000 -12.000000 33.000000 % Spawn Coords
}

#new:Data $VectorList_Entity_Lock_Spring_3
{
-402.000000 -10.000000 118.000000
-402.000000 -11.000000 118.000000
-402.000000 -12.000000 118.000000 % Spawn Coords
}

#new:Data $VectorList_Entity_Lock_Spring_4
{
-664.000000 -10.000000 118.000000
-664.000000 -11.000000 118.000000
-664.000000 -12.000000 118.000000 % Spawn Coords
}

%% Blocks - High 1
% Upper Left
#new:Data $VectorList_Entity_Block_Set1_1
{
-724.000000 74.000000 -64.000000
-724.000000 75.000000 -64.000000
-724.000000 76.000000 -64.000000 % Spawn Coords
}

% Upper Right
#new:Data $VectorList_Entity_Block_Set1_2
{
-340.000000 74.000000 -64.000000
-340.000000 75.000000 -64.000000
-340.000000 76.000000 -64.000000 % Spawn Coords
}

% Bottom Right
#new:Data $VectorList_Entity_Block_Set1_3
{
-340.000000 74.000000 151.000000
-340.000000 75.000000 151.000000
-340.000000 76.000000 151.000000 % Spawn Coords
}

% Bottom Left
#new:Data $VectorList_Entity_Block_Set1_4
{
-724.000000 74.000000 151.000000
-724.000000 75.000000 151.000000
-724.000000 76.000000 151.000000 % Spawn Coords
}

%% Blocks - High 2 % for Corners2 and Exclusive Ultra Boots Blocks
% Upper Left
#new:Data $VectorList_Entity_Block_Set2_1
{
-724.000000 114.000000 -64.000000
-724.000000 115.000000 -64.000000
-724.000000 116.000000 -64.000000 % Spawn Coords
}

% Upper Right
#new:Data $VectorList_Entity_Block_Set2_2
{
-340.000000 114.000000 -64.000000
-340.000000 115.000000 -64.000000
-340.000000 116.000000 -64.000000 % Spawn Coords
}

% Bottom Right
#new:Data $VectorList_Entity_Block_Set2_3
{
-340.000000 114.000000 151.000000
-340.000000 115.000000 151.000000
-340.000000 116.000000 151.000000 % Spawn Coords
}

% Bottom Left
#new:Data $VectorList_Entity_Block_Set2_4
{
-724.000000 114.000000 151.000000
-724.000000 115.000000 151.000000
-724.000000 116.000000 151.000000 % Spawn Coords
}

% Checking Flags Scripts
#new:Script:Map $Script_Rogue_CheckFlags_Entities
{
If .Rogue_Flag_Entity_1 == .False
    Set .Rogue_Flag_Entity_1 .True
    Set *Var[9] 1 % entity index
    Return
EndIf
If .Rogue_Flag_Entity_2 == .False
    Set .Rogue_Flag_Entity_2 .True
    Set *Var[9] 2 % entity index
    Return
EndIf
If .Rogue_Flag_Entity_3 == .False
    Set .Rogue_Flag_Entity_3 .True
    Set *Var[9] 3 % entity index
    Return
EndIf
If .Rogue_Flag_Entity_4 == .False
    Set .Rogue_Flag_Entity_4 .True
    Set *Var[9] 4 % entity index
    Return
EndIf
If .Rogue_Flag_Entity_5 == .False
    Set .Rogue_Flag_Entity_5 .True
    Set *Var[9] 5 % entity index
    Return
EndIf
If .Rogue_Flag_Entity_6 == .False
    Set .Rogue_Flag_Entity_6 .True
    Set *Var[9] 6 % entity index
    Return
EndIf
If .Rogue_Flag_Entity_7 == .False
    Set .Rogue_Flag_Entity_7 .True
    Set *Var[9] 7 % entity index
    Return
EndIf
If .Rogue_Flag_Entity_8 == .False
    Set .Rogue_Flag_Entity_8 .True
    Set *Var[9] 8 % entity index
    Return
EndIf
If .Rogue_Flag_Entity_9 == .False
    Set .Rogue_Flag_Entity_9 .True
    Set *Var[9] 9 % entity index
    Return
EndIf
If .Rogue_Flag_Entity_10 == .False
    Set .Rogue_Flag_Entity_10 .True
    Set *Var[9] 10` % entity index
    Return
EndIf
If .Rogue_Flag_Entity_11 == .False
    Set .Rogue_Flag_Entity_11 .True
    Set *Var[9] 11` % entity index
    Return
EndIf
If .Rogue_Flag_Entity_12 == .False
    Set .Rogue_Flag_Entity_12 .True
    Set *Var[9] 12` % entity index
    Return
EndIf
Return
End
}

%% Spawn Rewards
% This script read all traps data to know what kind of
% reward to spawn next
#new:Script:Map $Script_InitReward
{
% Check if the Item need to appear on the upper corners
/%
Var[A]=Reward Spawn Point
Var[B]=Trap ID
Var[C]=Rarity Points
%/
Call $Function_Reward_WriteDataX % save the data previously loaded in DataX
% Get Rarity points by reading the current trap and floor
% Var5 = Rarity Var
Set *Var[5] .Default
% read current floor
Switch *PitMapID
    Case < 10`
        Add *Var[5] 0
    Case < 20`
        Add *Var[5] 0
    Case < 30`
        Add *Var[5] 0
    Case < 40`
        Add *Var[5] 0
    Case < 50`
        Add *Var[5] 1
    Case < 60`
        Add *Var[5] 1
    Case < 70`
        Add *Var[5] 1
    Case < 80`
        Add *Var[5] 2
    Case < 90`
        Add *Var[5] 2
    Case < 100`
        Add *Var[5] 3
EndSwitch
% read current trap
Switch *Var[B]
    Case == 0 % Block - Super Hammer
        Add *Var[5] 2
    Case == 1 % Block - Ultra Hammer
        Add *Var[5] 2
    Case == 2 % Spring - Super Boots
        Add *Var[5] 2
    Case == 3 % ? Switch - Ultra Boots
        Add *Var[5] 2
    Case == 4 % Switch - Kooper 1
        Add *Var[5] 2
    Case == 5 % Switch - Kooper 2
        Add *Var[5] 2
    Case == 6 % Grab Item - Kooper Only
        Add *Var[5] 2
    Case == 7 % Grab Item - Kooper and Parakarry
        Add *Var[5] 1
    Case == 8 % Rocks - Bombette
        Add *Var[5] 2
    %Case == 9 % Switches - Bombette % unused
    Case == 10` % Gaps - Parakarry
        Add *Var[5] 2
    Case == 11` % Spikes - Bow and Lakilester
        Add *Var[5] 1
    Case == 12` % Water Gaps - Sushie
        Add *Var[5] 2
    Case == 13` % Spikes - Lakilester Only
        Add *Var[5] 2
    Case == 14` % Spring - Goombario Only
        Add *Var[5] 2
    %Case == 15` % Spring - Bow Based % unused
    Case == 16` % Spring - Watt Only
        Add *Var[5] 2
    Case == 17` % Springs - Keys Based
        % unfinished
        Add *Var[5] 0
    Case == 18` % Springs - Battle Based
        % this trap spawn the NPC accordingly to the item spawned
        /%ExecWait $Script_Reward_ReadSpringkeeper % uses Exec, sometimes doesn't load the reward when using ExecWait (why o.o?!)
        %Wait 2
        Add *Var[5] *Var[0]%/
EndSwitch
% Get RNG Bonus
Call    RandInt ( 100` *Var[0] )
Switch *Var[0]
    Case < 50` % 50%
        Call    RandInt ( 2 *Var[0] )
    Case < 80` % 30%
        Call    RandInt ( 3 *Var[0] )
    %Case < 95` % 15%
    %    Call    RandInt ( 4 *Var[0] )
    Case > 80` % 20%
        Call    RandInt ( 6 *Var[0] )
EndSwitch
% According to Var[5] spawn the reward - the highest the better the reward will be
Add     *Var[5] *Var[0] % add RNG bonus
Set     *MapVar[F] *Var[5] % save final value in mapvar[F]
Jump $Script_SpawnRewards_Main
Return
End
}

% It reads the reward data from $Script_InitReward and spawns the reward
#new:Script:Map $Script_SpawnRewards_Main
{
Call $Function_Reward_GetDataX
Call   RandInt ( 4 *Var[5] ) % Bonus RNG 2
Add   *MapVar[F] *Var[5]
%Set   *MapVar[F] 6` % testing
Switch *MapVar[F]
    Case <= 2 % Item
        Jump $Script_Reward_SpawnItem
    Case <= 4 % Badge % was Badge or Items but got changed to only Badges
        % Check if Mario already have all badges
        ExecWait $Script_Reward_Badges_CheckAllFlags
        If *Var[1] >= 60` % All Badges
            Jump $Script_Reward_SpawnItem
        EndIf
        Jump $Script_Reward_SpawnBadge
    Case <= 6 % Badge or Chest
        Call    RandInt ( 2 *Var[5] )
        %Set *Var[5] 2 % testing stuff
        If *Var[5] <= 1 % Badge - 66%
            % Check if Mario already have all badges
            ExecWait $Script_Reward_Badges_CheckAllFlags
            If *Var[1] == 60` % All Badges
                % If yes spawn an item instead
                Jump $Script_Reward_SpawnItem
            EndIf
            Jump $Script_Reward_SpawnBadge
        Else % Chest - 33%
            % Check if the current trap is compatible with the Giant Chest
            Switch *Var[B] % Trap ID
                CaseOR == 3 % ? Switch - Ultra Boots
                CaseOR == 4 % Switch - Kooper 1
                CaseOR == 5 % Switch - Kooper 2
                CaseOR == 6 % Grab Item - Kooper Only
                CaseOR == 7 % Grab Item - Kooper and Parakarry
                    Set  *MapVar[F] .False % reset all "better reward" points
                    Jump $Script_SpawnRewards_Main
                EndCaseGroup
            EndSwitch
            Call    MakeEntity ( .Entity:Chest 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1 
            Call    AssignScript 	( $Script_Reward_Chest_Main )
            %% Set Reward and Lock vars
            Call    $Function_Reward_GetDataX
            Call    RandInt ( 1 *Var[E] )
            Set     *Var[D] 1
            Add     *Var[D] *Var[E]
            Call    $Function_Save_RewardData ( *Var[D] )
            ExecWait $Script_Entity_AdjustSpringTrap
            ExecWait $Script_Rogue_Entities_SetSpawn_Chests
        EndIf
    Case <= 9 % Ultra Boots/Hammer, Super Block, Max HP/FP
        ExecWait $Script_SpawnRewards_OnlyUpgrades
    Case >= 10` % Ultra Boots/Hammer
        % If a GiantChest has been already spawned
        If .Flag_GiantChestSpawned == .True
            Label CheckSuperBlock
            % Check if a Super Block can be spawned instead
            Call    $Function_CheckPartnersUpgrades
            If  *Var[0] == -1` % nope
                Jump $Script_SpawnRewards_OnlyUpgrades
            EndIf
            % Check if the current trap is compatible with the super block
            Call    $Function_Reward_GetDataX % save in varA/B/C
            Switch *Var[B] % Trap ID
                CaseOR ==  3 % ? Switch - Ultra Boots
                CaseOR ==  4 % Switch - Kooper 1
                CaseOR ==  5 % Switch - Kooper 2
                CaseOR ==  6 % Grab Item - Kooper Only
                CaseOR ==  7 % Grab Item - Kooper and Parakarry
                    Set  *MapVar[F] .False % reset all "better reward" points
                    Jump $Script_SpawnRewards_Main
                EndCaseGroup
            EndSwitch
            Jump $Script_Reward_Spawn_SuperBlock
        EndIf
        % Check if Mario is already fully upgraded
        Call $Function_GetHammer % save in var3
        Set *Var[4] *Var[3]
        Call $Function_GetBoots % save in var3
        Add *Var[3] *Var[4]
        If *Var[3] == 4
            % check if a super block can be spawned instead
            Wait 1
            Goto CheckSuperBlock
        EndIf
        % Check if the current trap is compatible with the Giant Chest
        Call    $Function_Reward_GetDataX % save in varA/B/C
        Switch *Var[B] % Trap ID
            CaseOR == 3 % ? Switch - Ultra Boots
            CaseOR == 4 % Switch - Kooper 1
            CaseOR == 5 % Switch - Kooper 2
            CaseOR == 6 % Grab Item - Kooper Only
            CaseOR == 7 % Grab Item - Kooper and Parakarry
                % check if a super block can be spawned instead
                Wait 1
                Goto CheckSuperBlock
            EndCaseGroup
        EndSwitch
        ExecWait $Script_Reward_Spawn_GiantChest
EndSwitch
Return
End
}

#new:Script:Map $Script_Padlock_Reformat_Keys
{
% format varD
Switch *Var[D]
    Case <= 1
        Set *Var[D] 1
    Case == 2
        Set *Var[D] 2
    Case == 3
        Set *Var[D] 4
    Case >= 4
        Set *Var[D] 6
EndSwitch
Set     *Var[5] *PitMapID
Div     *Var[5] 20`
Add     *Var[D] *Var[5] % div current floor by 2 and add it
Call     $Function_SaveLockVar % read from VarD
ExecWait $Script_SetLockAmount
Return
End
}

#new:Script:Map $Script_Padlock_Reformat_Coins
{
% format varD
Switch *Var[D]
    Case <= 1 % Tier 1 Reward
        Switch *PitMapID
            Case < 10`
                Set *Var[D] 10`
            Case < 20`
                Set *Var[D] 20`
            Case < 30`
                Set *Var[D] 40`
            Case < 40`
                Set *Var[D] 80`
            Case < 50`
                Set *Var[D] 100`
            Case < 60`
                Set *Var[D] 140`
            Case < 70`
                Set *Var[D] 180`
            Case < 80`
                Set *Var[D] 220`
            Case < 90`
                Set *Var[D] 250`
            Case < 100`
                Set *Var[D] 260`
        EndSwitch
    Case == 2 % Tier 2 Reward
        Switch *PitMapID
            Case < 10`
                Set *Var[D] 15`
            Case < 20`
                Set *Var[D] 30`
            Case < 30`
                Set *Var[D] 60`
            Case < 40`
                Set *Var[D] 100`
            Case < 50`
                Set *Var[D] 140`
            Case < 60`
                Set *Var[D] 180`
            Case < 70`
                Set *Var[D] 220`
            Case < 80`
                Set *Var[D] 250`
            Case < 90`
                Set *Var[D] 300`
            Case < 100`
                Set *Var[D] 320`
        EndSwitch
    Case == 3 % Tier 3 Reward
        Switch *PitMapID
            Case < 10`
                Set *Var[D] 25`
            Case < 20`
                Set *Var[D] 50`
            Case < 30`
                Set *Var[D] 100`
            Case < 40`
                Set *Var[D] 170`
            Case < 50`
                Set *Var[D] 200`
            Case < 60`
                Set *Var[D] 240`
            Case < 70`
                Set *Var[D] 290`
            Case < 80`
                Set *Var[D] 360`
            Case < 90`
                Set *Var[D] 400`
            Case < 100`
                Set *Var[D] 420`
        EndSwitch
    Case >= 4 % Tier 4 Reward
        Switch *PitMapID
            Case < 10`
                Set *Var[D] 40`
            Case < 20`
                Set *Var[D] 70`
            Case < 30`
                Set *Var[D] 150`
            Case < 40`
                Set *Var[D] 220`
            Case < 50`
                Set *Var[D] 280`
            Case < 60`
                Set *Var[D] 300`
            Case < 70`
                Set *Var[D] 380`
            Case < 80`
                Set *Var[D] 430`
            Case < 90`
                Set *Var[D] 500`
            Case < 100`
                Set *Var[D] 520`
        EndSwitch
EndSwitch
Set     *Var[5] *PitMapID
Div     *Var[5] 2
Add     *Var[D] *Var[5] % div current floor by 2 and add it
Call     $Function_SaveLockVar % read from VarD
ExecWait $Script_SetLockAmount
Return
End
}

#new:Script:Map $Script_Padlock_Reformat_HP
{
% format varD
Switch *Var[D]
    Case <= 1
        Switch *PitMapID
            Case < 10`
                Set *Var[D] 3
            Case < 20`
                Set *Var[D] 3
            Case < 30`
                Set *Var[D] 5
            Case < 40`
                Set *Var[D] 5
            Case < 50`
                Set *Var[D] 6
            Case < 60`
                Set *Var[D] 6
            Case < 70`
                Set *Var[D] 7
            Case < 80`
                Set *Var[D] 7
            Case < 90`
                Set *Var[D] 7
            Case < 100`
                Set *Var[D] 7
        EndSwitch
    Case == 2
        Switch *PitMapID
            Case < 10`
                Set *Var[D] 5
            Case < 20`
                Set *Var[D] 5
            Case < 30`
                Set *Var[D] 5
            Case < 40`
                Set *Var[D] 6
            Case < 50`
                Set *Var[D] 6
            Case < 60`
                Set *Var[D] 7
            Case < 70`
                Set *Var[D] 7
            Case < 80`
                Set *Var[D] 8
            Case < 90`
                Set *Var[D] 10`
            Case < 100`
                Set *Var[D] 10`
        EndSwitch
    Case == 3
        Switch *PitMapID
            Case < 10`
                Set *Var[D] 10`
            Case < 20`
                Set *Var[D] 10`
            Case < 30`
                Set *Var[D] 10`
            Case < 40`
                Set *Var[D] 10`
            Case < 50`
                Set *Var[D] 13`
            Case < 60`
                Set *Var[D] 13`
            Case < 70`
                Set *Var[D] 13`
            Case < 80`
                Set *Var[D] 15`
            Case < 90`
                Set *Var[D] 15`
            Case < 100`
                Set *Var[D] 15`
        EndSwitch
    Case >= 4
        Switch *PitMapID
            Case < 10`
                Set *Var[D] 15`
            Case < 20`
                Set *Var[D] 20`
            Case < 30`
                Set *Var[D] 20`
            Case < 40`
                Set *Var[D] 20`
            Case < 50`
                Set *Var[D] 23`
            Case < 60`
                Set *Var[D] 23`
            Case < 70`
                Set *Var[D] 23`
            Case < 80`
                Set *Var[D] 25`
            Case < 90`
                Set *Var[D] 25`
            Case < 100`
                Set *Var[D] 25`
        EndSwitch
EndSwitch
Call     $Function_SaveLockVar % read from VarD
ExecWait $Script_SetLockAmount
Return
End
}

% Spawn a reward
% Only spawn things like HP/FP Upgrades, Hammer/Boots upgrades and Partners upgrades
#new:Script:Map $Script_SpawnRewards_OnlyUpgrades
{
% If the player have already 50HP, 50FP and all upgrades for
% Mario and Partners just spawn an item
Call    $ReadAddress ( 8010F290 0 *Var[1] 3 .False ) % Max HP
Call    $ReadAddress ( 8010F290 0 *Var[2] 6 .False ) % Max FP
Add *Var[1] *Var[2]
If *Var[1] >= 100`
    % Check if any partner is available to be upgraded
    Call    $Function_CheckPartnersUpgrades
    If  *Var[0] == -1 % nope
        % Check Player upgrades
        Call    $ReadAddress ( 8010F290 0 *Var[1] 0 .False ) % Boots
        Call    $ReadAddress ( 8010F290 0 *Var[2] 1 .False ) % Hammer
        Add *Var[1] *Var[2]
        If *Var[1] >= 4
            % Just spawn an item instead
            Jump $Script_Reward_SpawnItem
        EndIf
    EndIf
EndIf
Call RandInt ( 3 *Var[0] ) % get reward
%Set *Var[0] 2 % testing stuff
Switch *Var[0]
    Case == 0 % Max FP
        % Check if the player have max FP
        Call    $ReadAddress ( 8010F290 0 *Var[1] 6 .False ) % Max FP
        If *Var[1] >= 75`
            Jump $Script_SpawnRewards_OnlyUpgrades
        EndIf
        % Check if the player already have enough HP/FP
        Call    $ReadAddress ( 8010F290 0 *Var[1] 3 .False ) % Max HP
        Call    $ReadAddress ( 8010F290 0 *Var[2] 6 .False ) % Max FP
        Add *Var[1] *Var[2]
        If *Var[1] >= 100`
            Jump $Script_SpawnRewards_OnlyUpgrades
        EndIf
        Set     *Var[0] .Item:AttackFXA % Silver Flower
        Set     *Var[2] .False % itemFlag
        Call    $Function_Reward_GetDataX % save in VarA/B/C
        % save rarity var for current reward
        Set     *Var[D] 3
        Call    $Function_Save_RewardData ( *Var[D] )
        ExecWait $Script_Entity_AdjustSpringTrap
        ExecWait $Script_Reward_SetItemPos
    Case == 1 % Max HP
        % Check if the player have max HP
        Call    $ReadAddress ( 8010F290 0 *Var[1] 3 .False ) % Max HP
        If *Var[1] >= 75`
            Jump $Script_SpawnRewards_OnlyUpgrades
        EndIf
        % Check if the player already have enough HP/FP
        Call    $ReadAddress ( 8010F290 0 *Var[1] 3 .False ) % Max HP
        Call    $ReadAddress ( 8010F290 0 *Var[2] 6 .False ) % Max FP
        Add *Var[1] *Var[2]
        If *Var[1] >= 100`
            Jump $Script_SpawnRewards_OnlyUpgrades
        EndIf
        Set     *Var[0] .Item:AttackFXD % Silver Heart
        Set     *Var[2] .False % itemFlag
        Call    $Function_Reward_GetDataX
        % save rarity var for current reward
        Set     *Var[D] 3
        Call    $Function_Save_RewardData ( *Var[D] )
        ExecWait $Script_Entity_AdjustSpringTrap
        ExecWait $Script_Reward_SetItemPos
    Case == 2 % Super Block
        % Check if any partner is available to be upgraded
        Call    $Function_CheckPartnersUpgrades
        If  *Var[0] == -1` % nope
            Jump $Script_SpawnRewards_OnlyUpgrades
        EndIf
        % Check if the current trap is compatible with the super block
        Call    $Function_Reward_GetDataX % save in varA/B/C
        Switch *Var[B] % Trap ID
            CaseOR ==  3 % ? Switch - Ultra Boots
            CaseOR ==  4 % Switch - Kooper 1
            CaseOR ==  5 % Switch - Kooper 2
            CaseOR ==  6 % Grab Item - Kooper Only
            CaseOR ==  7 % Grab Item - Kooper and Parakarry
                Set  *MapVar[F] .False % reset all "better reward" points
                Jump $Script_SpawnRewards_Main
            EndCaseGroup
        EndSwitch
        Jump $Script_Reward_Spawn_SuperBlock
    Case == 3 % Super/Ultra Boots/Hammer
        % If a GiantChest has been already spawned
        If .Flag_GiantChestSpawned == .True
            Jump $Script_SpawnRewards_OnlyUpgrades
        EndIf
        % Check if is already fully upgraded
        Call $Function_GetHammer % save in var3
        Set *Var[4] *Var[3]
        Call $Function_GetBoots % save in var3
        Add *Var[3] *Var[4]
        If *Var[3] == 4
            Jump $Script_SpawnRewards_OnlyUpgrades
        EndIf
        % Check if the current trap is compatible with the Giant Chest,
            % if not spawn a HP/FP Plus instead
        Call    $Function_Reward_GetDataX % save in varA/B/C
        Switch *Var[B] % Trap ID
            CaseOR == 3 % ? Switch - Ultra Boots
            CaseOR == 4 % Switch - Kooper 1
            CaseOR == 5 % Switch - Kooper 2
            CaseOR == 6 % Grab Item - Kooper Only
            CaseOR == 7 % Grab Item - Kooper and Parakarry
                Set  *MapVar[F] .False % reset all "better reward" points
                Jump $Script_SpawnRewards_Main
            EndCaseGroup
        EndSwitch
        ExecWait $Script_Reward_Spawn_GiantChest
EndSwitch
Return
End
}

#new:Script:Map $Script_Reward_Spawn_SuperBlock
{
Call     MakeEntity  	( .Entity:SuperBlock 00000000 00000000 00000000 00000000 80000000 ) % ~Vec4d:Rogue_Entity1 
Call    $ReadAddress ( $Reward_SuperBlock_Data1 0 *Var[5] 1 .False )
% Set Flag
If *Var[5] == 1
    Call     AssignBlockFlag 	( .Flag_SuperBlock1 )
Else
    Call     AssignBlockFlag 	( .Flag_SuperBlock2 )
EndIf
Call     AssignScript 	( $Script_SuperBlock_Main )
Call    $Function_GetSuperBlocksData1 % save in Var5/6/7
Call    $Function_Reward_GetDataX % save in varA/B/C
/%
Var5=FlagID
Var6=EntityID
Var7=RewardSpawnPoint
%/
% Data1 has been already used?
If  *Var[5] == 0
    Set *Var[5] 1 % Set SuperBlockID
    Set *Var[6] *Var[0] % Set Entity ID
    Set *Var[7] *Var[A] % Set Reward Spawn Point
    Call   $Function_WriteSuperBlocksData1
Else
% Use data2
    Set *Var[5] 2 % Set SuperBlockID
    Set *Var[6] *Var[0] % Set Entity ID
    Set *Var[7] *Var[A] % Set Reward Spawn Point
    Call   $Function_WriteSuperBlocksData2
EndIf
ExecWait $Script_Rogue_Entities_SetSpawn_SuperBlock
% var9=EntityIndex
Call    $Function_Reward_GetDataX
% save rarity var for current reward
Set     *Var[D] 3
Call    $Function_Save_RewardData ( *Var[D] )
ExecWait $Script_Entity_AdjustSpringTrap
Return
End
}

#new:Script:Map $Script_Reward_Spawn_GiantChest
{
Set     .Flag_GiantChestSpawned .True
% Get upgrade to put inside the chest
Call    RandInt ( 1 *Var[2] )
If *Var[2] == 0 % Boots
    Label Boots
    Call $Function_GetBoots % save in var3
    Switch *Var[3]
        Case == .Default
            Set *Var[5] .Item:SpinJump
        Case == 1
            Set *Var[5] .Item:TornadoJump
        Case == 2
            Wait 1
            Goto Hammer
    EndSwitch
Else
    Label Hammer
    Call $Function_GetHammer % save in var3
    Switch *Var[3]
        Case == .Default
            Set *Var[5] .Item:SuperHammer
        Case == 1
            Set *Var[5] .Item:UltraHammer
        Case == 2
            Wait 1
            Goto Boots
    EndSwitch
EndIf
Call     MakeEntity 	( .Entity:GiantChest 00000000 00000000 00000000 00000000 *Var[5] 80000000 ) % ~Vec4d:Rogue_Entity1 
Call     AssignFlag  	( .Flag_GiantChest )
Exec     $Script_GiantChest_Main
ExecWait $Script_Rogue_Entities_SetSpawn_Chests
Call    $Function_WriteGiantChestID
Call    $Function_Reward_GetDataX % save in varA/B/C
% The chest is in moving spikes trap?
If *Var[B] == 11` % Spikes - Bow and Lakilester
    Set .Flag_GiantChestParentToSpikes .True
EndIf
ExecWait $Script_RotateChest
% save rarity var for current reward
Set     *Var[D] 4
Call    $Function_Save_RewardData ( *Var[D] )
ExecWait $Script_Entity_AdjustSpringTrap
Return
End
}

% set the yaw of the giant chest by reading the current trap, spawn point and spawn side
#new:Script:Map $Script_RotateChest
{
Call $Function_ReadGiantChestID % save ID in var9
Call $GetEntityRotation     ( *Var[9] *Var[0] *Var[1] *Var[2] ) %entityID, xyz
Call $Function_GetRewardYaw ( 2 *Var[3] )
Switch *Var[3]
    Case == .Down % 0 % unnecessary
        SetF *Var[1] *Fixed[0.000000] % Down / Default%/
    Case == .Up % 1
        SetF *Var[1] *Fixed[-180.000000] % Up
    Case == .Right % 2
        SetF *Var[1] *Fixed[90.000000] % Right
    Case == .Left % 3
        SetF *Var[1] *Fixed[-90.000000] % Left
EndSwitch
Call $SetEntityRotation     ( *Var[9] *Var[0] *Var[1] *Var[2] )
Return
End
}

#new:Function $Function_WriteGiantChestID % read from var9
{
PUSH	RA, V0, A1, A2
LIO 	A1, *Var[9] % entityID
JAL 	~Func:get_variable 
RESERVED
SAB     V0, $Data_Reward_GiantChestID
LIO 	A1, *Var[5] % itemID
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Data_Reward_GiantChestID
SB      V0, 1 (T0)
JPOP    RA, V0, A1, A2
}

#new:Function $Function_ReadGiantChestID % save in var9
{
PUSH	RA, V0, A1, A2
LABU    A2, $Data_Reward_GiantChestID
LIO 	A1, *Var[9]
JAL 	~Func:set_variable
RESERVED
LIO     T0, $Data_Reward_GiantChestID
LBU     A2, 1 (T0)
LIO 	A1, *Var[A]
JAL 	~Func:set_variable
RESERVED
JPOP	RA, V0, A1, A2
}

#new:Function $Function_WriteRewardYaw % arg0=GetYawID(0/1/2) , arg1=newYaw Value
{
/%
0 = Yaw1
1 = Yaw2
2 = YawX
%/
PUSH    RA, A0, A1, A2, A3
LW     A1, C (A0) % Load Args pointer
LW     A2, 0 (A1) % load arg0
LW     A3, 4 (A1) % load arg1
LIO     T0, $Data_GiantChestYaw
ADDU    T0, T0, A2 % get YawID to overwrite
SB      A3, 0 (T0)
JPOP    RA, A0, A1, A2, A3
}

% the same but when the arg1 value is from a Var
% I know can be fused in a single function, but.... whatever :D
#new:Function $Function_WriteRewardYawVar % arg0=GetYawID(0/1/2) , arg1=newYaw Value need to be readed from a var
{
PUSH    RA, A0, A1, S0, V0
LW     A1, C (A0) % Load Args pointer
LW     S0, 0 (A1) % load arg0
JAL     ~Func:get_variable
LW     A1, 4 (A1) % load arg1
LIO     T0, $Data_GiantChestYaw
ADDU    T0, T0, S0 % get YawID to overwrite
SB      V0, 0 (T0)
JPOP    RA, A0, A1, S0, V0
}

#new:Function $Function_GetRewardYaw % arg0=GetYawID(0/1/2) , arg1=output
{
/%
0 = Yaw1
1 = Yaw2
2 = YawX
%/
PUSH    RA, A0, A1, A2, A3, V0
LW     T0, C (A0) % Load Args pointer
LW     T1, 0 (T0) % load YawID
LIO     T2, $Data_GiantChestYaw
ADDU    T2, T2, T1 % get YawID to load
LBU     A2, 0 (T2) % save value from yawID in A1
JAL     ~Func:set_variable
LW     A1, 4 (T0) % load arg1
JPOP    RA, A0, A1, A2, A3, V0
}

#new:Script:Map $Script_GiantChest_Main
{
If  .Flag_GiantChest  ==  .False
    Loop
        Wait 1
        If  .Flag_GiantChest  ==  .True
            BreakLoop
        EndIf
    EndLoop
    SetGroup 0
    SuspendAll 2
    Set     .Flag_GiantChestOpened .True
    Wait     60`
    Call     802D5FF8 ( 42 1 ) % Play Music
    % Stop the spikes if the trap for the chest was moving spikes
    Call    $Function_ReadGiantChestID % save in var9/A
    Switch *Var[A]
        Case == .Item:SpinJump
            Call    ShowMessageAtScreenPos 	( 001D0180 A0 28 ) % Super Boots
        Case == .Item:TornadoJump
            Call    ShowMessageAtScreenPos 	( 001D0187 A0 28 ) % Ultra Boots
        Case == .Item:SuperHammer
            Call    ShowMessageAtScreenPos 	( 001D017D A0 28 ) % Super Hammer
        Case == .Item:UltraHammer
            Call    ShowMessageAtScreenPos 	( 001D0186 A0 28 ) % Ultra Hammer
    EndSwitch
    Call    $Function_GiantChest_EnableInputs ( *Var[9] ) % EntityID
    Call     802D5FD8 % Stop Music
    Set     .Flag_GiantChest .False
    ResumeAll 2
EndIf
Return
End
}

    #new:Function $Function_GiantChest_EnableInputs
{
    ADDIU		SP, SP, FFE8
    SW			RA, 10 (SP)
    LW         A1, C (A0) % load ID from arg1
    JAL         ~Func:get_variable 
    LW         A1, 0 (A1)
    JAL			~Func:get_entity_by_index
    COPY        A0, V0
    LW			A0, 84 (A0)
    LW			A0, 40 (V0)
    ADDIU		V1, R0, 1
    SB			V1, 30 (A0)
    LW			RA, 10 (SP)
    ADDIU		V0, R0, 2
    JR			RA
    ADDIU		SP, SP, 18
}

#new:Function $ShowStatusBar
{
    SAB    R0, 8010EF92 % Stats Bar State, 00=Active / 01=Inactive
    JR     RA
    NOP
}

% Patch ShowGotItem
% Show "You got some keys" instead of "You got some coins"
% if the current item is .Item:FortressKey (0x0010)
@Hook CCEF4 % 801367F4
{
    PUSH    T0, T1
    LHU	    T0, 0018 (S1) % load itemID
    ORI     T1, R0, 0010 % .Item:FortressKey
    BNE     T0, T1, .LoadCoinsMessage
    NOP
    .LoadKeysMessage
    LIO     S0, 001D01AB
    BEQ     R0, R0, .End
    RESERVED
    .LoadCoinsMessage
    LIO     S0, 001D005D
    .End
    POP     T0, T1
    J       801367FC
    NOP
}

% Small Chests Main Script
#new:Script:Map $Script_Reward_Chest_Main
{
SetGroup 0
SuspendAll 2
% Give Coins or Keys?
Call    RandInt ( 1 *Var[0] )
%Set *Var[0] 0 % testing
If  *Var[0] == 0 % Keys
    Call    ShowGotItem ( .Item:FortressKey .True 00000010 )
    Call    $WriteAddress ( 8010EF90 2 00000001 0 .False ) % Force status menu to appear
    Wait    10`
    Call    RandInt ( 5 *Var[0] )
    Set *Var[1] 2
    Add *Var[1] *Var[0]
    Loop *Var[1]
        If *Rogue_Keys == FFFFFFFF % Max Keys Amount (Global Bytes are readed as signed)
            BreakLoop
        EndIf
        Wait    4
        Add     *Rogue_Keys 1
        Call    PlaySound ( 2099 ) % was 0215
    EndLoop
Else % Coins
    Call    ShowGotItem ( .Item:Coin .True 00000010 ) % you got some coins
    Call    $WriteAddress ( 8010EF90 2 00000001 0 .False ) % Force status menu to appear
    Call    RandInt ( 100` *Var[0] )
    Switch  *Var[0]
        Case <= 20` % 20%
            Call    AddCoin ( 100` )
        Case <= 80` % 60%
            Call    AddCoin ( 150` )
        Case <= 95` % 15%
            Call    AddCoin ( 200` )
        Case <= 100` % 5%
            Call    AddCoin ( 400` )
    EndSwitch
    Loop 3
        Call    PlaySound ( 0211 ) % coin
        Wait    2
    EndLoop
EndIf
ResumeAll 2
Return
End
}

% *out var5/6/7
#new:Function $Function_GetSuperBlocksData1
{
PUSH	RA, V0, A1, A2
LIO     A2, $Reward_SuperBlock_Data1
LBU     A2, 1 (A2)
LIO 	A1, *Var[5] % FlagID
JAL 	~Func:set_variable
RESERVED
LIO     A2, $Reward_SuperBlock_Data1
LBU     A2, 2 (A2)
LIO 	A1, *Var[6] % Entity ID
JAL 	~Func:set_variable
RESERVED
LIO     A2, $Reward_SuperBlock_Data1
LBU     A2, 3 (A2)
LIO 	A1, *Var[7] % Reward Spawn Point
JAL 	~Func:set_variable
RESERVED
JPOP	RA, V0, A1, A2
}

% *out var5/6/7
#new:Function $Function_GetSuperBlocksData2
{
PUSH	RA, V0, A1, A2
LIO     A2, $Reward_SuperBlock_Data2
LBU     A2, 1 (A2)
LIO 	A1, *Var[5] % FlagID
JAL 	~Func:set_variable
RESERVED
LIO     A2, $Reward_SuperBlock_Data2
LBU     A2, 2 (A2)
LIO 	A1, *Var[6] % Entity ID
JAL 	~Func:set_variable
RESERVED
LIO     A2, $Reward_SuperBlock_Data2
LBU     A2, 3 (A2)
LIO 	A1, *Var[7] % Reward Spawn Point
JAL 	~Func:set_variable
RESERVED
JPOP	RA, V0, A1, A2
}

% reads var5/6/7
#new:Function $Function_WriteSuperBlocksData1
{
PUSH	RA, V0, A1, A2
LIO 	A1, *Var[5] % FlagID
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Reward_SuperBlock_Data1
SB      V0, 1 (T0)
LIO 	A1, *Var[6] % Entity ID
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Reward_SuperBlock_Data1
SB      V0, 2 (T0)
LIO 	A1, *Var[7] % Reward Spawn Point
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Reward_SuperBlock_Data1
SB      V0, 3 (T0)
POP     RA, V0, A1, A2
JR      RA
ADDIU   V0, R0, 2
}

% reads var5/6/7
#new:Function $Function_WriteSuperBlocksData2
{
PUSH	RA, V0, A1, A2
LIO 	A1, *Var[5] % FlagID
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Reward_SuperBlock_Data2
SB      V0, 1 (T0)
LIO 	A1, *Var[6] % Entity ID
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Reward_SuperBlock_Data2
SB      V0, 2 (T0)
LIO 	A1, *Var[7] % Reward Spawn Point
JAL 	~Func:get_variable 
RESERVED
LIO     T0, $Reward_SuperBlock_Data2
SB      V0, 3 (T0)
POP     RA, V0, A1, A2
JR      RA
ADDIU   V0, R0, 2
}

#new:Script:Map $Script_SuperBlock_Main
{
    % Check what Super Block data you need to use
    /%
    Var5=FlagID
    Var6=EntityID
    Var7=RewardSpawnPoint
    %/
    Call    $Function_GetSuperBlocksData2 % save in var5/6/7
    Set     *Var[8] *Var[5]
    Set     *Var[9] *Var[6]
    Set     *Var[A] *Var[7]
    Call    $Function_GetSuperBlocksData1 % save in var5/6/7
    Call     GetPlayerPos 	( *Var[0] *Var[1] *Var[2] )
    If  *Var[0] < -534`
        If *Var[2] < 78` % 1 % Top Left
            % Is saved in Data1?
            If *Var[7] == 1
                Set *Var[0] 1
            Else
            % Is saved in Data2 then
                Set *Var[0] 2
            EndIf
        Else % 4 % Bottom Left
            % Is saved in Data1?
            If *Var[7] == 4
                Set *Var[0] 1
            Else
            % Is saved in Data2 then
                Set *Var[0] 2
            EndIf
        EndIf
    Else
    % Mario is on the right side of the room
        If *Var[2] < 78` % 2 % Top Right
            % Is saved in Data1?
            If *Var[7] == 2
                Set *Var[0] 1
            Else
            % Is saved in Data2 then
                Set *Var[0] 2
            EndIf
        Else % 3 % Bottom Right
            % Is saved in Data1?
            If *Var[7] == 3
                Set *Var[0] 1
            Else
            % Is saved in Data2 then
                Set *Var[0] 2
            EndIf
        EndIf
    EndIf
    %% Load correct data and save in DataX %%
    If  *Var[0] == 1 % use data1
        Set *Var[4] *Var[5] % Flag ID
        Set *Var[5] *Var[6] % Entity ID
        Set *Var[6] *Var[7] % Reward Spawn Point
    Else % use data2
        Set *Var[4] *Var[8] % Flag ID
        Set *Var[5] *Var[9] % Entity ID
        Set *Var[6] *Var[A] % Reward Spawn Point
    EndIf
    Call    $Function_Reward_WriteDataX_Alt % write from Var4/5/6, the word get saved like this AAAABBCC
    If  *Var[4] == 1
        % Data1
        If  .Flag_SuperBlock1  ==  .True
            Return
        EndIf
    Else
        % Data2
        If  .Flag_SuperBlock2  ==  .True
            Return
        EndIf
    EndIf
    Call     800441F0 ( *Var[0] )
    If  *Var[0]  ==  1
        Return
    EndIf
    Call     $Function_802430D8
    If  *Var[0]  ==  1
        Return
    EndIf
    SetGroup 0
    SuspendAll 2
    Call     802D585C ( .True 00200000 )
    Call     $Function_802423D0
    Call     DisablePlayerInput 	( .True )
    Call     DisablePartnerAI 	( 0 )
    Call     SetNpcFlagBits ( .Npc:Partner 00000100 .True )
    Call     $Function_80242850 ( *Var[5] *Var[9] ) % varB=Entity ID
    Call     FindKeyItem 	( .Item:UltraStone *Var[C] )
    Set		*Var[C] .True 		% Bypass Ultra Stone check
    Call     $Function_CheckAvailability
    If  *Var[0]  ==  FFFFFFFF 
        Call     ShowMessageAtScreenPos 	( 001D00DC 000000A0 00000028 ) % You have no member you can upgrade now.
        Wait     10`
        Call     $Function_802428E0 ( *Var[9] )
        Call     DisablePlayerInput 	( .False )
        Call     EnablePartnerAI
        Call     802D585C ( .False 00200000 )
        Call     $Function_802423EC
        ResumeAll 2
        Return
    EndIf
    Call     $Function_OpenPartnersList
    If  *Var[0]  ==  -1 
        Call     $Function_802428E0 ( *Var[9] )
        Call     DisablePlayerInput 	( .False )
        Call     EnablePartnerAI
        Call     802D585C ( .False 00200000 )
        Call     $Function_802423EC
        ResumeAll 2
        Return
    EndIf
    Set  *Var[A]  *Var[0] 
    Set  *Var[B]  *Var[1] 
    Call     EnablePartnerAI
    Call     GetCurrentPartnerID 	( *Var[0] )
    If  *Var[0]  !=  *Var[B] 
        Call     $Function_802427EC ( *Var[B] )
    Else
        Call     802CF56C ( 2 )
    EndIf
    Wait     10`
    Call     ShowMessageAtScreenPos 	( 001D00DF 000000A0 00000028 ) % Do you want to upgrade this member? 
    Call     ShowChoice  	( 001E000D ) % Yes No 
    Call     802D0A98
    If  *Var[0]  !=  0
        Call     $Function_802428E0 ( *Var[9] )
        Call     DisablePlayerInput	( .False )
        Call     EnablePartnerAI
        Call     802D585C ( .False 00200000 )
        Call     $Function_802423EC
        ResumeAll 2
        Return
    EndIf
    ExecWait $Script_80243D94 
    Call     $Function_80242438 ( *Var[B] *Var[D] )
    Call    $Function_Reward_GetDataX_Alt % save in Var4/5/6
    If  *Var[4] == 1
        Set  .Flag_SuperBlock1 .True
    Else
        Set  .Flag_SuperBlock2 .True
    EndIf
    Call     $Function_802428E0 ( *Var[9] )
    Call     $Function_80242818
    If  *Var[D]  ==  1
        Call     ShowMessageAtScreenPos 	( 001D00DD 000000A0 00000028 ) %  is upgraded to Super-rank!
    Else
        Call     ShowMessageAtScreenPos 	( 001D00DE 000000A0 00000028 ) %  is upgraded to Ultra-rank!
    EndIf
    Call     DisablePlayerInput 	( .False )
    Call     EnablePartnerAI
    Call     802D585C ( .False 00200000 )
    Call     $Function_802423EC
    ResumeAll 2
    Return
    End
}

  #new:Script:Map $Script_80243D94
{
    0:  Wait     10`
    C:  Call     PlaySound   	( 212D )
        Call    $Function_Reward_GetDataX_Alt % save in Var4/5/6
   1C:  Call    $Function_80242914 ( *Var[5] )
   2C:  Wait     55
   38:  Thread
   40:  	Call     PlaySound   	( 212E )
   50:  	Call     $Function_80242F08 ( 46 46 )
   64:  	Wait     0000001B 
   70:  	Call     PlaySound   	( 208E )
   80:  	Call     $Function_80242F08 ( 32 32 )
   94:  EndThread
   9C:  Thread
   A4:  	Wait     3
   B0:  	Call     $Function_8024240C ( *Var[5] )
   C0:  EndThread
   C8:  Thread
   D0:  	Wait     2F 
   DC:  	Call     $Function_80242978
   E8:  	Call     $Function_80243048
   F4:  	Wait     5
  100:  	Call     $Function_80243090
  10C:  	Wait     5
  118:  	Call     $Function_80243048
  124:  EndThread
  12C:  Wait     3
  138:  Call     $Function_802429D0 ( *Var[5] )
  148:  Wait     1E 
  154:  Return
  15C:  End
}

  #new:Function $Function_80242914
{
    0:  ADDIU		SP, SP, FFE0
    4:  SW			RA, 18 (SP)
    8:  LW			V0, C (A0)
    C:  JAL			~Func:get_variable
   10:  LW			A1, 0 (V0)
   14:  JAL			~Func:get_entity_by_index
   18:  COPY		A0, V0
   1C:  LIF			F0, 1.000000
   24:  LWC1		F2, 4C (V0)
   28:  SWC1		F0, 10 (SP)
   2C:  LIF			F0, 12.5
   34:  ADDIU		V1, R0, 4B
   38:  SW			V1, 14 (SP)
   3C:  ADD.S		F2, F2, F0
   40:  LW			A1, 48 (V0)
   44:  LW			A3, 50 (V0)
   48:  MFC1		A2, F2
   4C:  JAL			80070BB0
   50:  ADDIU		A0, R0, 4
   54:  LW			RA, 18 (SP)
   58:  ADDIU		V0, R0, 2
   5C:  JR			RA
   60:  ADDIU		SP, SP, 20
}

   #new:Function $Function_80242F08
{
    0:  ADDIU		SP, SP, FFE0
    4:  SW			S1, 14 (SP)
    8:  COPY		S1, A0
    C:  SW			S2, 18 (SP)
   10:  SW			RA, 1C (SP)
   14:  SW			S0, 10 (SP)
   18:  LW			S0, C (S1)
   1C:  BEQ			A1, R0, .o60
   20:  CLEAR		S2
   24:  LW			A1, 0 (S0)
   28:  JAL			~Func:get_variable
   2C:  ADDIU		S0, S0, 4
   30:  SW			V0, 84 (S1)
   34:  LW			A1, 0 (S0)
   38:  JAL			~Func:get_variable
   3C:  COPY		A0, S1
   40:  COPY		A0, S2
   44:  ADDIU		A1, R0, D0
   48:  COPY		A2, A1
   4C:  COPY		A3, A1
   50:  SW			V0, 88 (S1)
   54:  SW			R0, 70 (S1)
   58:  JAL			80137E10
   5C:  SW			R0, 74 (S1)
        .o60
   60:  LW			V1, 70 (S1)
   64:  ADDIU		A0, R0, 1
   68:  BEQ			V1, A0, .oD0
   6C:  SLTI		V0, V1, 2
   70:  BEQ			V0, R0, .o88
   74:  ADDIU		V0, R0, 2
   78:  BEQ			V1, R0, .o98
   7C:  ADDIU		A1, R0, FF
   80:  BEQ			R0, R0, .o110
   84:  NOP
        .o88
   88:  BEQ			V1, V0, .oF0
   8C:  NOP
   90:  BEQ			R0, R0, .o110
   94:  NOP
        .o98
   98:  LW			V0, 74 (S1)
   9C:  BNE			V0, A1, .oB0
   A0:  NOP
   A4:  SW			A0, 70 (S1)
   A8:  SW			R0, 78 (S1)
   AC:  LW			V0, 74 (S1)
        .oB0
   B0:  LW			V1, 84 (S1)
   B4:  ADDU		V0, V0, V1
   B8:  SW			V0, 74 (S1)
   BC:  SLTI		V0, V0, 100
   C0:  BEQL		V0, R0, .o110
   C4:  SW			A1, 74 (S1)
   C8:  BEQ			R0, R0, .o110
   CC:  NOP
        .oD0
   D0:  LW			V0, 78 (S1)
   D4:  ADDIU		V0, V0, 1
   D8:  SW			V0, 78 (S1)
   DC:  SLTI		V0, V0, 2
   E0:  BNE			V0, R0, .o110
   E4:  ADDIU		V0, R0, 2
   E8:  BEQ			R0, R0, .o110
   EC:  SW			V0, 70 (S1)
        .oF0
   F0:  LW			V1, 74 (S1)
   F4:  BEQL		V1, R0, .oFC
   F8:  ADDIU		S2, R0, 1
        .oFC
   FC:  LW			V0, 88 (S1)
  100:  SUBU		V0, V1, V0
  104:  BGEZ		V0, .o110
  108:  SW			V0, 74 (S1)
  10C:  SW			R0, 74 (S1)
        .o110
  110:  LWC1		F0, 74 (S1)
  114:  CVT.S.W		F0, F0
  118:  MFC1		A1, F0
  11C:  JAL			80137D88
  120:  ADDIU		A0, R0, 1
  124:  COPY		V0, S2
  128:  LW			RA, 1C (SP)
  12C:  LW			S2, 18 (SP)
  130:  LW			S1, 14 (SP)
  134:  LW			S0, 10 (SP)
  138:  JR			RA
  13C:  ADDIU		SP, SP, 20
}

  #new:Function $Function_8024240C
{
    0:  ADDIU		SP, SP, FFE8
    4:  SW			RA, 10 (SP)
    8:  LW			V0, C (A0)
    C:  JAL			~Func:get_variable
   10:  LW			A1, 0 (V0)
   14:  JAL			802E5690
   18:  COPY		A0, V0
   1C:  LW			RA, 10 (SP)
   20:  ADDIU		V0, R0, 2
   24:  JR			RA
   28:  ADDIU		SP, SP, 18
}

   #new:Function $Function_80242978
{
    0:  ADDIU		SP, SP, FFE0
    4:  SW			RA, 18 (SP)
    8:  JAL			~Func:get_npc_safe
    C:  ADDIU		A0, R0, FFFC
   10:  LWC1		F4, 3C (V0)
   14:  LIF			F2, 12.5
   1C:  LIF			F0, 1.000000
   24:  ADDIU		V1, R0, 1E
   28:  SW			V1, 14 (SP)
   2C:  ADD.S		F4, F4, F2
   30:  SWC1		F0, 10 (SP)
   34:  LW			A1, 38 (V0)
   38:  LW			A3, 40 (V0)
   3C:  MFC1		A2, F4
   40:  JAL			80070BB0
   44:  ADDIU		A0, R0, 9
   48:  LW			RA, 18 (SP)
   4C:  ADDIU		V0, R0, 2
   50:  JR			RA
   54:  ADDIU		SP, SP, 20
}

   #new:Function $Function_80243048
{
    0:  ADDIU		SP, SP, FFE0
    4:  SW			RA, 18 (SP)
    8:  JAL			~Func:get_npc_safe
    C:  ADDIU		A0, R0, FFFC
   10:  LIF			F0, 30.000000
   18:  LWC1		F2, 3C (V0)
   1C:  ADD.S		F2, F2, F0
   20:  SWC1		F0, 10 (SP)
   24:  LW			A1, 38 (V0)
   28:  LW			A3, 40 (V0)
   2C:  MFC1		A2, F2
   30:  JAL			8006FEF0
   34:  ADDIU		A0, R0, 2
   38:  LW			RA, 18 (SP)
   3C:  ADDIU		V0, R0, 2
   40:  JR			RA
   44:  ADDIU		SP, SP, 20
}

   #new:Function $Function_80243090
{
    0:  ADDIU		SP, SP, FFE0
    4:  SW			RA, 18 (SP)
    8:  JAL			~Func:get_npc_safe
    C:  ADDIU		A0, R0, FFFC
   10:  LIF			F0, 30.000000
   18:  LWC1		F2, 3C (V0)
   1C:  ADD.S		F2, F2, F0
   20:  SWC1		F0, 10 (SP)
   24:  LW			A1, 38 (V0)
   28:  LW			A3, 40 (V0)
   2C:  MFC1		A2, F2
   30:  JAL			8006FEF0
   34:  ADDIU		A0, R0, 4
   38:  LW			RA, 18 (SP)
   3C:  ADDIU		V0, R0, 2
   40:  JR			RA
   44:  ADDIU		SP, SP, 20
}

   #new:Function $Function_802429D0
{
    0:  ADDIU		SP, SP, FFA0
    4:  SW			S6, 40 (SP)
    8:  COPY		S6, A0
    C:  SW			S0, 28 (SP)
   10:  COPY		S0, A1
   14:  SW			RA, 44 (SP)
   18:  SW			S5, 3C (SP)
   1C:  SW			S4, 38 (SP)
   20:  SW			S3, 34 (SP)
   24:  SW			S2, 30 (SP)
   28:  SW			S1, 2C (SP)
   2C:  SDC1		F24, 58 (SP)
   30:  SDC1		F22, 50 (SP)
   34:  SDC1		F20, 48 (SP)
   38:  LW			S3, C (S6)
   3C:  JAL			~Func:get_npc_safe
   40:  ADDIU		A0, R0, FFFC
   44:  ADDIU		A1, SP, 18
   48:  LAW			A0, 80077410
   50:  ADDIU		A2, SP, 1C
   54:  SLL			V1, A0, 2
   58:  ADDU		V1, V1, A0
   5C:  SLL			V1, V1, 2
   60:  SUBU		V1, V1, A0
   64:  SLL			A0, V1, 3
   68:  ADDU		V1, V1, A0
   6C:  SLL			V1, V1, 3
   70:  LTF			F12, V1 (800B1DEC)
   7C:  JAL			~Func:sin_cos_deg
   80:  COPY		S5, V0
   84:  BEQ			S0, R0, .o1FC
   88:  NOP
   8C:  JAL			~Func:general_heap_malloc
   90:  ADDIU		A0, R0, 68
   94:  COPY		S2, V0
   98:  COPY		A0, S6
   9C:  CLEAR		S1
   A0:  ADDIU		S4, R0, FFFF
   A4:  SW			S2, 60 (S6)
   A8:  LW			A1, 0 (S3)
   AC:  LIF			F24, 12.5
   B4:  LIF			F22, 1.000000
   BC:  MTC1		R0, F20
   C0:  JAL			~Func:get_variable
   C4:  COPY		S0, S2
   C8:  JAL			~Func:get_entity_by_index
   CC:  COPY		A0, V0
   D0:  SW			V0, 5C (S2)
        .oD4
   D4:  LW			V0, 5C (S2)
   D8:  LWC1		F0, 4C (V0)
   DC:  CLEAR		A0
   E0:  SWC1		F22, 10 (SP)
   E4:  SW			S4, 14 (SP)
   E8:  ADD.S		F0, F0, F24
   EC:  LW			A1, 48 (V0)
   F0:  LW			A3, 50 (V0)
   F4:  MFC1		A2, F0
   F8:  JAL			800716F0
   FC:  ADDIU		S1, S1, 1
  100:  SW			V0, 8 (S0)
  104:  SWC1		F20, 2C (S0)
  108:  SWC1		F20, 20 (S0)
  10C:  SWC1		F20, 14 (S0)
  110:  SWC1		F20, 50 (S0)
  114:  SWC1		F20, 44 (S0)
  118:  SWC1		F20, 38 (S0)
  11C:  SLTI		V0, S1, 3
  120:  BNE			V0, R0, .oD4
  124:  ADDIU		S0, S0, 4
  128:  CLEAR		S1
  12C:  COPY		S0, S2
  130:  LIA			S4, $???_80243D88
  138:  LIF			F20, 50.000000
  140:  ADDIU		S3, R0, 44
  144:  SW			R0, 0 (S2)
  148:  SW			R0, 4 (S2)
  14C:  SW			R0, 60 (S2)
  150:  SW			R0, 64 (S2)
        .o154
  154:  ADDIU		A0, SP, 20
  158:  MFC1		A2, F20
  15C:  LW			A3, 0 (S4)
  160:  ADDU		A1, S2, S3
  164:  JAL			~Func:add_vec2D_polar
  168:  SW			R0, 20 (SP)
  16C:  LWC1		F2, 1C (SP)
  170:  LWC1		F4, 20 (SP)
  174:  MUL.S		F2, F2, F4
  178:  NOP
  17C:  LWC1		F0, 18 (SP)
  180:  MUL.S		F0, F0, F4
  184:  NOP
  188:  SWC1		F2, 38 (S0)
  18C:  SWC1		F0, 50 (S0)
  190:  LW			V0, 5C (S2)
  194:  LWC1		F0, 38 (S0)
  198:  LWC1		F2, 48 (V0)
  19C:  ADD.S		F2, F2, F0
  1A0:  LWC1		F0, 38 (S5)
  1A4:  SUB.S		F0, F0, F2
  1A8:  SWC1		F0, 38 (S0)
  1AC:  LW			V0, 5C (S2)
  1B0:  LWC1		F0, 44 (S0)
  1B4:  LWC1		F2, 4C (V0)
  1B8:  ADD.S		F2, F2, F0
  1BC:  LWC1		F0, 3C (S5)
  1C0:  SUB.S		F0, F0, F2
  1C4:  SWC1		F0, 44 (S0)
  1C8:  LW			V0, 5C (S2)
  1CC:  LWC1		F0, 50 (S0)
  1D0:  LWC1		F2, 50 (V0)
  1D4:  ADDIU		S4, S4, 4
  1D8:  ADD.S		F2, F2, F0
  1DC:  LWC1		F0, 40 (S5)
  1E0:  ADDIU		S3, S3, 4
  1E4:  SUB.S		F0, F0, F2
  1E8:  ADDIU		S1, S1, 1
  1EC:  SLTI		V0, S1, 3
  1F0:  SWC1		F0, 50 (S0)
  1F4:  BNE			V0, R0, .o154
  1F8:  ADDIU		S0, S0, 4
        .o1FC
  1FC:  LW			S2, 60 (S6)
  200:  LW			V1, 0 (S2)
  204:  ADDIU		V0, R0, 1
  208:  BEQ			V1, V0, .o2EC
  20C:  SLTI		V0, V1, 2
  210:  BEQL		V0, R0, .o228
  214:  ADDIU		V0, R0, 2
  218:  BEQ			V1, R0, .o238
  21C:  ADDIU		A0, R0, 5
  220:  BEQ			R0, R0, .o3D0
  224:  NOP
        .o228
  228:  BEQ			V1, V0, .o38C
  22C:  NOP
  230:  BEQ			R0, R0, .o3D0
  234:  NOP
        .o238
  238:  CLEAR		S1
  23C:  LIA			S4, $???_80243D88
  244:  ADDIU		S3, R0, 20
  248:  LUI			A2, 4248
  24C:  MTC1		R0, F0
  250:  ADDIU		V0, R0, 14
  254:  SW			V0, 10 (SP)
  258:  MFC1		A1, F0
  25C:  LW			A3, 60 (S2)
  260:  MTC1		A1, F22
  264:  JAL			~Func:update_lerp
  268:  COPY		S0, S2
  26C:  MOV.S		F20, F0
        .o270
  270:  MFC1		A2, F20
  274:  ADDIU		A0, SP, 20
  278:  SWC1		F22, 20 (S0)
  27C:  LW			A3, 0 (S4)
  280:  ADDU		A1, S2, S3
  284:  JAL			~Func:add_vec2D_polar
  288:  SWC1		F22, 20 (SP)
  28C:  LWC1		F4, 1C (SP)
  290:  LWC1		F0, 20 (SP)
  294:  MUL.S		F4, F4, F0
  298:  NOP
  29C:  LWC1		F2, 18 (SP)
  2A0:  ADDIU		S4, S4, 4
  2A4:  MUL.S		F2, F2, F0
  2A8:  NOP
  2AC:  ADDIU		S3, S3, 4
  2B0:  ADDIU		S1, S1, 1
  2B4:  SLTI		V0, S1, 3
  2B8:  SWC1		F4, 14 (S0)
  2BC:  SWC1		F2, 2C (S0)
  2C0:  BNE			V0, R0, .o270
  2C4:  ADDIU		S0, S0, 4
  2C8:  LW			V0, 60 (S2)
  2CC:  ADDIU		V0, V0, 1
  2D0:  SW			V0, 60 (S2)
  2D4:  SLTI		V0, V0, 15
  2D8:  BNE			V0, R0, .o3D0
  2DC:  ADDIU		V0, R0, 1
  2E0:  SW			V0, 0 (S2)
  2E4:  BEQ			R0, R0, .o3D0
  2E8:  SW			R0, 60 (S2)
        .o2EC
  2EC:  CLEAR		S1
  2F0:  LIA			S4, $???_80243D88
  2F8:  ADDIU		S3, R0, 20
  2FC:  COPY		S0, S2
  300:  LIF			F20, 50.000000
  308:  MTC1		R0, F22
        .o30C
  30C:  MFC1		A2, F20
  310:  ADDIU		A0, SP, 20
  314:  SWC1		F22, 20 (S0)
  318:  LW			A3, 0 (S4)
  31C:  ADDU		A1, S2, S3
  320:  JAL			~Func:add_vec2D_polar
  324:  SWC1		F22, 20 (SP)
  328:  LWC1		F4, 1C (SP)
  32C:  LWC1		F0, 20 (SP)
  330:  MUL.S		F4, F4, F0
  334:  NOP
  338:  LWC1		F2, 18 (SP)
  33C:  ADDIU		S4, S4, 4
  340:  MUL.S		F2, F2, F0
  344:  NOP
  348:  ADDIU		S3, S3, 4
  34C:  ADDIU		S1, S1, 1
  350:  SLTI		V0, S1, 3
  354:  SWC1		F4, 14 (S0)
  358:  SWC1		F2, 2C (S0)
  35C:  BNE			V0, R0, .o30C
  360:  ADDIU		S0, S0, 4
  364:  LW			V0, 60 (S2)
  368:  ADDIU		V0, V0, 1
  36C:  SW			V0, 60 (S2)
  370:  SLTI		V0, V0, 10
  374:  BNE			V0, R0, .o3D0
  378:  ADDIU		V0, R0, F
  37C:  SW			V0, 60 (S2)
  380:  ADDIU		V0, R0, 2
  384:  BEQ			R0, R0, .o3D0
  388:  SW			V0, 0 (S2)
        .o38C
  38C:  LW			V0, 60 (S2)
  390:  ADDIU		V0, V0, 1
  394:  SW			V0, 60 (S2)
  398:  SLTI		V0, V0, 1F
  39C:  BNE			V0, R0, .o3D0
  3A0:  CLEAR		S1
  3A4:  COPY		A1, S2
        .o3A8
  3A8:  LW			V0, 8 (A1)
  3AC:  LW			V1, 0 (V0)
  3B0:  ADDIU		S1, S1, 1
  3B4:  ORI			V1, V1, 10
  3B8:  SW			V1, 0 (V0)
  3BC:  SLTI		V0, S1, 3
  3C0:  BNE			V0, R0, .o3A8
  3C4:  ADDIU		A1, A1, 4
  3C8:  BEQ			R0, R0, .o504
  3CC:  ADDIU		V0, R0, 2
        .o3D0
  3D0:  LW			V1, 4 (S2)
  3D4:  BEQ			V1, R0, .o3EC
  3D8:  ADDIU		V0, R0, 1
  3DC:  BEQ			V1, V0, .o40C
  3E0:  CLEAR		S1
  3E4:  BEQ			R0, R0, .o4C0
  3E8:  COPY		A1, S2
        .o3EC
  3EC:  LW			V0, 64 (S2)
  3F0:  ADDIU		V0, V0, 1
  3F4:  SW			V0, 64 (S2)
  3F8:  SLTI		V0, V0, 10
  3FC:  BNE			V0, R0, .o4BC
  400:  CLEAR		S1
  404:  BEQ			R0, R0, .o4B0
  408:  ADDIU		V0, R0, 1
        .o40C
  40C:  MTC1		R0, F20
  410:  ADDIU		S3, R0, 14
  414:  COPY		S0, S2
        .o418
  418:  MFC1		A1, F20
  41C:  SW			S3, 10 (SP)
  420:  LW			A2, 38 (S0)
  424:  LW			A3, 64 (S2)
  428:  JAL			~Func:update_lerp
  42C:  ADDIU		A0, R0, 1
  430:  LWC1		F2, 14 (S0)
  434:  ADD.S		F2, F2, F0
  438:  MFC1		A1, F20
  43C:  SWC1		F2, 14 (S0)
  440:  SW			S3, 10 (SP)
  444:  LW			A2, 44 (S0)
  448:  LW			A3, 64 (S2)
  44C:  JAL			~Func:update_lerp
  450:  ADDIU		A0, R0, 1
  454:  LWC1		F2, 20 (S0)
  458:  ADD.S		F2, F2, F0
  45C:  MFC1		A1, F20
  460:  SWC1		F2, 20 (S0)
  464:  SW			S3, 10 (SP)
  468:  LW			A2, 50 (S0)
  46C:  LW			A3, 64 (S2)
  470:  JAL			~Func:update_lerp
  474:  ADDIU		A0, R0, 1
  478:  LWC1		F2, 2C (S0)
  47C:  ADD.S		F2, F2, F0
  480:  ADDIU		S1, S1, 1
  484:  SLTI		V0, S1, 3
  488:  SWC1		F2, 2C (S0)
  48C:  BNE			V0, R0, .o418
  490:  ADDIU		S0, S0, 4
  494:  LW			V0, 64 (S2)
  498:  ADDIU		V0, V0, 1
  49C:  SW			V0, 64 (S2)
  4A0:  SLTI		V0, V0, 15
  4A4:  BNE			V0, R0, .o4BC
  4A8:  CLEAR		S1
  4AC:  ADDIU		V0, R0, 2
        .o4B0
  4B0:  SW			V0, 4 (S2)
  4B4:  SW			R0, 64 (S2)
  4B8:  CLEAR		S1
        .o4BC
  4BC:  COPY		A1, S2
        .o4C0
  4C0:  LW			V0, 8 (A1)
  4C4:  LWC1		F0, 14 (A1)
  4C8:  LW			V0, C (V0)
  4CC:  SWC1		F0, 10 (V0)
  4D0:  LW			V0, 8 (A1)
  4D4:  LWC1		F0, 20 (A1)
  4D8:  LW			V0, C (V0)
  4DC:  ADDIU		S1, S1, 1
  4E0:  SWC1		F0, 14 (V0)
  4E4:  LW			V0, 8 (A1)
  4E8:  LWC1		F0, 2C (A1)
  4EC:  LW			V0, C (V0)
  4F0:  SWC1		F0, 18 (V0)
  4F4:  SLTI		V0, S1, 3
  4F8:  BNE			V0, R0, .o4C0
  4FC:  ADDIU		A1, A1, 4
  500:  CLEAR		V0
        .o504
  504:  LW			RA, 44 (SP)
  508:  LW			S6, 40 (SP)
  50C:  LW			S5, 3C (SP)
  510:  LW			S4, 38 (SP)
  514:  LW			S3, 34 (SP)
  518:  LW			S2, 30 (SP)
  51C:  LW			S1, 2C (SP)
  520:  LW			S0, 28 (SP)
  524:  LDC1		F24, 58 (SP)
  528:  LDC1		F22, 50 (SP)
  52C:  LDC1		F20, 48 (SP)
  530:  JR			RA
  534:  ADDIU		SP, SP, 60
}

  #new:Data $???_80243D48
{
001D00E0 001D00E1 001D00E2 001D00E3 001D00E4 001D00E5 001D00E6 001D00E7 
001D00E8 001D00E9 001D00EA 001D00EB 001D00EC 001D00ED 001D00EE 001D00EF 
}

#new:Data $???_80243D88
{
430C0000 43340000 435C0000 
}

#new:Function $Function_80242438
{
    0:  ADDIU		SP, SP, FFE0
    4:  SW			S0, 10 (SP)
    8:  COPY		S0, A0
    C:  SW			RA, 18 (SP)
   10:  SW			S1, 14 (SP)
   14:  LW			S1, C (S0)
   18:  LW			A1, 0 (S1)
   1C:  JAL			~Func:get_variable
   20:  ADDIU		S1, S1, 4
   24:  COPY		A0, S0
   28:  LIA			V1, 8010F290
   30:  SLL			V0, V0, 3
   34:  ADDU		V0, V0, V1
   38:  LBU			A2, 15 (V0)
   3C:  LW			A1, 0 (S1)
   40:  ADDIU		A2, A2, 1
   44:  SB			A2, 15 (V0)
   48:  SLL			A2, A2, 18
   4C:  JAL			~Func:set_variable
   50:  SRA			A2, A2, 18
   54:  LW			RA, 18 (SP)
   58:  LW			S1, 14 (SP)
   5C:  LW			S0, 10 (SP)
   60:  ADDIU		V0, R0, 2
   64:  JR			RA
   68:  ADDIU		SP, SP, 20
}

   #new:Function $Function_80242818
{
    0:  LAB			V0, 8010F2A2
    8:  ADDIU		SP, SP, FFE8
    C:  SW			RA, 10 (SP)
   10:  SLL			V0, V0, 4
   14:  LTW			A0, V0 (8008EF20)
   20:  JAL			~Func:set_message_string
   24:  CLEAR		A1
   28:  LW			RA, 10 (SP)
   2C:  ADDIU		V0, R0, 2
   30:  JR			RA
   34:  ADDIU		SP, SP, 18
}

  #new:Function $Function_802430D8
{
    0:  LIA			V1, 8010EBB0
    8:  SW			R0, 84 (A0)
    C:  LB			V0, 0 (V1)
   10:  BEQ			V0, R0, .o28
   14:  ADDIU		V0, R0, 3
   18:  LB			V1, 3 (V1)
   1C:  BNE			V1, V0, .o28
   20:  ADDIU		V0, R0, 1
   24:  SW			V0, 84 (A0)
        .o28
   28:  JR			RA
   2C:  ADDIU		V0, R0, 2
}

   #new:Function $Function_802423D0
{
   0:  LIA			V1, 8009A650
   8:  LW			V0, 0 (V1)
   C:  ORI			V0, V0, 40
  10:  SW			V0, 0 (V1)
  14:  JR			RA
  18:  ADDIU		V0, R0, 2
}

  #new:Function $Function_80242850
{
    0:  ADDIU		SP, SP, FFD8
    4:  SW			S1, 1C (SP)
    8:  COPY		S1, A0
    C:  SW			RA, 20 (SP)
   10:  SW			S0, 18 (SP)
   14:  LW			S0, C (S1)
   18:  LW			A1, 0 (S0)
   1C:  JAL			~Func:get_variable
   20:  ADDIU		S0, S0, 4
   24:  JAL			~Func:get_entity_by_index
   28:  COPY		A0, V0
   2C:  LW			S0, 0 (S0)
   30:  LWC1		F4, 4C (V0)
   34:  LIF			F0, 12.5
   3C:  LIO			AT, 3F333333
   44:  MTC1		AT, F2
   48:  SW			R0, 14 (SP)
   4C:  ADD.S		F4, F4, F0
   50:  SWC1		F2, 10 (SP)
   54:  LW			A1, 48 (V0)
   58:  LW			A3, 50 (V0)
   5C:  MFC1		A2, F4
   60:  JAL			80071750
   64:  CLEAR		A0
   68:  COPY		A0, S1
   6C:  COPY		A1, S0
   70:  JAL			~Func:set_variable
   74:  COPY		A2, V0
   78:  LW			RA, 20 (SP)
   7C:  LW			S1, 1C (SP)
   80:  LW			S0, 18 (SP)
   84:  ADDIU		V0, R0, 2
   88:  JR			RA
   8C:  ADDIU		SP, SP, 28
}

   #new:Function $Function_CheckAvailability
{
   0:  ADDIU		SP, SP, FFD0
   4:  SW			S3, 1C (SP)
   8:  COPY		S3, A0
   C:  SW			S0, 10 (SP)
  10:  ADDIU		S0, R0, 1
  14:  SW			S4, 20 (SP)
  18:  ADDIU		S4, R0, FFFF
  1C:  SW			S5, 24 (SP)
  20:  COPY		S5, S0
  24:  SW			S1, 14 (SP)
  28:  LIA			S1, 8010F298
  30:  SW			RA, 28 (SP)
  34:  SW			S2, 18 (SP)
  38:  LW			V0, B4 (S3)
  3C:  COPY		V1, S4
  40:  SW			V1, 84 (S3)
  44:  NOR			V0, R0, V0
  48:  SRL			V0, V0, 1F
  4C:  SLL			S2, V0, 10
       .o50
  50:  LBU			V0, 14 (S1)
  54:  BEQL		V0, R0, .o78
  58:  ADDIU		S0, S0, 1
  5C:  COPY		A0, S0
  60:  JAL			$Function_802424A4
  64:  SRA			A1, S2, 10
  68:  BEQ			V0, S4, .o78
  6C:  ADDIU		S0, S0, 1
  70:  BEQ			R0, R0, .o84
  74:  SW			S5, 84 (S3)
       .o78
  78:  SLTI		V0, S0, C
  7C:  BNE			V0, R0, .o50
  80:  ADDIU		S1, S1, 8
       .o84
  84:  LW			RA, 28 (SP)
  88:  LW			S5, 24 (SP)
  8C:  LW			S4, 20 (SP)
  90:  LW			S3, 1C (SP)
  94:  LW			S2, 18 (SP)
  98:  LW			S1, 14 (SP)
  9C:  LW			S0, 10 (SP)
  A0:  ADDIU		V0, R0, 2
  A4:  JR			RA
  A8:  ADDIU		SP, SP, 30
}

#new:Function $Function_GetBoots % save in var3
{
PUSH	RA, V0, A1, A2
LAB 	A2, 8010F290 % Boots
LIO 	A1, *Var[3]
JAL 	~Func:set_variable
NOP
POP		RA, V0, A1, A2
JR 		RA
NOP
}

#new:Function $Function_GetHammer % save in var3
{
PUSH	RA, V0, A1, A2
LAB 	A2, 8010F291 % Hammer
LIO 	A1, *Var[3]
JAL 	~Func:set_variable
NOP
POP		RA, V0, A1, A2
JR 		RA
NOP
}

%Set    *Var[C] .True % Bypass Ultra Stone check
% Save a -1 in Var0 if there isn't any partners available to be upgraded

% *out = var0
%
% -1 = Everyone upgraded
#new:Function $Function_CheckPartnersUpgrades
{
    0:  ADDIU		SP, SP, FFD0
    4:  SW			S3, 1C (SP)
    8:  COPY		S3, A0
    C:  SW			S0, 10 (SP)
   10:  ADDIU		S0, R0, 1
   14:  SW			S4, 20 (SP)
   18:  ADDIU		S4, R0, FFFF
   1C:  SW			S5, 24 (SP)
   20:  COPY		S5, S0
   24:  SW			S1, 14 (SP)
   28:  LIA			S1, 8010F298
   30:  SW			RA, 28 (SP)
   34:  SW			S2, 18 (SP)
   38:  LW			V0, B4 (S3)
   3C:  COPY		V1, S4
   40:  SW			V1, 84 (S3)
   44:  NOR			V0, R0, V0
   48:  SRL			V0, V0, 1F
   4C:  SLL			S2, V0, 10
        .o50
   50:  LBU			V0, 14 (S1)
   54:  BEQL		V0, R0, .o78
   58:  ADDIU		S0, S0, 1
   5C:  COPY		A0, S0
   60:  JAL			$Function_802424A4
   64:  SRA			A1, S2, 10
   68:  BEQ			V0, S4, .o78
   6C:  ADDIU		S0, S0, 1
   70:  BEQ			R0, R0, .o84
   74:  SW			S5, 84 (S3)
        .o78
   78:  SLTI		V0, S0, C
   7C:  BNE			V0, R0, .o50
   80:  ADDIU		S1, S1, 8
        .o84
   84:  LW			RA, 28 (SP)
   88:  LW			S5, 24 (SP)
   8C:  LW			S4, 20 (SP)
   90:  LW			S3, 1C (SP)
   94:  LW			S2, 18 (SP)
   98:  LW			S1, 14 (SP)
   9C:  LW			S0, 10 (SP)
   A0:  ADDIU		V0, R0, 2
   A4:  JR			RA
   A8:  ADDIU		SP, SP, 30
}
   
   #new:Function $Function_802424A4
{
    LIA			V0, 8010F290
    SLL			A0, A0, 3
    ADDU		A0, A0, V0
    LBU			V0, 14 (A0)
    BEQ			V0, R0, .o3C
    NOP
    LBU			V0, 15 (A0)
    SLL			A0, V0, 18
    SRA			V1, A0, 18
    SLL			V0, A1, 10
    SRA			V0, V0, 10
    SLT			V0, V0, V1
    BEQ			V0, R0, .o44
    NOP
    .o3C
    JR			RA
    ADDIU		V0, R0, FFFF
    .o44
    JR			RA
    SRA			V0, A0, 18
}

    #new:Function $Function_802428E0
{
    0:  ADDIU		SP, SP, FFE8
    4:  SW			RA, 10 (SP)
    8:  LW			V0, C (A0)
    C:  JAL			~Func:get_variable
   10:  LW			A1, 0 (V0)
   14:  COPY		A0, V0
   18:  LW			V1, 0 (A0)
   1C:  ORI			V1, V1, 10
   20:  SW			V1, 0 (A0)
   24:  LW			RA, 10 (SP)
   28:  ADDIU		V0, R0, 2
   2C:  JR			RA
   30:  ADDIU		SP, SP, 18
}

   #new:Function $Function_802423EC
{
    0:  LIA			V0, 8009A650
    8:  LW			V1, 0 (V0)
    C:  ADDIU		A0, R0, FFBF
   10:  AND			V1, V1, A0
   14:  SW			V1, 0 (V0)
   18:  JR			RA
   1C:  ADDIU		V0, R0, 2
}

   #new:Function $Function_OpenPartnersList
{
    0:  ADDIU		SP, SP, FFC0
    4:  SW			S5, 2C (SP)
    8:  COPY		S5, A0
    C:  SW			S8, 38 (SP)
   10:  LIA			S8, 8010F290
   18:  SW			RA, 3C (SP)
   1C:  SW			S7, 34 (SP)
   20:  SW			S6, 30 (SP)
   24:  SW			S4, 28 (SP)
   28:  SW			S3, 24 (SP)
   2C:  SW			S2, 20 (SP)
   30:  SW			S1, 1C (SP)
   34:  BEQ			A1, R0, .o174
   38:  SW			S0, 18 (SP)
   3C:  JAL			8002ACE4
   40:  ADDIU		A0, R0, 330
   44:  COPY		S3, V0
   48:  CLEAR		S6
   4C:  COPY		S2, S6
   50:  LIA			S4, $???_80243D38
   58:  COPY		S1, S3
   5C:  LW			V0, B4 (S5)
   60:  LIA			V1, $???_80243D30
   68:  SW			S3, 78 (S5)
   6C:  NOR			V0, R0, V0
   70:  SRL			S7, V0, 1F
   74:  SLL			V0, S7, 2
   78:  ADDU		V0, V0, V1
   7C:  SW			V0, 10 (SP)
        .o80
   80:  LH			S0, 0 (S4)
   84:  SLL			V0, S0, 3
   88:  ADDU		V0, S8, V0
   8C:  LBU			V0, 14 (V0)
   90:  BEQL		V0, R0, .o14C
   94:  ADDIU		S2, S2, 1
   98:  SLL			V0, S0, 4
   9C:  LIA			A2, 8008EF20
   A4:  ADDU		V0, V0, A2
   A8:  COPY		A0, S0
   AC:  SW			S0, 108 (S1)
   B0:  LW			V0, 0 (V0)
   B4:  COPY		A1, S7
   B8:  JAL			$Function_802424A4
   BC:  SW			V0, 84 (S1)
   C0:  COPY		A0, V0
   C4:  BLTZ		A0, .o10C
   C8:  SLL			V0, S0, 2
   CC:  LIA			A2, 800F7F00
   D4:  ADDU		V0, V0, A2
   D8:  LW			V1, 0 (V0)
   DC:  ADDIU		V0, R0, 1
   E0:  SW			V0, 18C (S1)
   E4:  SLL			V0, A0, 2
   E8:  LIA			A2, $???_80243D48
   F0:  SW			V1, 0 (S1)
   F4:  SLL			V1, S2, 3
   F8:  ADDU		V0, V0, V1
   FC:  ADDU		V0, V0, A2
  100:  LW			V0, 0 (V0)
  104:  BEQ			R0, R0, .o130
  108:  SW			V0, 294 (S1)
        .o10C
  10C:  LIA			A2, 800F7F40
  114:  ADDU		V0, V0, A2
  118:  LW			V0, 0 (V0)
  11C:  SW			R0, 18C (S1)
  120:  SW			V0, 0 (S1)
  124:  LW			A2, 10 (SP)
  128:  LW			V0, 0 (A2)
  12C:  SW			V0, 294 (S1)
        .o130
  130:  SLL			V0, S0, 3
  134:  ADDU		V0, S8, V0
  138:  LB			V0, 15 (V0)
  13C:  ADDIU		S6, S6, 1
  140:  SW			V0, 210 (S1)
  144:  ADDIU		S1, S1, 4
  148:  ADDIU		S2, S2, 1
        .o14C
  14C:  SLTI		V0, S2, 8
  150:  BNE			V0, R0, .o80
  154:  ADDIU		S4, S4, 2
  158:  COPY		A0, S3
  15C:  ADDIU		V0, R0, 4
  160:  SW			V0, 318 (A0)
  164:  SW			S6, 324 (A0)
  168:  JAL			800F4E40
  16C:  SW			R0, 328 (A0)
  170:  SW			R0, 70 (S5)
        .o174
  174:  LW			V0, 70 (S5)
  178:  LW			S3, 78 (S5)
  17C:  BNE			V0, R0, .o1A0
  180:  ADDIU		V0, V0, 1
  184:  LH			V0, 32C (S3)
  188:  BEQ			V0, R0, .o1B0
  18C:  SW			V0, 74 (S5)
  190:  JAL			800F13B0
  194:  NOP
  198:  LW			V0, 70 (S5)
  19C:  ADDIU		V0, V0, 1
        .o1A0
  1A0:  SW			V0, 70 (S5)
  1A4:  SLTI		V0, V0, F
  1A8:  BEQ			V0, R0, .o1B8
  1AC:  NOP
        .o1B0
  1B0:  BEQ			R0, R0, .o220
  1B4:  CLEAR		V0
        .o1B8
  1B8:  JAL			800F1538
  1BC:  NOP
  1C0:  LW			V1, 74 (S5)
  1C4:  ADDIU		V0, R0, FF
  1C8:  BEQ			V1, V0, .o20C
  1CC:  ADDIU		V0, V1, FFFF
  1D0:  SLL			V0, V0, 2
  1D4:  ADDU		V0, S3, V0
  1D8:  LW			V0, 108 (V0)
  1DC:  SLL			V0, V0, 4
  1E0:  LTW			V1, V0 (8008EF20)
  1EC:  LW			V0, 74 (S5)
  1F0:  ADDIU		V0, V0, FFFF
  1F4:  SLL			V0, V0, 2
  1F8:  ADDU		V0, S3, V0
  1FC:  SW			V1, 84 (S5)
  200:  LW			V0, 108 (V0)
  204:  BEQ			R0, R0, .o214
  208:  SW			V0, 88 (S5)
        .o20C
  20C:  ADDIU		V0, R0, FFFF
  210:  SW			V0, 84 (S5)
        .o214
  214:  JAL			8002AD2C
  218:  LW			A0, 78 (S5)
  21C:  ADDIU		V0, R0, 2
        .o220
  220:  LW			RA, 3C (SP)
  224:  LW			S8, 38 (SP)
  228:  LW			S7, 34 (SP)
  22C:  LW			S6, 30 (SP)
  230:  LW			S5, 2C (SP)
  234:  LW			S4, 28 (SP)
  238:  LW			S3, 24 (SP)
  23C:  LW			S2, 20 (SP)
  240:  LW			S1, 1C (SP)
  244:  LW			S0, 18 (SP)
  248:  JR			RA
  24C:  ADDIU		SP, SP, 40
}

  #new:Data $???_80243D30
{
001D00F0 001D00F1 
}

#new:Data $???_80243D38
{
00010002 00030004 00090006 00070008 
}

#new:Function $Function_802427EC
{
    0:  ADDIU		SP, SP, FFE8
    4:  SW			RA, 10 (SP)
    8:  LW			V0, C (A0)
    C:  JAL			~Func:get_variable
   10:  LW			A1, 0 (V0)
   14:  JAL			800EB168
   18:  COPY		A0, V0
   1C:  LW			RA, 10 (SP)
   20:  ADDIU		V0, R0, 2
   24:  JR			RA
   28:  ADDIU		SP, SP, 18
}

% Spawn Rewards
#new:Script:Map $Script_Reward_SpawnItem
{
Call $Function_Reward_GetDataX % save in varA/B/C
Call    RandInt     ( 5A *Var[0] ) % Get Item to Spawn % Fully RNG
Add     *Var[0] 80 % ItemIDs 0080 -00DB ( 80 + 5A = DA - Highest possible ID)
% Check impossible items, just use the next available ID on the item table instead
Switch *Var[0]
    Case == .Item:InsecticideHerb
        Set *Var[0] .Item:StopWatch
    Case == .Item:HustleDrink
        Set *Var[0] .Item:StoneCap
    Case == .Item:LifeShroom
        Set *Var[0] .Item:Mystery
    Case == .Item:PleaseComeBack
        Set *Var[0] .Item:DizzyDial
    CaseOR == .Item:RedBerry % Ultra Life Shroom
    CaseOR == .Item:YellowBerry % FP Life Shroom
        Set *Var[0] .Item:BubbleBerry
    EndCaseGroup
EndSwitch
% *Var[2]=ItemEntity Flag, Items doesn't use flags so always use 0
Set     *Var[2] .Flag_SpawnedItem
% save rarity var for current reward (used for padlocks springs)
Call    RandInt ( 1 *Var[E] )
Set     *Var[D] 1
Add     *Var[D] *Var[E]
Call    $Function_Save_RewardData ( *Var[D] ) % used for battle based springs
% Check if 1thing2traps was used
If .Rogue_Item_2 == .False
    If .Rogue_LoadedID != FF
        Set *Var[B] .Rogue_ID % use rogueID instead
    EndIf
EndIf
% Check if a Lock is the trap, to set the amount
% needed to open the lock
Switch *Var[B]
    Case == 17` % Spring - Keys Based
        ExecWait $Script_Padlock_Reformat_Keys
    Case == 18` % Spring - Battle Based
        ExecWait $Script_Spring_SetNPC
    Case == 20` % Springs - Coins Based
        ExecWait $Script_Padlock_Reformat_Coins
    Case == 21` % Springs - HP Based
        ExecWait $Script_Padlock_Reformat_HP
EndSwitch
ExecWait $Script_Reward_SetItemPos
Return
End
}

% check if the obstacle from some spring trap needs to be adjusted
#new:Script:Map $Script_Entity_AdjustSpringTrap
{
Call $Function_Reward_GetDataX % save in varA/B/C
% Check if 1thing2traps was used
If .Rogue_Item_2 == .False
    If .Rogue_LoadedID != FF
        Set *Var[B] .Rogue_ID % use rogueID instead
    EndIf
EndIf
% Check if a Lock is the trap, to set the amount
% needed to open the lock
Switch *Var[B]
    Case == 17` % Spring - Keys Based
        ExecWait $Script_Padlock_Reformat_Keys
    Case == 18` % Spring - Battle Based
        ExecWait $Script_Spring_SetNPC
    Case == 20` % Springs - Coins Based
        ExecWait $Script_Padlock_Reformat_Coins
    Case == 21` % Springs - HP Based
        ExecWait $Script_Padlock_Reformat_HP
EndSwitch
Return
End
}

#new:Script:Map $Script_Reward_SpawnBadge
{
Call $Function_Reward_GetDataX % save in varA/B/C
% read rarity points
Switch *MapVar[F]
    Case <= 4 % Low Tier
        % Check if the player already have all the badges on this tier
        Label LowTier
        Set *Var[1] .Default
        Add *Var[1] *Flag_SlowGo2
        Add *Var[1] *Flag_LuckyDay2
        Add *Var[1] *Flag_Peekaboo2
        Add *Var[1] *Flag_SSmashChg2
        Add *Var[1] *Flag_Spin_Smash2
        Add *Var[1] *Flag_PayOff2
        Add *Var[1] *Flag_Money_Money2
        Add *Var[1] *Flag_Chill_Out2
        Add *Var[1] *Flag_Pretty_Lucky2
        Add *Var[1] *Flag_Hammer_Throw2
        Add *Var[1] *Flag_MegaSmash2
        Add *Var[1] *Flag_MegaJump2
        Add *Var[1] *Flag_Refund2
        Add *Var[1] *Flag_SmashCharge2
        Add *Var[1] *Flag_SpikeShield2
        %Add *Var[1] *Flag_DDownPound2
        Add *Var[1] *Flag_PowerSmash2
        Add *Var[1] *Flag_SleepStomp2
        Add *Var[1] *Flag_DizzyStomp2
        Add *Var[1] *Flag_MegaQuake2
        If *Var[1] == 19`
            Set *MapVar[F] 5
            Wait 1
            Goto MediumTier
        EndIf
        % Get Badge to use
        Call RandInt ( 19` *Var[0] )
        % scrapped badges
		Switch *Var[0]
			CaseOR == 15` % D Down Pound
				Add *Var[0] 1 % just load the next badge
			EndCaseGroup
		EndSwitch
        Switch *Var[0]
            Case == 0
                If *Flag_SlowGo2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:SlowGo
                SetConst *Var[2] *Flag_SlowGo2
            Case == 1
                If *Flag_LuckyDay2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:LuckyDay
                SetConst *Var[2] *Flag_LuckyDay2
            Case == 2
                If *Flag_Peekaboo2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:Peekaboo
                SetConst *Var[2] *Flag_Peekaboo2
            Case == 3
                If *Flag_SSmashChg2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:SSmashChg
                SetConst *Var[2] *Flag_SSmashChg2
            Case == 4
                If *Flag_Spin_Smash2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:SpinSmash
                SetConst *Var[2] *Flag_Spin_Smash2
            Case == 5
                If *Flag_PayOff2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:PayOff
                SetConst *Var[2] *Flag_PayOff2
            Case == 6
                If *Flag_Money_Money2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:MoneyMoney
                SetConst *Var[2] *Flag_Money_Money2
            Case == 7
                If *Flag_Chill_Out2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:ChillOut
                SetConst *Var[2] *Flag_Chill_Out2
            Case == 8
                If *Flag_Pretty_Lucky2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:PrettyLucky
                SetConst *Var[2] *Flag_Pretty_Lucky2
            Case == 9
                If *Flag_Hammer_Throw2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:HammerThrow
                SetConst *Var[2] *Flag_Hammer_Throw2
            Case == 10`
                If *Flag_MegaSmash2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:MegaSmash
                SetConst *Var[2] *Flag_MegaSmash2
            Case == 11`
                If *Flag_MegaJump2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:MegaJump
                SetConst *Var[2] *Flag_MegaJump2
            Case == 12`
                If *Flag_Refund2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:Refund
                SetConst *Var[2] *Flag_Refund2
            Case == 13`
                If *Flag_SmashCharge2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:SmashCharge
                SetConst *Var[2] *Flag_SmashCharge2
            Case == 14`
                If *Flag_SpikeShield2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:SpikeShield
                SetConst *Var[2] *Flag_SpikeShield2
            /%Case == 15`
                If *Flag_DDownPound2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:DDownPound
                SetConst *Var[2] *Flag_DDownPound2%/
            Case == 16`
                If *Flag_PowerSmash2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:PowerSmash1
                SetConst *Var[2] *Flag_PowerSmash2
            Case == 17`
                If *Flag_SleepStomp2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:SleepStomp
                SetConst *Var[2] *Flag_SleepStomp2
            Case == 18`
                If *Flag_DizzyStomp2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:DizzyStomp
                SetConst *Var[2] *Flag_DizzyStomp2
            Case == 19`
                If *Flag_MegaQuake2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:MegaQuake
                SetConst *Var[2] *Flag_MegaQuake2
        EndSwitch
    Case == 5 % Medium Tier
        Label MediumTier
        Set *Var[1] .Default
        Add *Var[1] *Flag_TripleDip2
        Add *Var[1] *Flag_ShrinkStomp2
        Add *Var[1] *Flag_GroupFocus2
        Add *Var[1] *Flag_FireShield2
        Add *Var[1] *Flag_HappyHeartA2
        Add *Var[1] *Flag_HappyHeartB2
        Add *Var[1] *Flag_IcePower2
        %Add *Var[1] *Flag_FeelingFine2 % scrapped
        Add *Var[1] *Flag_SJumpChg2
        Add *Var[1] *Flag_JumpCharge2
        Add *Var[1] *Flag_DeepFocusA2
        Add *Var[1] *Flag_DeepFocusB2
        Add *Var[1] *Flag_DeepFocusC2
        Add *Var[1] *Flag_HappyFlowerA2
        Add *Var[1] *Flag_HappyFlowerB2
        Add *Var[1] *Flag_DodgeMaster2
        Add *Var[1] *Flag_ZapTap2
        Add *Var[1] *Flag_Multibounce2
        Add *Var[1] *Flag_DizzyAttack2
        Add *Var[1] *Flag_PowerJump2
        If *Var[1] == 19`
            Set *MapVar[F] 6
            Wait 1
            Goto HighTier
        EndIf
        % Get Badge to use
        Call RandInt ( 19` *Var[0] )
        Switch *Var[0]
            Case == 0
                If *Flag_TripleDip2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:TripleDip
                SetConst *Var[2] *Flag_TripleDip2
            Case == 1
                If *Flag_ShrinkStomp2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:ShrinkStomp
                SetConst *Var[2] *Flag_ShrinkStomp2
            Case == 2
                If *Flag_GroupFocus2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:GroupFocus
                SetConst *Var[2] *Flag_GroupFocus2
            Case == 3
                If *Flag_FireShield2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:FireShield
                SetConst *Var[2] *Flag_FireShield2
            Case == 4
                If *Flag_HappyHeartA2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:HappyHeartA
                SetConst *Var[2] *Flag_HappyHeartA2
            Case == 5
                If *Flag_HappyHeartB2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:HappyHeartB
                SetConst *Var[2] *Flag_HappyHeartB2
            Case == 6
                If *Flag_IcePower2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:IcePower
                SetConst *Var[2] *Flag_IcePower2
            CaseOR == 7
                /% Feeling got scrapped
                If *Flag_FeelingFine2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:FeelingFine
                SetConst *Var[2] *Flag_FeelingFine2%/
            CaseOR == 8
                If *Flag_SJumpChg2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:SJumpChg
                SetConst *Var[2] *Flag_SJumpChg2
            EndCaseGroup
            Case == 9
                If *Flag_JumpCharge2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:JumpCharge
                SetConst *Var[2] *Flag_JumpCharge2
            Case == 10`
                If *Flag_DeepFocusA2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:DeepFocus1
                SetConst *Var[2] *Flag_DeepFocusA2
            Case == 11`
                If *Flag_DeepFocusB2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:DeepFocus2
                SetConst *Var[2] *Flag_DeepFocusB2
            Case == 12`
                If *Flag_DeepFocusC2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:DeepFocus3
                SetConst *Var[2] *Flag_DeepFocusC2
            Case == 13`
                If *Flag_HappyFlowerA2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:HappyFlowerA
                SetConst *Var[2] *Flag_HappyFlowerA2
            Case == 14`
                If *Flag_HappyFlowerB2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:HappyFlowerB
                SetConst *Var[2] *Flag_HappyFlowerB2
            Case == 15`
                If *Flag_DodgeMaster2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:DodgeMaster
                SetConst *Var[2] *Flag_DodgeMaster2
            Case == 16`
                If *Flag_ZapTap2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:ZapTap
                SetConst *Var[2] *Flag_ZapTap2
            Case == 17`
                If *Flag_Multibounce2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:Multibounce
                SetConst *Var[2] *Flag_Multibounce2
            Case == 18`
                If *Flag_DizzyAttack2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:DizzyAttack
                SetConst *Var[2] *Flag_DizzyAttack2
            Case == 19`
                If *Flag_PowerJump2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:PowerJump
                SetConst *Var[2] *Flag_PowerJump2
        EndSwitch
    Case >= 6 % High Tier
        Label HighTier
        Set *Var[1] .Default
        Add *Var[1] *Flag_FlowerSaverA2
        Add *Var[1] *Flag_FlowerSaverB2
        Add *Var[1] *Flag_HeartFinder2
        Add *Var[1] *Flag_FlowerFinder2
        Add *Var[1] *Flag_CloseCall2
        Add *Var[1] *Flag_DefendPlus2
        Add *Var[1] *Flag_PDownDUp2
        Add *Var[1] *Flag_PowerPlusA2
        Add *Var[1] *Flag_PowerPlusB2
        Add *Var[1] *Flag_QuickChange2
        Add *Var[1] *Flag_QuakeHammer2
        Add *Var[1] *Flag_PowerQuake2
        Add *Var[1] *Flag_DoubleDip2
        Add *Var[1] *Flag_PowerRush2
        %Add *Var[1] *Flag_DDownJump2
        Add *Var[1] *Flag_PUpDDown2
        Add *Var[1] *Flag_AllorNothing2
        Add *Var[1] *Flag_MegaRush2
        Add *Var[1] *Flag_PowerBounce2
        Add *Var[1] *Flag_LastStand2
        Add *Var[1] *Flag_DamageDodgeA2
        Add *Var[1] *Flag_DamageDodgeB2
        Add *Var[1] *Flag_HPDrain2
        If *Var[1] == 22`
            Set *MapVar[F] 4
            Wait 1
            Goto LowTier
        EndIf
        Call RandInt ( 22` *Var[0] )
        % scrapped badges
		Switch *Var[0]
			CaseOR == 14` % D Down Jump
				Add *Var[0] 1 % just load the next badge
			EndCaseGroup
		EndSwitch
        Switch *Var[0]
            Case == 0
                If *Flag_FlowerSaverA2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:FlowerSaverA
                SetConst *Var[2] *Flag_FlowerSaverA2
            Case == 1
                If *Flag_FlowerSaverB2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:FlowerSaverB
                SetConst *Var[2] *Flag_FlowerSaverB2
            Case == 2
                If *Flag_HeartFinder2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:HeartFinder
                SetConst *Var[2] *Flag_HeartFinder2
            Case == 3
                If *Flag_FlowerFinder2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:FlowerFinder
                SetConst *Var[2] *Flag_FlowerFinder2
            Case == 4
                If *Flag_CloseCall2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:CloseCall
                SetConst *Var[2] *Flag_CloseCall2
            Case == 5
                If *Flag_DefendPlus2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:DefendPlusA
                SetConst *Var[2] *Flag_DefendPlus2
            Case == 6
                If *Flag_PDownDUp2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:PDownDUp
                SetConst *Var[2] *Flag_PDownDUp2
            Case == 7
                If *Flag_PowerPlusA2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:PowerPlusA
                SetConst *Var[2] *Flag_PowerPlusA2
            Case == 8
                If *Flag_PowerPlusB2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:PowerPlusB
                SetConst *Var[2] *Flag_PowerPlusB2
            Case == 9
                If *Flag_QuickChange2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:QuickChange
                SetConst *Var[2] *Flag_QuickChange2
            Case == 10`
                If *Flag_QuakeHammer2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:QuakeHammer
                SetConst *Var[2] *Flag_QuakeHammer2
            Case == 11`
                If *Flag_PowerQuake2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:PowerQuake
                SetConst *Var[2] *Flag_PowerQuake2
            Case == 12`
                If *Flag_DoubleDip2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:DoubleDip
                SetConst *Var[2] *Flag_DoubleDip2
            Case == 13`
                If *Flag_PowerRush2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:PowerRush
                SetConst *Var[2] *Flag_PowerRush2
            /%Case == 14`
                If *Flag_DDownJump2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:DDownJump
                SetConst *Var[2] *Flag_DDownJump2%/
            Case == 15`
                If *Flag_PUpDDown2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:PUpDDown
                SetConst *Var[2] *Flag_PUpDDown2
            Case == 16`
                If *Flag_AllorNothing2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:AllorNothing
                SetConst *Var[2] *Flag_AllorNothing2
            Case == 17`
                If *Flag_MegaRush2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:MegaRush
                SetConst *Var[2] *Flag_MegaRush2
            Case == 18`
                If *Flag_PowerBounce2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:PowerBounce
                SetConst *Var[2] *Flag_PowerBounce2
            Case == 19`
                If *Flag_LastStand2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:LastStand
                SetConst *Var[2] *Flag_LastStand2
            Case == 20`
                If *Flag_DamageDodgeA2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:DamageDodgeA
                SetConst *Var[2] *Flag_DamageDodgeA2
            Case == 21`
                If *Flag_DamageDodgeB2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:DamageDodgeB
                SetConst *Var[2] *Flag_DamageDodgeB2
            Case == 22`
                If *Flag_HPDrain2 == .True
                    Jump $Script_Reward_SpawnBadge
                EndIf
                Set *Var[0] .Item:HPDrain
                SetConst *Var[2] *Flag_HPDrain2
        EndSwitch
EndSwitch
% Check if the badge loaded has already been spawned on this floor
Call    $Function_GetData_RewardIDs
% Var6 = RewardID1
% Var7 = RewardID2
% Var8 = RewardID3
% Var9 = RewardID4
Switch *Var[0]
    CaseOR == *Var[6]
    CaseOR == *Var[7]
    CaseOR == *Var[8]
    CaseOR == *Var[9]
        Jump $Script_Reward_SpawnBadge
    EndCaseGroup
EndSwitch
% If not, write the ID
Call    $Function_WriteData_RewardIDs
Call    $Function_Reward_GetDataX % save in VarA/B/C
% To know what NPC need to be spawned when using a Battle Based Spring
% save rarity var for current reward
Switch *MapVar[F]
    Case <= 4 % Low Tier
        Set     *Var[D] 1
    Case == 5 % Medium Tier
        Set     *Var[D] 2
    Case >= 6 % High Tier
        Set     *Var[D] 3
EndSwitch
Call    $Function_Save_RewardData ( *Var[D] ) % used for battle based springs
ExecWait $Script_Entity_AdjustSpringTrap % check if the obstacle from some spring trap needs to be adjusted
ExecWait $Script_Reward_SetItemPos
Return
End
}

#export $Script_Reward_SpawnBadge

#new:Script:Map $Script_Reward_Badges_CheckAllFlags
{
Set *Var[1] .Default
% Low Tier
Add *Var[1] *Flag_SlowGo2
Add *Var[1] *Flag_LuckyDay2
Add *Var[1] *Flag_Peekaboo2
Add *Var[1] *Flag_SSmashChg2
Add *Var[1] *Flag_Spin_Smash2
Add *Var[1] *Flag_PayOff2
Add *Var[1] *Flag_Money_Money2
Add *Var[1] *Flag_Chill_Out2
Add *Var[1] *Flag_Pretty_Lucky2
Add *Var[1] *Flag_Hammer_Throw2
Add *Var[1] *Flag_MegaSmash2
Add *Var[1] *Flag_MegaJump2
Add *Var[1] *Flag_Refund2
Add *Var[1] *Flag_SmashCharge2
Add *Var[1] *Flag_SpikeShield2
%Add *Var[1] *Flag_DDownPound2
Add *Var[1] *Flag_PowerSmash2
Add *Var[1] *Flag_SleepStomp2
Add *Var[1] *Flag_DizzyStomp2
Add *Var[1] *Flag_MegaQuake2
% Middle Tier
Add *Var[1] *Flag_TripleDip2
Add *Var[1] *Flag_ShrinkStomp2
Add *Var[1] *Flag_GroupFocus2
Add *Var[1] *Flag_FireShield2
Add *Var[1] *Flag_HappyHeartA2
Add *Var[1] *Flag_HappyHeartB2
Add *Var[1] *Flag_IcePower2
%Add *Var[1] *Flag_FeelingFine2
Add *Var[1] *Flag_SJumpChg2
Add *Var[1] *Flag_JumpCharge2
Add *Var[1] *Flag_DeepFocusA2
Add *Var[1] *Flag_DeepFocusB2
Add *Var[1] *Flag_DeepFocusC2
Add *Var[1] *Flag_HappyFlowerA2
Add *Var[1] *Flag_HappyFlowerB2
Add *Var[1] *Flag_DodgeMaster2
Add *Var[1] *Flag_ZapTap2
Add *Var[1] *Flag_Multibounce2
Add *Var[1] *Flag_DizzyAttack2
Add *Var[1] *Flag_PowerJump2
% High Tier
Add *Var[1] *Flag_FlowerSaverA2
Add *Var[1] *Flag_FlowerSaverB2
Add *Var[1] *Flag_HeartFinder2
Add *Var[1] *Flag_FlowerFinder2
Add *Var[1] *Flag_CloseCall2
Add *Var[1] *Flag_DefendPlus2
Add *Var[1] *Flag_PDownDUp2
Add *Var[1] *Flag_PowerPlusA2
Add *Var[1] *Flag_PowerPlusB2
Add *Var[1] *Flag_QuickChange2
Add *Var[1] *Flag_QuakeHammer2
Add *Var[1] *Flag_PowerQuake2
Add *Var[1] *Flag_DoubleDip2
Add *Var[1] *Flag_PowerRush2
%Add *Var[1] *Flag_DDownJump2
Add *Var[1] *Flag_PUpDDown2
Add *Var[1] *Flag_AllorNothing2
Add *Var[1] *Flag_MegaRush2
Add *Var[1] *Flag_PowerBounce2
Add *Var[1] *Flag_LastStand2
Add *Var[1] *Flag_DamageDodgeA2
Add *Var[1] *Flag_DamageDodgeB2
Add *Var[1] *Flag_HPDrain2
Return
End
}

% Only used in LoadBadgeLists.mpat (when getting a Badge from a Giant Chest)
#new:Script:Map $Script_Reward_Badges_CheckAllFlags_ExceptHPDrain_PDownDUpANDSlowGo
{
Set *Var[1] .Default
% Low Tier
%Add *Var[1] *Flag_SlowGo2
Add *Var[1] *Flag_LuckyDay2
Add *Var[1] *Flag_Peekaboo2
Add *Var[1] *Flag_SSmashChg2
Add *Var[1] *Flag_Spin_Smash2
Add *Var[1] *Flag_PayOff2
Add *Var[1] *Flag_Money_Money2
Add *Var[1] *Flag_Chill_Out2
Add *Var[1] *Flag_Pretty_Lucky2
Add *Var[1] *Flag_Hammer_Throw2
Add *Var[1] *Flag_MegaSmash2
Add *Var[1] *Flag_MegaJump2
Add *Var[1] *Flag_Refund2
Add *Var[1] *Flag_SmashCharge2
Add *Var[1] *Flag_SpikeShield2
%Add *Var[1] *Flag_DDownPound2
Add *Var[1] *Flag_PowerSmash2
Add *Var[1] *Flag_SleepStomp2
Add *Var[1] *Flag_DizzyStomp2
Add *Var[1] *Flag_MegaQuake2
% Middle Tier
Add *Var[1] *Flag_TripleDip2
Add *Var[1] *Flag_ShrinkStomp2
Add *Var[1] *Flag_GroupFocus2
Add *Var[1] *Flag_FireShield2
Add *Var[1] *Flag_HappyHeartA2
Add *Var[1] *Flag_HappyHeartB2
Add *Var[1] *Flag_IcePower2
%Add *Var[1] *Flag_FeelingFine2
Add *Var[1] *Flag_SJumpChg2
Add *Var[1] *Flag_JumpCharge2
Add *Var[1] *Flag_DeepFocusA2
Add *Var[1] *Flag_DeepFocusB2
Add *Var[1] *Flag_DeepFocusC2
Add *Var[1] *Flag_HappyFlowerA2
Add *Var[1] *Flag_HappyFlowerB2
Add *Var[1] *Flag_DodgeMaster2
Add *Var[1] *Flag_ZapTap2
Add *Var[1] *Flag_Multibounce2
Add *Var[1] *Flag_DizzyAttack2
Add *Var[1] *Flag_PowerJump2
% High Tier
Add *Var[1] *Flag_FlowerSaverA2
Add *Var[1] *Flag_FlowerSaverB2
Add *Var[1] *Flag_HeartFinder2
Add *Var[1] *Flag_FlowerFinder2
Add *Var[1] *Flag_CloseCall2
Add *Var[1] *Flag_DefendPlus2
%Add *Var[1] *Flag_PDownDUp2
Add *Var[1] *Flag_PowerPlusA2
Add *Var[1] *Flag_PowerPlusB2
Add *Var[1] *Flag_QuickChange2
Add *Var[1] *Flag_QuakeHammer2
Add *Var[1] *Flag_PowerQuake2
Add *Var[1] *Flag_DoubleDip2
Add *Var[1] *Flag_PowerRush2
%Add *Var[1] *Flag_DDownJump2
Add *Var[1] *Flag_PUpDDown2
Add *Var[1] *Flag_AllorNothing2
Add *Var[1] *Flag_MegaRush2
Add *Var[1] *Flag_PowerBounce2
Add *Var[1] *Flag_LastStand2
Add *Var[1] *Flag_DamageDodgeA2
Add *Var[1] *Flag_DamageDodgeB2
%Add *Var[1] *Flag_HPDrain2
Return
End
}

#export $Script_Reward_Badges_CheckAllFlags
#export $Script_Reward_Badges_CheckAllFlags_ExceptHPDrain_PDownDUpANDSlowGo

#new:Function $Function_GetData_RewardIDs
{
PUSH	RA, V0, A1, A2
LAHU 	A2, $Reward_RewardID1
LIO 	A1, *Var[6]
JAL 	~Func:set_variable
RESERVED
LAHU 	A2, $Reward_RewardID2
LIO 	A1, *Var[7]
JAL 	~Func:set_variable
RESERVED
LAHU 	A2, $Reward_RewardID3
LIO 	A1, *Var[8]
JAL 	~Func:set_variable
RESERVED
LAHU 	A2, $Reward_RewardID4
LIO 	A1, *Var[9]
JAL 	~Func:set_variable
RESERVED
JPOP	RA, V0, A1, A2
}

% Check the next available ID to use
#new:Function $Function_WriteData_RewardIDs
{
PUSH	RA, V0, A1, A2
LAHU    T0, $Reward_RewardID1
BNE     T0, R0, .CheckID2
NOP
LIO    T1, $Reward_RewardID1
BEQ     R0, R0, .WriteID
NOP
.CheckID2
LAHU    T0, $Reward_RewardID2
BNE     T0, R0, .CheckID3
NOP
LIO    T1, $Reward_RewardID2
BEQ     R0, R0, .WriteID
NOP
.CheckID3
LAHU    T0, $Reward_RewardID3
BNE     T0, R0, .CheckID4
NOP
LIO    T1, $Reward_RewardID3
BEQ     R0, R0, .WriteID
NOP
.CheckID4
% If all other IDs was already used use ID4
LIO     T1, $Reward_RewardID4
.WriteID
LIO 	A1, *Var[0] % Item/Badge ID
JAL 	~Func:get_variable 
RESERVED
SH      V0, 0 (T1) % save ID % save as 0000XXXX
POP     RA, V0, A1, A2
JR      RA
ADDIU   V0, R0, 2
}

% Reads this 2 vars:
%
% var0 = itemID
%
% var2 = ItemFlag
#new:Script:Map $Script_Reward_SetItemPos
{
Call $Function_Reward_GetDataX % save in VarA/B/C
Switch *Var[B]
    CaseOR == 2
    CaseOR == 12`
    CaseOR == 14`
    CaseOR == 16`
    CaseOR == 17`
    CaseOR == 18`
    CaseOR == 20`
    CaseOR == 21`
        Set *Var[1] 63` % Hight 2
    EndCaseGroup
    Default
        Set *Var[1] 26` % Hight 1
EndSwitch
Switch *Var[A]
    Case == 1
        Call     DropItemEntity   ( *Var[0] -721` *Var[1] -55` 11 *Var[2] )
    Case == 2
        Call     DropItemEntity   ( *Var[0] -342` *Var[1] -55` 11 *Var[2] )
    Case == 3
        Call     DropItemEntity   ( *Var[0] -342` *Var[1] 150` 11 *Var[2] )
    Case == 4
        Call     DropItemEntity   ( *Var[0] -721` *Var[1] 150` 11 *Var[2] )
    % Switches - set the items position a lot of pixels below
    Case == 5
        Call     DropItemEntity   ( *Var[0] -579` -400` 60` 11 *Var[2] )
        % save ItemIndex in var0, used when the switch is pressed
        Set     *Var[3] 5
        Call    $Function_Reward_GetSwitchVarToUse
    Case == 6
        Call     DropItemEntity   ( *Var[0] -492` -400` 60` 11 *Var[2] )
        Set     *Var[3] 6
        Call    $Function_Reward_GetSwitchVarToUse
    % Pillars
    Case == 1000
        Call     DropItemEntity   ( *Var[0] -582` *Var[1] -71` 11 *Var[2] )
    Case == 0100
        Call     DropItemEntity   ( *Var[0] -535` *Var[1] -71` 11 *Var[2] )
    Case == 0010
        Call     DropItemEntity   ( *Var[0] -486` *Var[1] -71` 11 *Var[2] )
    Case == 1001
        Call     DropItemEntity   ( *Var[0] -582` *Var[1] 166` 11 *Var[2] )
    Case == 0101
        Call     DropItemEntity   ( *Var[0] -535` *Var[1] 166` 11 *Var[2] )
    Case == 0011
        Call     DropItemEntity   ( *Var[0] -486` *Var[1] 166` 11 *Var[2] )
EndSwitch
Return
End
}

#new:Script:Map $Script_Reward_ReadSpringkeeper % unused
{
Call $Function_Reward_GetDataX % save in varA/B/C
/% *Var[A] .Rogue_Item_X % reward spawn point %/
% Check what NPC is the one on the spring
Set *Var[2] 50
Loop
    Call    GetNpcPos 	( *Var[2] *Var[0] .False *Var[1] )
    % The npc is on the left side of the room?
    If  *Var[0] < -534`
        If *Var[1] < 78` % 1 % Top Left
            % Check Item Spawn Point
            If .Reward_Pos == 1
                BreakLoop
            EndIf
        Else % 4 % Bottom Left        
            % Check Item Spawn Point
            If .Reward_Pos == 4
                BreakLoop
            EndIf
        EndIf
    % The npc is on the right side of the room?
    Else
        If *Var[1] < 78` % 2 % Top Right
            % Check Item Spawn Point
            If .Reward_Pos == 2
                BreakLoop
            EndIf
        Else % 3 % Bottom Right
            % Check Item Spawn Point
            If .Reward_Pos == 3
                BreakLoop
            EndIf
        EndIf
    EndIf
    Add *Var[2] 1 % check next NPC ID
    Wait 1
EndLoop
% Set Var accordingly to the current NPCID
/% *Var[2] == Springkeeper NpcID
%/
Switch *Var[2]
    Case == 50 % Koopatropa
        Set *Var[0] 1
    Case == 51 % Forest Fuzzy
        Set *Var[0] 1
    Case == 52 % Bleft
        Set *Var[0] 1
    Case == 53 % Spy Guy
        Set *Var[0] 2
    Case == 54 % Jungle Fuzzy
        Set *Var[0] 2
    Case == 55 % Crazee Dayzee
        Set *Var[0] 2
    Case == 56 % Lakitu
        Set *Var[0] 2
    Case == 57 % White Clubba
        Set *Var[0] 3
    Case == 58 % Hammer Bros.
        Set *Var[0] 3
    Case == 59 % Ember Guy
        Set *Var[0] 4
EndSwitch
Return
End
}

#new:Script:Map $Script_DisableColliders_Roguelike
{
% Disabling all collitions one by one because you can't do it by using groups.... F!
% [Stairs]
% Stairs 1 %
Call ModifyColliderFlags ( .False .Collider_Stairs_Set1_1-1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set1_1-2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set1_2-1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set1_2-2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set1_3-1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set1_3-2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set1_4-1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set1_4-2 7FFFFE00 )
% Stairs 2 %
Call ModifyColliderFlags ( .False .Collider_Stairs_Set2_1-1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set2_1-2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set2_2-1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set2_2-2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set2_3-1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set2_3-2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set2_4-1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Stairs_Set2_4-2 7FFFFE00 )
% [Corners]
% Corners 1 %
Call ModifyColliderFlags ( .False .Collider_Corners_Set1_1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Corners_Set1_2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Corners_Set1_3 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Corners_Set1_4 7FFFFE00 )
% Corners 2 %
Call ModifyColliderFlags ( .False .Collider_Corners_Set2_1-1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Corners_Set2_1-2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Corners_Set2_2-1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Corners_Set2_2-2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Corners_Set2_3-1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Corners_Set2_3-2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Corners_Set2_4-1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Corners_Set2_4-2 7FFFFE00 )
% [Floors]
Call ModifyColliderFlags ( .False .Collider_Floors_Up 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Floors_Right 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Floors_Down 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Floors_Left 7FFFFE00 )
% [walls]
Call ModifyColliderFlags ( .False .Collider_Walls_Up 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Walls_Right 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Walls_Down 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Walls_Left 7FFFFE00 )
%[Pillars]
% Up %
Call ModifyColliderFlags ( .False .Collider_Pillars_Up_100 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Pillars_Up_010 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Pillars_Up_001 7FFFFE00 )
% Down %
Call ModifyColliderFlags ( .False .Collider_Pillars_Down_100 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Pillars_Down_010 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Pillars_Down_001 7FFFFE00 )
%[Spikes]
%[[Spikesss]]%
% Floors %
Call ModifyColliderFlags ( .False .Collider_Spikes_Floors_1_Up 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spikes_Floors_1_Right 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spikes_Floors_1_Down 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spikes_Floors_1_Left 7FFFFE00 )
%
Call ModifyColliderFlags ( .False .Collider_Spikes_Floors_2_Up 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spikes_Floors_2_Right 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spikes_Floors_2_Down 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spikes_Floors_2_Left 7FFFFE00 )
% Corners %
Call ModifyColliderFlags ( .False .Collider_Spikes_Corners_1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spikes_Corners_2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spikes_Corners_3 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spikes_Corners_4 7FFFFE00 )
% [Waterpads]
% Walls
Call ModifyColliderFlags ( .False .Collider_Waterpads_Walls_Up 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Waterpads_Walls_Down 7FFFFE00 )
% Pools
Call ModifyColliderFlags ( .False .Collider_Waterpads_Pools_Up 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Waterpads_Pools_Down 7FFFFE00 )
% Pads
Call ModifyColliderFlags ( .False .Collider_Waterpads_Pads_Floor_1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Waterpads_Pads_Floor_2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Waterpads_Pads_Floor_3 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Waterpads_Pads_Floor_4 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Waterpads_Pads_Walls_1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Waterpads_Pads_Walls_2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Waterpads_Pads_Walls_3 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Waterpads_Pads_Walls_4 7FFFFE00 )
% Springs
Call ModifyColliderFlags ( .False .Collider_Spring_Top_1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spring_Top_2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spring_Top_3 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spring_Top_4 7FFFFE00 )
%
Call ModifyColliderFlags ( .False .Collider_Spring_Wall_1 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spring_Wall_2 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spring_Wall_3 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Spring_Wall_4 7FFFFE00 )
% Bombette
Call ModifyColliderFlags ( .False .Collider_Bombette_Up 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Bombette_Right 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Bombette_Down 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Bombette_Left 7FFFFE00 )
% Blocks
Call ModifyColliderFlags ( .False .Collider_Block_Up 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Block_Right 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Block_Down 7FFFFE00 )
Call ModifyColliderFlags ( .False .Collider_Block_Left 7FFFFE00 )
Return
End
}

#export $Script_DisableColliders_Roguelike

#new:Data $ResetPos1
{
00000000 C4340000 00000000 C25C0000 % -720.000000 0.000000 -55.000000
FFFFFFFF 00000000 00000000 00000000 % 0.000000 0.000000 0.000000
00000000
}

#new:Data $ResetPos2
{
00000000 C3AA8000 00000000 C25C0000 % -341.000000 0.000000 -55.000000
FFFFFFFF 00000000 00000000 00000000 % 0.000000 0.000000 0.000000
00000000
}

#new:Data $ResetPos3
{
00000000 C3AA8000 00000000 43150000 % -341.000000 0.000000 149.000000
FFFFFFFF 00000000 00000000 00000000 % 0.000000 0.000000 0.000000
00000000
}

#new:Data $ResetPos4
{
00000000 C4340000 00000000 43150000 % -720.000000 0.000000 149.000000
FFFFFFFF 00000000 00000000 00000000 % 0.000000 0.000000 0.000000
00000000
}

#new:Script:Map $Script_Roguelike_MoveSpikes
{
    SetGroup EF
    % Get Collition and Models
    Switch .Rogue_SpawnPoint
        Case == 1 % Upper L
            Set *Var[9] $ResetPos1
            If .Rogue_SpawnSide == 0 % Up/Down stairs
                Set *Var[3] .Collider_Spikes_Floors_1_Up
                Set *Var[4] .Collider_Spikes_Floors_1_Right
                Set *Var[5] .Collider_Spikes_Corners_2
                Set *Var[6] .Model_Spikes_Floors_Up
                Set *Var[7] .Model_Spikes_Floors_Right
                Set *Var[8] .Model_Spikes_Corners_2
            Else % L/R stairs
                Set *Var[3] .Collider_Spikes_Floors_1_Left
                Set *Var[4] .Collider_Spikes_Floors_1_Down
                Set *Var[5] .Collider_Spikes_Corners_4
                Set *Var[6] .Model_Spikes_Floors_Left
                Set *Var[7] .Model_Spikes_Floors_Down
                Set *Var[8] .Model_Spikes_Corners_4
            EndIf
        Case == 2 % Upper R
            Set *Var[9] $ResetPos2
            If .Rogue_SpawnSide == 0 % Up/Down stairs
                Set *Var[3] .Collider_Spikes_Floors_1_Up
                Set *Var[4] .Collider_Spikes_Floors_1_Left
                Set *Var[5] .Collider_Spikes_Corners_1
                Set *Var[6] .Model_Spikes_Floors_Up
                Set *Var[7] .Model_Spikes_Floors_Left
                Set *Var[8] .Model_Spikes_Corners_1
            Else % L/R stairs
                Set *Var[3] .Collider_Spikes_Floors_1_Right
                Set *Var[4] .Collider_Spikes_Floors_1_Down
                Set *Var[5] .Collider_Spikes_Corners_3
                Set *Var[6] .Model_Spikes_Floors_Right
                Set *Var[7] .Model_Spikes_Floors_Down
                Set *Var[8] .Model_Spikes_Corners_3
            EndIf
        Case == 3 % Bottom R
            Set *Var[9] $ResetPos3
            If .Rogue_SpawnSide == 0 % Up/Down stairs
                Set *Var[3] .Collider_Spikes_Floors_1_Down
                Set *Var[4] .Collider_Spikes_Floors_1_Left
                Set *Var[5] .Collider_Spikes_Corners_4
                Set *Var[6] .Model_Spikes_Floors_Down
                Set *Var[7] .Model_Spikes_Floors_Left
                Set *Var[8] .Model_Spikes_Corners_4
            Else % L/R stairs
                Set *Var[3] .Collider_Spikes_Floors_1_Right
                Set *Var[4] .Collider_Spikes_Floors_1_Up
                Set *Var[5] .Collider_Spikes_Corners_2
                Set *Var[6] .Model_Spikes_Floors_Right
                Set *Var[7] .Model_Spikes_Floors_Up
                Set *Var[8] .Model_Spikes_Corners_2
            EndIf
        Case == 4 % Bottom L
            Set *Var[9] $ResetPos4
            If .Rogue_SpawnSide == 0 % Up/Down stairs
                Set *Var[3] .Collider_Spikes_Floors_1_Down
                Set *Var[4] .Collider_Spikes_Floors_1_Right
                Set *Var[5] .Collider_Spikes_Corners_3
                Set *Var[6] .Model_Spikes_Floors_Down
                Set *Var[7] .Model_Spikes_Floors_Right
                Set *Var[8] .Model_Spikes_Corners_3
            Else % L/R stairs
                Set *Var[3] .Collider_Spikes_Floors_1_Left
                Set *Var[4] .Collider_Spikes_Floors_1_Up
                Set *Var[5] .Collider_Spikes_Corners_1
                Set *Var[6] .Model_Spikes_Floors_Left
                Set *Var[7] .Model_Spikes_Floors_Up
                Set *Var[8] .Model_Spikes_Corners_1
            EndIf
    EndSwitch
    % Set Colliders to hurt Mario
    Call    ModifyColliderFlags 	( 3 *Var[3] 00000002 )
    Call    ModifyColliderFlags 	( 3 *Var[4] 00000002 )
    Call    ModifyColliderFlags 	( 3 *Var[5] 00000002 )
    % Position to set after getting hurt
	Thread
		Call    ResetFromLava 	( *Var[9] )
	EndThread
    Wait    50`
    Call     TranslateModel ( *Var[6] 0 0 0 )
    Call     TranslateModel ( *Var[7] 0 0 0 )
    Call     TranslateModel ( *Var[8] 0 0 0 )
    Call     ParentColliderToModel 	( *Var[3] *Var[6] )
    Call     ParentColliderToModel 	( *Var[4] *Var[7] )
    Call     ParentColliderToModel 	( *Var[5] *Var[8] )
    Loop
        % Spikes go down
		Call     MakeLerp    	( 0 -35` 15` 0 )
		Loop     
			Call     UpdateLerp
            Call     TranslateModel ( *Var[6] 0 *Var[0] 0 )
            Call     TranslateModel ( *Var[7] 0 *Var[0] 0 )
            Call     TranslateModel ( *Var[8] 0 *Var[0] 0 )
            Call     UpdateColliderTransform 	( *Var[3] )
            Call     UpdateColliderTransform 	( *Var[4] )
            Call     UpdateColliderTransform 	( *Var[5] )
			Wait     1
			If  *Var[1]  ==  0
				BreakLoop
			EndIf
        EndLoop
        % The spikes stop if the giant chest get opened
        If  .Flag_GiantChestParentToSpikes == .True
            If  .Flag_GiantChestOpened == .True
                Return
            EndIf
        EndIf
        Wait     60` % cooldown
        % The spikes stop if the giant chest get opened
        If  .Flag_GiantChestParentToSpikes == .True
            If  .Flag_GiantChestOpened == .True
                Return
            EndIf
        EndIf
        % Spikes go up
		Call     PlaySoundAtCollider 	( *Var[3] 2093 0 )
		Call     MakeLerp    	( -35` 0 4 0 )
		Loop
			Call     UpdateLerp
            Call     TranslateModel ( *Var[6] 0 *Var[0] 0 )
            Call     TranslateModel ( *Var[7] 0 *Var[0] 0 )
            Call     TranslateModel ( *Var[8] 0 *Var[0] 0 )
            Call     UpdateColliderTransform 	( *Var[3] )
            Call     UpdateColliderTransform 	( *Var[4] )
            Call     UpdateColliderTransform 	( *Var[5] )
			Wait     1
			If  *Var[1]  ==  0
				BreakLoop
			EndIf
		EndLoop
		Wait    35`
	EndLoop
	Return
	End%/
}
      
% Define Models and Colliders for Roguelike Mode
%% Models %%
%% Model - Groups %%
#export .Model_Group_Roguelike D1
% Stairs
#define .Model_Group_Stairs 45
#define .Model_Group_Stairs_Set1 37
#define .Model_Group_Stairs_Set1_1 2D
#define .Model_Group_Stairs_Set1_2 30
#define .Model_Group_Stairs_Set1_3 33
#define .Model_Group_Stairs_Set1_4 36
#define .Model_Group_Stairs_Set2 44
#define .Model_Group_Stairs_Set2_1 3A
#define .Model_Group_Stairs_Set2_2 3D
#define .Model_Group_Stairs_Set2_3 40
#define .Model_Group_Stairs_Set2_4 43
% Corners
#define .Model_Group_Corners 58
#define .Model_Group_Corners_Set1 4A
#define .Model_Group_Corners_Set2 57
#define .Model_Group_Corners_Set2_1 4D
#define .Model_Group_Corners_Set2_2 50
#define .Model_Group_Corners_Set2_3 53
#define .Model_Group_Corners_Set2_4 56
% Floors
#define .Model_Group_Floors 5D
% Pillars
#define .Model_Group_Pillars 66
#define .Model_Group_Pillars_Up 61
#define .Model_Group_Pillars_Down 65
% Spikes % Everything related to the spikes
#define .Model_Group_Spikes 7D
#define .Model_Group_Spikes_Spikes 71 % the spikes geometry
#define .Model_Group_Spikes_Spikes_Floors 6B
#define .Model_Group_Spikes_Spikes_Corners 70
#define .Model_Group_Spikes_Holes 7C
#define .Model_Group_Spikes_Holes_Floors 76
#define .Model_Group_Spikes_Holes_Corners 7B
% Waterpads/Sushie Pads
#define .Model_Group_Waterpads 89
#define .Model_Group_Waterpads_Walls 80
#define .Model_Group_Waterpads_Pools 83
#define .Model_Group_Waterpads_Pads 88
% Icons
#define .Model_Group_Icons 99
#define .Model_Group_Icons_Boots 8E
#define .Model_Group_Icons_Goombario 93
#define .Model_Group_Icons_Watt 98
% Engine
#define .Model_Group_Engine AA
#define .Model_Group_Engine_1 9D
#define .Model_Group_Engine_2 A1
#define .Model_Group_Engine_3 A5
#define .Model_Group_Engine_4 A9
% Bombette Blocks
#define .Model_Group_Bombette B5
#define .Model_Group_Bombette_Blocks AF
#define .Model_Group_Bombette_Cracks B4
% Blocks
#define .Model_Group_Blocks C0
#define .Model_Group_Blocks_Super BA
#define .Model_Group_Blocks_Ultra BF

%% Model - Geometry %%
% [Stairs]
% Stairs 1 %
#define .Model_Stairs_Set1_1-1 2B
#define .Model_Stairs_Set1_1-2 2C
#define .Model_Stairs_Set1_2-1 2E
#define .Model_Stairs_Set1_2-2 2F
#define .Model_Stairs_Set1_3-1 31
#define .Model_Stairs_Set1_3-2 32
#define .Model_Stairs_Set1_4-1 34
#define .Model_Stairs_Set1_4-2 35
% Stairs 2 %
#define .Model_Stairs_Set2_1-1 38
#define .Model_Stairs_Set2_1-2 39
#define .Model_Stairs_Set2_2-1 3B
#define .Model_Stairs_Set2_2-2 3C
#define .Model_Stairs_Set2_3-1 3E
#define .Model_Stairs_Set2_3-2 3F
#define .Model_Stairs_Set2_4-1 41
#define .Model_Stairs_Set2_4-2 42
% [Corners]
% Corners 1 %
#define .Model_Corners_Set1_1 46
#define .Model_Corners_Set1_2 47
#define .Model_Corners_Set1_3 48
#define .Model_Corners_Set1_4 49
% Corners 2 %
#define .Model_Corners_Set2_1-1 4B
#define .Model_Corners_Set2_1-2 4C
#define .Model_Corners_Set2_2-1 4E
#define .Model_Corners_Set2_2-2 4F
#define .Model_Corners_Set2_3-1 51
#define .Model_Corners_Set2_3-2 52
#define .Model_Corners_Set2_4-1 54
#define .Model_Corners_Set2_4-2 55
%[Floors]
#define .Model_Floors_Up 59
#define .Model_Floors_Right 5A
#define .Model_Floors_Down 5B
#define .Model_Floors_Left 5C
%[Pillars]
% Up %
#define .Model_Pillars_Up_100 5E
#define .Model_Pillars_Up_010 5F
#define .Model_Pillars_Up_001 60
% Down %
#define .Model_Pillars_Down_100 62
#define .Model_Pillars_Down_010 63
#define .Model_Pillars_Down_001 64
%[Spikes]
%[[Spikesss]]%
% Floors %
#define .Model_Spikes_Floors_Up 67
#define .Model_Spikes_Floors_Right 68
#define .Model_Spikes_Floors_Down 69
#define .Model_Spikes_Floors_Left 6A
% Corners %
#define .Model_Spikes_Corners_1 6C
#define .Model_Spikes_Corners_2 6D
#define .Model_Spikes_Corners_3 6E
#define .Model_Spikes_Corners_4 6F
%[[Holes]]%
% Floors %
#define .Model_Holes_Floors_Up 72
#define .Model_Holes_Floors_Right 73
#define .Model_Holes_Floors_Down 74
#define .Model_Holes_Floors_Left 75
% Corners %
#define .Model_Holes_Corners_1 77
#define .Model_Holes_Corners_2 78
#define .Model_Holes_Corners_3 79
#define .Model_Holes_Corners_4 7A

% [Waterpads]
% Walls
#define .Model_Waterpads_Walls_Up 7E
#define .Model_Waterpads_Walls_Down 7F
% Pools
#define .Model_Waterpads_Pools_Up 81
#define .Model_Waterpads_Pools_Down 82
% Pads
#define .Model_Waterpads_Pads_1 84
#define .Model_Waterpads_Pads_2 85
#define .Model_Waterpads_Pads_3 86
#define .Model_Waterpads_Pads_4 87

%% Icons
% Boots
#define .Model_Boots_1 8A
#define .Model_Boots_2 8B
#define .Model_Boots_3 8C
#define .Model_Boots_4 8D
% Goombario
#define .Model_Goombario_1 8F
#define .Model_Goombario_2 90
#define .Model_Goombario_3 91
#define .Model_Goombario_4 92
% Watt
#define .Model_Watt_1 94
#define .Model_Watt_2 95
#define .Model_Watt_3 96
#define .Model_Watt_4 97

%% Engine
% 1
#define .Model_Engine_1_Box 9A
#define .Model_Engine_1_Green 9B
#define .Model_Engine_1_Red 9C
% 2
#define .Model_Engine_2_Box 9E
#define .Model_Engine_2_Green 9F
#define .Model_Engine_2_Red A0
% 3
#define .Model_Engine_3_Box A2
#define .Model_Engine_3_Green A3
#define .Model_Engine_3_Red A4
% 4
#define .Model_Engine_4_Box A6
#define .Model_Engine_4_Green A7
#define .Model_Engine_4_Red A8

%%% Bombette Blocks
%% Blocks
#define .Model_Bombette_Block_Up AB
#define .Model_Bombette_Block_Right AC
#define .Model_Bombette_Block_Down AD
#define .Model_Bombette_Block_Left AE
%% Cracks
#define .Model_Bombette_Crack_Up B0
#define .Model_Bombette_Crack_Right B1
#define .Model_Bombette_Crack_Down B2
#define .Model_Bombette_Crack_Left B3

%%% Blocks
%% Super
#define .Model_Block_Super_Up B6
#define .Model_Block_Super_Right B7
#define .Model_Block_Super_Down B8
#define .Model_Block_Super_Left B9
%% Ultra 
#define .Model_Block_Ultra_Up BB
#define .Model_Block_Ultra_Right BC
#define .Model_Block_Ultra_Down BD
#define .Model_Block_Ultra_Left BE

%%% Spring's Color Panels
%% Yellow
#define .Model_Color_Yellow_1 C1
#define .Model_Color_Yellow_2 C2
#define .Model_Color_Yellow_3 C3
#define .Model_Color_Yellow_4 C4
%% Blue
#define .Model_Color_Blue_1 C6
#define .Model_Color_Blue_2 C7
#define .Model_Color_Blue_3 C8
#define .Model_Color_Blue_4 C9
%% Red
#define .Model_Color_Red_1 CB
#define .Model_Color_Red_2 CC
#define .Model_Color_Red_3 CD
#define .Model_Color_Red_4 CE

% Sign
#export .Model_Sign D2

%% Colliders - Geometry
% [Stairs]
% Stairs 1 %
#define .Collider_Stairs_Set1_1-1 0C
#define .Collider_Stairs_Set1_1-2 0D
#define .Collider_Stairs_Set1_2-1 0F
#define .Collider_Stairs_Set1_2-2 10
#define .Collider_Stairs_Set1_3-1 12
#define .Collider_Stairs_Set1_3-2 13
#define .Collider_Stairs_Set1_4-1 15
#define .Collider_Stairs_Set1_4-2 16
% Stairs 2 %
#define .Collider_Stairs_Set2_1-1 19
#define .Collider_Stairs_Set2_1-2 1A
#define .Collider_Stairs_Set2_2-1 1C
#define .Collider_Stairs_Set2_2-2 1D
#define .Collider_Stairs_Set2_3-1 1F
#define .Collider_Stairs_Set2_3-2 20
#define .Collider_Stairs_Set2_4-1 22
#define .Collider_Stairs_Set2_4-2 23
% [Corners]
% Corners 1 %
#define .Collider_Corners_Set1_1 27
#define .Collider_Corners_Set1_2 28
#define .Collider_Corners_Set1_3 29
#define .Collider_Corners_Set1_4 2A
% Corners 2 %
#define .Collider_Corners_Set2_1-1 2C
#define .Collider_Corners_Set2_1-2 2D
#define .Collider_Corners_Set2_2-1 2F
#define .Collider_Corners_Set2_2-2 30
#define .Collider_Corners_Set2_3-1 32
#define .Collider_Corners_Set2_3-2 33
#define .Collider_Corners_Set2_4-1 35
#define .Collider_Corners_Set2_4-2 36
%[Floors]
#define .Collider_Floors_Up 3A
#define .Collider_Floors_Right 3B
#define .Collider_Floors_Down 3C
#define .Collider_Floors_Left 3D
%[Walls]
#define .Collider_Walls_Up 3F
#define .Collider_Walls_Right 40
#define .Collider_Walls_Down 41
#define .Collider_Walls_Left 42
%[Pillars]
% Up %
#define .Collider_Pillars_Up_100 45
#define .Collider_Pillars_Up_010 46
#define .Collider_Pillars_Up_001 47
% Down %
#define .Collider_Pillars_Down_100 49
#define .Collider_Pillars_Down_010 4A
#define .Collider_Pillars_Down_001 4B
%[Spikes]
%[[Spikesss]]%
% Floors %
#define .Collider_Spikes_Floors_1_Up 4E
#define .Collider_Spikes_Floors_1_Right 4F
#define .Collider_Spikes_Floors_1_Down 50
#define .Collider_Spikes_Floors_1_Left 51
%
#define .Collider_Spikes_Floors_2_Up 53
#define .Collider_Spikes_Floors_2_Right 54
#define .Collider_Spikes_Floors_2_Down 55
#define .Collider_Spikes_Floors_2_Left 56
% Corners %
#define .Collider_Spikes_Corners_1 59
#define .Collider_Spikes_Corners_2 5A
#define .Collider_Spikes_Corners_3 5B
#define .Collider_Spikes_Corners_4 5C

% [Waterpads]
% Walls
#define .Collider_Waterpads_Walls_Up 60
#define .Collider_Waterpads_Walls_Down 61
% Pools
#define .Collider_Waterpads_Pools_Up 63
#define .Collider_Waterpads_Pools_Down 64
% Pads
#define .Collider_Waterpads_Pads_Walls_1 66
#define .Collider_Waterpads_Pads_Walls_2 67
#define .Collider_Waterpads_Pads_Walls_3 68
#define .Collider_Waterpads_Pads_Walls_4 69
%
#define .Collider_Waterpads_Pads_Floor_1 6B
#define .Collider_Waterpads_Pads_Floor_2 6C
#define .Collider_Waterpads_Pads_Floor_3 6D
#define .Collider_Waterpads_Pads_Floor_4 6E

% Springs % Used when needing the Super Boots
#define .Collider_Spring_Top_1 72
#define .Collider_Spring_Top_2 73
#define .Collider_Spring_Top_3 74
#define .Collider_Spring_Top_4 75
%
#define .Collider_Spring_Wall_1 77
#define .Collider_Spring_Wall_2 78
#define .Collider_Spring_Wall_3 79
#define .Collider_Spring_Wall_4 7A

% Bombette
#define .Collider_Bombette_Up 7D
#define .Collider_Bombette_Right 7E
#define .Collider_Bombette_Down 7F
#define .Collider_Bombette_Left 80

% Blocks
#define .Collider_Block_Up 82
#define .Collider_Block_Right 83
#define .Collider_Block_Down 84
#define .Collider_Block_Left 85

% Sign
#export .Collider_Sign 88

% Define Rogue Flags
% Used to know which entity has been already used
#define .Rogue_Flag_Entity_1 *MapFlag[01]
#define .Rogue_Flag_Entity_2 *MapFlag[02]
#define .Rogue_Flag_Entity_3 *MapFlag[03]
#define .Rogue_Flag_Entity_4 *MapFlag[04]
#define .Rogue_Flag_Entity_5 *MapFlag[05]
#define .Rogue_Flag_Entity_6 *MapFlag[06]
#define .Rogue_Flag_Entity_7 *MapFlag[07]
#define .Rogue_Flag_Entity_8 *MapFlag[08]
#define .Rogue_Flag_Entity_9 *MapFlag[09]
#define .Rogue_Flag_Entity_10 *MapFlag[0A]
#define .Rogue_Flag_Entity_11 *MapFlag[0B]
#define .Rogue_Flag_Entity_12 *MapFlag[0C]

% Used to know which geomtry is active
#define .Rogue_Flag_Geometry_Stairs_1-1 *MapFlag[0D] % Up/Down Stairs
#define .Rogue_Flag_Geometry_Stairs_1-2 *MapFlag[0E] % Left/Right Stairs
#define .Rogue_Flag_Geometry_Stairs_2-1 *MapFlag[0F]
#define .Rogue_Flag_Geometry_Stairs_2-2 *MapFlag[10]
#define .Rogue_Flag_Geometry_Stairs_3-1 *MapFlag[11]
#define .Rogue_Flag_Geometry_Stairs_3-2 *MapFlag[12]
#define .Rogue_Flag_Geometry_Stairs_4-1 *MapFlag[13]
#define .Rogue_Flag_Geometry_Stairs_4-2 *MapFlag[14]
#define .Rogue_Flag_Geometry_Corners_1 *MapFlag[15]
#define .Rogue_Flag_Geometry_Corners_2 *MapFlag[16]
#define .Rogue_Flag_Geometry_Corners_3 *MapFlag[17]
#define .Rogue_Flag_Geometry_Corners_4 *MapFlag[18]
#define .Rogue_Flag_Geometry_Floors_Horizontal *MapFlag[19]
#define .Rogue_Flag_Geometry_Floors_Vertical *MapFlag[1A]
#define .Rogue_Flag_Geometry_Floors_Up *MapFlag[1B]
#define .Rogue_Flag_Geometry_Floors_Right *MapFlag[1C]
#define .Rogue_Flag_Geometry_Floors_Down *MapFlag[1D]
#define .Rogue_Flag_Geometry_Floors_Left *MapFlag[1E]
% Misc
#define .Reward_Pos *Var[A]
#define .Reward_TrapID *Var[B]